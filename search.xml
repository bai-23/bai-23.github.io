<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Centos7 零成本搭建web服务器【外网可访问】</title>
    <url>/2021/07/21/centosweb/</url>
    <content><![CDATA[<blockquote>
<p>更新：【Windows+Nginx+Natapp零成本搭建web服务器】教程即将上线 。</p>
</blockquote>
<span id="more"></span>

<p> 一、 <strong>技术栈</strong></p>
<blockquote>
<ul>
<li><em>虚拟机</em>：当然是选择 Linux 系统，本人使用的是 ==centos7== 版本。</li>
<li><em>服务器</em>：轻量级服务器nginx，10分钟搭建静态网站。</li>
<li><em>内网穿透</em>：使用Natapp，访问内网。</li>
</ul>
</blockquote>
<hr>
<p>二、<strong>步骤</strong></p>
<ol>
<li><p><strong>Linux系统安装与配置</strong></p>
<blockquote>
<p><em>安装linux虚拟机就跳过吧，网上一大把，当然最好是Centos系统哦。</em></p>
</blockquote>
</li>
</ol>
<ul>
<li><p>配置<br>由于是自己创建的虚拟机，需要手动打开80端口，重新配置防火墙，以及切换源。下面开始吧。</p>
<p>  <strong>==a.切换阿里源==</strong></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">备份：mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br><span class="line">清理缓存：yum clean all</span><br><span class="line">生成缓存：yum makecache</span><br></pre></td></tr></table></figure>
<p>  <strong>==b.防火墙配置==</strong></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service <span class="comment">#停止firewall</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service <span class="comment">#禁止firewall开机启动</span></span><br><span class="line">yum install iptables-services <span class="comment">#安装iptables防火墙</span></span><br><span class="line">yum install iptables-services <span class="comment">#安装iptables防火墙</span></span><br></pre></td></tr></table></figure>
<p>  <strong>==c.开启80端口==</strong></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/sysconfig/iptables <span class="comment">#编辑防火墙配置文件</span></span><br><span class="line">按i进入文本编辑模式</span><br><span class="line">找到：</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT</span><br><span class="line">在该行下面添加：</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT</span><br><span class="line">保存退出：先按ESC，再输入【:wq!】输入括号里的内容。</span><br></pre></td></tr></table></figure>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart iptables.service <span class="comment">#重启防火墙使配置生效</span></span><br><span class="line">systemctl <span class="built_in">enable</span> iptables.service <span class="comment">#设置防火墙开机启动</span></span><br><span class="line">firewall-cmd --query-port=80/tcp <span class="comment">#查询端口是否开启</span></span><br></pre></td></tr></table></figure>
<hr>
<p>   <strong>2. 配置Nginx服务器</strong></p>
<blockquote>
<p><em>简介</em>：Nginx是一个http服务器。是一个使用c语言开发的高性能的http服务器及反向代理服务器。Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。</p>
</blockquote>
<p>  <strong>==a.安装环境==</strong></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc依赖：yum install gcc-c++</span><br><span class="line">Perl库：yum install -y pcre pcre-devel</span><br><span class="line">zlib库：yum install -y zlib zlib-devel</span><br><span class="line">yum install -y openssl openssl-devel</span><br><span class="line">nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。</span><br></pre></td></tr></table></figure>
<p>  <strong>==b.安装==</strong></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span></span><br><span class="line">mkdir nginx</span><br><span class="line"><span class="built_in">cd</span> nginx	<span class="comment">#进入nginx文件夹</span></span><br><span class="line"></span><br><span class="line">wget http://nginx.org/download/nginx-1.9.7.tar.gz</span><br><span class="line">tar -zxvf nginx-1.9.7.tar.gz	<span class="comment">#解压</span></span><br><span class="line"></span><br><span class="line">./configure		<span class="comment">#安装nginx</span></span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> sbin</span><br><span class="line">sudo ./nginx	<span class="comment">#启动</span></span><br><span class="line"></span><br><span class="line">/usr/<span class="built_in">local</span>/nginx/sbin/nginx -t	<span class="comment">#查询nginx.conf是否正确</span></span><br></pre></td></tr></table></figure>
<p>  <strong>==c.配置网站文件==</strong></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">准备好自己写的网页，以目录形式上传到 /usr/<span class="built_in">local</span>/nginx/xxx/ 路径（xxx为网站跟目录名）</span><br><span class="line"><span class="built_in">cd</span> nginx</span><br><span class="line">vim conf/nginx.conf		<span class="comment">#使用vim编辑器</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       <span class="number">80</span>;</span><br><span class="line">    server_name  _;</span><br><span class="line">    <span class="comment">#root /usr/local/nginx/xxx/;      # 修改1：xxx为静态页面根目录，index.html文件放在xxx下面</span></span><br><span class="line">    <span class="comment">#index index.html;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/local/nginx/xxx/;	<span class="comment"># 修改2</span></span><br><span class="line">        index  index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /<span class="number">50</span>x.html;</span><br><span class="line">    location = /<span class="number">50</span>x.html &#123;</span><br><span class="line">        root   html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./nginx -s reload 	<span class="comment">#重启</span></span><br><span class="line"></span><br><span class="line">ps aux|grep nginx	<span class="comment">#查询nginx进程</span></span><br><span class="line"></span><br><span class="line">./nginx -s stop		<span class="comment">#停止</span></span><br></pre></td></tr></table></figure></li>
</ul>
<pre><code>&gt;   到这里，就可以实现内网之间的访问了，通过ifconfig查询桥接模式下的内网地址，在本机搜索即可进入网站。但是，做好网站只有自己能看还挺不爽的，接下来就是让别人可以访问的操作辽~

---
**3.Natapp实现内网穿透**
&gt; *简介*：内网穿透简单来说就是将内网外网通过natapp隧道打通,让内网的数据让外网可以获取。比如常用的办公室软件等，一般在办公室或家里，通过拨号上网，这样办公软件只有在本地的局域网之内才能访问，那么问题来了，如果是手机上，或者公司外地的办公人员，如何访问到办公软件呢？这就需要natapp内网穿透工具了。运行natapp隧道之后，natapp会分配一个专属域名/端口,办公软件就已经在公网上了,在外地的办公人员可以在任何地方愉快的访问办公软件了~

&gt; emmm一句话：别人可以访问你的192.168.xxx.xxx
Natapp网址：[点这里](https://natapp.cn/)

**==a.购买隧道==**

- 注册账号
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201207104539729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ3NjU0MDEw,size_16,color_FFFFFF,t_70)
- 登录，购买隧道（免费版）
- 选择web隧道协议![在这里插入图片描述](https://img-blog.csdnimg.cn/20201207104746667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ3NjU0MDEw,size_16,color_FFFFFF,t_70)
- 获取authtoken，启动时需要用
![在这里插入图片描述](https://img-blog.csdnimg.cn/2020120710531049.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ3NjU0MDEw,size_16,color_FFFFFF,t_70)

**==b.下载客户端==**
&gt; Linux可直接wget
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20201207105027387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ3NjU0MDEw,size_14,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<pre><code>**==c.运行Natapp==**
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">chmod a+x natapp	<span class="comment">#给执行权限</span></span><br><span class="line">./natapp			<span class="comment">#运行</span></span><br><span class="line"></span><br><span class="line">./natapp <span class="literal">-authtoken</span>=<span class="number">9</span>ab6b9040a624f40	<span class="comment">#参数方式运行，authtoken购买隧道后即可在控制台查看</span></span><br><span class="line">注意参数输入正确性,不要有多余的空格等!</span><br></pre></td></tr></table></figure>


&gt; 运行成功结果：![在这里插入图片描述](https://img-blog.csdnimg.cn/2020120711005848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ3NjU0MDEw,size_16,color_FFFFFF,t_70)
</code></pre>
<p>红框内的网址就是你的内网地址了，接下来就可以访问了，可以发给您的小伙伴试试~</p>
<pre><code>&gt;更多内容，欢迎访问 [宋木头](http://aoau.top/) ~
</code></pre>
<hr>
<p>原创不易，转载请注明出处：)</p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript动态显示时间</title>
    <url>/2021/07/21/%5B%20JavaScript%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%98%BE%E7%A4%BA%E6%97%B6%E9%97%B4%E6%95%88%E6%9E%9C%EF%BC%9AsetInterval%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%20%5D/</url>
    <content><![CDATA[<p><strong>知识点</strong></p>
<span id="more"></span>

<blockquote>
<p>Timing事件之 setInterval()方法：<img src="https://img-blog.csdnimg.cn/20200809150657625.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ3NjU0MDEw,size_16,color_FFFFFF,t_70"></p>
</blockquote>
<p><strong>效果</strong><br><img src="https://img-blog.csdnimg.cn/20200809150619988.jpg"></p>
<p><strong>上代码</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;time&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;开始&quot;</span> <span class="attr">id</span>=<span class="string">&quot;start&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;结束&quot;</span> <span class="attr">id</span>=<span class="string">&quot;end&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> start = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;start&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> end = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;end&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> time1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;time&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        start.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            </span></span><br><span class="line"><span class="javascript">            <span class="comment">// clearInterval(timer);</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            timer = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                </span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="javascript">                <span class="comment">//  年月日</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> year = d.getFullYear();</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> month = d.getMonth()+<span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> day = d.getDate();</span></span><br><span class="line"><span class="javascript">                <span class="comment">//  时分秒</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> h = d.getHours();</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> m = d.getMinutes();</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> s = d.getSeconds();</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(s&lt;<span class="number">10</span>)&#123;</span></span><br><span class="line"><span class="javascript">                    s = <span class="string">&quot;0&quot;</span>+s;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// time1.innerHTML = s;</span></span></span><br><span class="line"><span class="javascript">                time1.innerHTML = <span class="string">&quot;当前时间：&quot;</span>+year+<span class="string">&quot;-&quot;</span>+month+<span class="string">&quot;-&quot;</span>+day+<span class="string">&quot; &quot;</span>+h+<span class="string">&quot;:&quot;</span>+m+<span class="string">&quot;:&quot;</span>+s;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            &#125;,<span class="number">100</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            end.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">clearInterval</span>(timer);</span></span><br><span class="line"><span class="javascript">                <span class="comment">// alert(&#x27;stop&#x27;);</span></span></span><br><span class="line"><span class="javascript">            &#125;;</span></span><br><span class="line"><span class="javascript">        &#125;;</span></span><br><span class="line"><span class="javascript">        </span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
        <category>frontend</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>建站随笔</title>
    <url>/2021/07/20/hello-world/</url>
    <content><![CDATA[<p>…</p>
<span id="more"></span>


<h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="新建页面"><a href="#新建页面" class="headerlink" title="新建页面"></a>新建页面</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page ‘title’</span><br></pre></td></tr></table></figure>

<h3 id="提交Git"><a href="#提交Git" class="headerlink" title="提交Git"></a>提交Git</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<h3 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo s --debug</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>随笔</category>
        <category>hexo&amp;next</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫</title>
    <url>/2021/07/21/spider/</url>
    <content><![CDATA[<h2 id="一、爬虫基础简介"><a href="#一、爬虫基础简介" class="headerlink" title="一、爬虫基础简介"></a>一、爬虫基础简介</h2><span id="more"></span>

<h3 id="前戏"><a href="#前戏" class="headerlink" title="前戏"></a><strong>前戏</strong></h3><p>​    1.你是否在夜深人静的时候，想看一些会让你更睡不着的图片却苦于没有资源…<br>​    2.你是否在节假日出行高峰的时候，想快速抢购火车票成功…<br>​    3.你是否在网上购物的时候，想快速且精准的定位到口碑质量最好的商品…</p>
<p><strong>什么是爬虫</strong>：</p>
<pre><code>- 通过编写程序，模拟浏览器上网，然后让其去互联网上抓取数据的过程。
</code></pre>
<p><strong>爬虫的价值</strong>：<br>    - 实际应用<br>        - 就业</p>
<p><strong>爬虫究竟是合法还是违法的</strong>？</p>
<ul>
<li>在法律中是不被禁止</li>
<li>具有违法风险</li>
<li>善意爬虫  恶意爬虫</li>
</ul>
<p><strong>爬虫带来的风险可以体现在如下</strong>2方面：<br>    - 爬虫干扰了被访问网站的正常运营<br>        - 爬虫抓取了收到法律保护的特定类型的数据或信息</p>
<p><strong>如何在使用编写爬虫的过程中避免进入局子的厄运呢</strong>？<br>    - 时常的优化自己的程序，避免干扰被访问网站的正常运行<br>        - 在使用，传播爬取到的数据时，审查抓取到的内容，如果发现了涉及到用户隐私<br>        商业机密等敏感内容需要及时停止爬取或传播</p>
<p><strong>爬虫在使用场景中的分类</strong></p>
<ul>
<li><p>通用爬虫：<br>抓取系统重要组成部分。抓取的是一整张页面数据。</p>
</li>
<li><p> 聚焦爬虫：</p>
</li>
</ul>
<p>  是建立在通用爬虫的基础之上。抓取的是页面中特定的局部内容。</p>
<ul>
<li>增量式爬虫：<br>检测网站中数据更新的情况。只会抓取网站中最新更新出来的数据。</li>
</ul>
<p><strong>爬虫的矛与盾</strong></p>
<p><strong>反爬机制</strong><br>    门户网站，可以通过制定相应的策略或者技术手段，防止爬虫程序进行网站数据的爬取。</p>
<p><strong>反反爬策略</strong><br>    爬虫程序可以通过制定相关的策略或者技术手段，破解门户网站中具备的反爬机制，从而可以获取门户网站中相关的数据。</p>
<p><strong>robots.txt</strong>协议：<br>    君子协议。规定了网站中哪些数据可以被爬虫爬取哪些数据不可以被爬取。</p>
<h3 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a><strong>http</strong>协议</h3><ul>
<li><p>概念：就是<code>服务器</code>和<code>客户端</code>进行数据交互的一种形式。</p>
</li>
<li><p><strong>常用请求头信息</strong></p>
<ul>
<li>User-Agent：请求载体的身份标识</li>
<li>Connection：请求完毕后，是断开连接还是保持连接</li>
</ul>
</li>
<li><p><strong>常用响应头信息</strong></p>
<ul>
<li>Content-Type：服务器响应回客户端的数据类型</li>
</ul>
</li>
</ul>
<p><strong>https</strong>协议：</p>
<pre><code>- 安全的超文本传输协议
</code></pre>
<p><strong>加密方式</strong></p>
<ul>
<li>对称秘钥加密<pre><code>  - 可能被第三方拦截
</code></pre>
</li>
<li>非对称秘钥加密<pre><code>  - 速度慢
  - 公钥可能被篡改
</code></pre>
</li>
<li>证书秘钥加密<pre><code>  - 给公钥数字签名
</code></pre>
</li>
</ul>
<h2 id="二、requests模块"><a href="#二、requests模块" class="headerlink" title="二、requests模块"></a>二、requests模块</h2><ul>
<li>网络请求模块<ul>
<li>urllib模块</li>
<li><strong>requests模块</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>requests模块：python中原生的一款基于网络请求的模块，功能非常强大，简单便捷，效率极高。</p>
<p>作用：<strong>模拟浏览器发请求</strong>。</p>
</blockquote>
<h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><blockquote>
<p>requests模块的编码流程</p>
</blockquote>
<ul>
<li>指定url<ul>
<li>UA伪装</li>
<li>请求参数的处理</li>
</ul>
</li>
<li>发起请求<ul>
<li>获取响应数据</li>
</ul>
</li>
<li>持久化存储</li>
</ul>
<h4 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h4><p> <code>pip install requests</code></p>
<h4 id="实战编码"><a href="#实战编码" class="headerlink" title="实战编码"></a>实战编码</h4><ul>
<li>需求：爬取搜狗首页的页面数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># - 需求：爬取搜狗首页的页面数据</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># step_1:指定url</span></span><br><span class="line">    url = <span class="string">&#x27;https://www.sogou.com/&#x27;</span></span><br><span class="line">    <span class="comment"># step_2:发起请求</span></span><br><span class="line">    <span class="comment"># get方法会返回一个响应对象</span></span><br><span class="line">    response = requests.get(url=url)</span><br><span class="line">    <span class="comment"># step_3:获取响应数据.text返回的是字符串形式的响应数据</span></span><br><span class="line">    page_text = response.text</span><br><span class="line">    <span class="built_in">print</span>(page_text)</span><br><span class="line">    <span class="comment"># step_4:持久化存储</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./sogou.html&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(page_text)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;爬取数据结束！！！&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="实战巩固"><a href="#实战巩固" class="headerlink" title="实战巩固"></a>实战巩固</h4><ul>
<li><p>需求：爬取搜狗指定词条对应的搜索结果页面（简易网页采集器）</p>
<ul>
<li><p><strong>UA检测</strong></p>
<blockquote>
<p>UA：User-Agent（请求载体的身份标识）.</p>
<p>门户网站的服务器会检测对应请求的载体身份标识，如果检测到请求的载体身份标识为某一款浏览器，说明该请求是一个正常的请求。但是，如果检测到请求的载体身份标识不是基于某一款浏览器的，则表示该请求为不正常的请求（爬虫），则服务器端就很有可能拒绝该次请求。</p>
</blockquote>
</li>
<li><p><strong>UA伪装</strong>: 将对应的User-Agent封装到一个字典中</p>
<blockquote>
<p>让爬虫对应的请求载体身份标识伪装成某一款浏览器</p>
</blockquote>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>需求：破解百度翻译(获取翻译结果)</p>
<ul>
<li>post请求（携带了参数）</li>
<li>响应数据是一组json数据</li>
</ul>
</li>
<li><p>需求：爬取豆瓣电影分类排行榜 <a href="https://movie.douban.com/%E4%B8%AD%E7%9A%84%E7%94%B5%E5%BD%B1%E8%AF%A6%E6%83%85%E6%95%B0%E6%8D%AE">https://movie.douban.com/中的电影详情数据</a></p>
</li>
<li><p>作业：爬取肯德基餐厅查询<a href="http://www.kfc.com.cn/kfccda/index.aspx%E4%B8%AD%E6%8C%87%E5%AE%9A%E5%9C%B0%E7%82%B9%E7%9A%84%E9%A4%90%E5%8E%85%E6%95%B0%E6%8D%AE">http://www.kfc.com.cn/kfccda/index.aspx中指定地点的餐厅数据</a></p>
</li>
<li><p>需求：爬取国家药品监督管理总局中基于中华人民共和国化妆品生产许可证相关数据</p>
<pre><code>      http://scxk.nmpa.gov.cn:81/xk/
  
</code></pre>
<ul>
<li>动态加载数据</li>
</ul>
</li>
<li><p>首页中对应的企业信息数据是通过ajax动态请求到的。</p>
<pre><code>http://125.35.6.84:81/xk/itownet/portal/dzpz.jsp?id=e6c1aa332b274282b04659a6ea30430a
http://125.35.6.84:81/xk/itownet/portal/dzpz.jsp?id=f63f61fe04684c46a016a45eac8754fe
</code></pre>
<ul>
<li>通过对详情页url的观察发现：<ul>
<li>url的域名都是一样的，只有携带的参数（id）不一样</li>
<li>id值可以从首页对应的ajax请求到的json串中获取</li>
<li>域名和id值拼接处一个完整的企业对应的详情页的url</li>
</ul>
</li>
<li>详情页的企业详情数据也是动态加载出来的<ul>
<li><a href="http://125.35.6.84:81/xk/itownet/portalAction.do?method=getXkzsById">http://125.35.6.84:81/xk/itownet/portalAction.do?method=getXkzsById</a></li>
<li><a href="http://125.35.6.84:81/xk/itownet/portalAction.do?method=getXkzsById">http://125.35.6.84:81/xk/itownet/portalAction.do?method=getXkzsById</a></li>
<li>观察后发现：<ul>
<li>所有的post请求的url都是一样的，只有参数id值是不同。</li>
<li>如果我们可以批量获取多家企业的id后，就可以将id和url形成一个完整的详情页对应详情数据的ajax请求的url</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="三、数据解析"><a href="#三、数据解析" class="headerlink" title="三、数据解析"></a>三、数据解析</h2><blockquote>
<p>聚焦爬虫、正则、bs4、xpath</p>
</blockquote>
<h4 id="聚焦爬虫"><a href="#聚焦爬虫" class="headerlink" title="聚焦爬虫"></a>聚焦爬虫</h4><p>定义：爬取页面中指定的页面内容。</p>
<p>编码流程：</p>
<ul>
<li>指定url</li>
<li>发起请求</li>
<li>获取响应数据</li>
<li>数据解析</li>
<li>持久化存储</li>
</ul>
<h4 id="数据解析分类"><a href="#数据解析分类" class="headerlink" title="数据解析分类"></a>数据解析分类</h4><ul>
<li>正则</li>
<li>bs4</li>
<li>xpath（***）</li>
</ul>
<p><strong>数据解析原理概述</strong></p>
<ul>
<li>解析的局部的文本内容都会在<strong>标签之间或者标签对应的属性中进行存储</strong></li>
<li>1.<strong>进行指定标签的定位</strong></li>
<li>2.标签或者标签对应的<strong>属性</strong>中存储的<strong>数据</strong>值进行<strong>提取（解析）</strong></li>
</ul>
<h5 id="正则解析"><a href="#正则解析" class="headerlink" title="正则解析"></a><strong>正则解析</strong></h5><p>回顾</p>
<p><img src="C:\Users\86136\Pictures\学习\rep.png" alt="正则表达式"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#提取出python</span></span><br><span class="line">key=<span class="string">&quot;javapythonc++php&quot;</span></span><br><span class="line">re.findall(<span class="string">&#x27;python&#x27;</span>,key)[<span class="number">0</span>]</span><br><span class="line"><span class="comment">########################################################</span></span><br><span class="line"><span class="comment">#提取出hello world</span></span><br><span class="line">key=<span class="string">&quot;</span></span><br><span class="line"><span class="string">hello world</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line">re.findall(<span class="string">&#x27;</span></span><br><span class="line"><span class="string">(.*)</span></span><br><span class="line"><span class="string">&#x27;</span>,key)[<span class="number">0</span>]</span><br><span class="line"><span class="comment">########################################################</span></span><br><span class="line"><span class="comment">#提取170</span></span><br><span class="line">string = <span class="string">&#x27;我喜欢身高为170的女孩&#x27;</span></span><br><span class="line">re.findall(<span class="string">&#x27;\d+&#x27;</span>,string)</span><br><span class="line"><span class="comment">########################################################</span></span><br><span class="line"><span class="comment">#提取出http://和https://</span></span><br><span class="line">key=<span class="string">&#x27;http://www.baidu.com and https://boob.com&#x27;</span></span><br><span class="line">re.findall(<span class="string">&#x27;https?://&#x27;</span>,key)</span><br><span class="line"><span class="comment">########################################################</span></span><br><span class="line"><span class="comment">#提取出hello</span></span><br><span class="line">key=<span class="string">&#x27;lalalahellohahah&#x27;</span> <span class="comment">#输出hello</span></span><br><span class="line">re.findall(<span class="string">&#x27;&lt;[Hh][Tt][mM][lL]&gt;(.*)&#x27;</span>,key)</span><br><span class="line"><span class="comment">########################################################</span></span><br><span class="line"><span class="comment">#提取出hit. </span></span><br><span class="line">key=<span class="string">&#x27;bobo@hit.edu.com&#x27;</span><span class="comment">#想要匹配到hit.</span></span><br><span class="line">re.findall(<span class="string">&#x27;h.*?\.&#x27;</span>,key)</span><br><span class="line"><span class="comment">########################################################</span></span><br><span class="line"><span class="comment">#匹配sas和saas</span></span><br><span class="line">key=<span class="string">&#x27;saas and sas and saaas&#x27;</span></span><br><span class="line">re.findall(<span class="string">&#x27;sa&#123;1,2&#125;s&#x27;</span>,key)</span><br></pre></td></tr></table></figure>



<h5 id="bs4进行数据解析"><a href="#bs4进行数据解析" class="headerlink" title="bs4进行数据解析"></a><strong>bs4进行数据解析</strong></h5><pre><code>- 数据解析的原理：
    - 1.标签定位
    - 2.提取标签、标签属性中存储的数据值
</code></pre>
<ul>
<li>bs4数据解析的原理：<ul>
<li>1.实例化一个BeautifulSoup对象，并且将页面源码数据加载到该对象中</li>
<li>2.通过调用BeautifulSoup对象中相关的属性或者方法进行标签定位和数据提取</li>
</ul>
</li>
<li>环境安装：<ul>
<li><code>pip install bs4</code></li>
<li><code>pip install lxml</code></li>
</ul>
</li>
<li>如何实例化BeautifulSoup对象：<ul>
<li><code>from bs4 import BeautifulSoup</code></li>
<li>对象的实例化：<ul>
<li>1.将本地的html文档中的数据加载到该对象中<pre><code>  `fp = open(&#39;./test.html&#39;,&#39;r&#39;,encoding=&#39;utf-8&#39;)`
 ` soup = BeautifulSoup(fp,&#39;lxml&#39;)`
</code></pre>
</li>
<li>2.将互联网上获取的页面源码加载到该对象中<pre><code>  `page_text = response.text`
</code></pre>
  <code> soup = BeatifulSoup(page_text,&#39;lxml&#39;)</code></li>
</ul>
</li>
<li>提供的用于数据解析的方法和属性：<ul>
<li><code>soup.tagName</code>:返回的是文档中第一次出现的tagName对应的标签</li>
<li><code>soup.find()</code>:<ul>
<li><code>find(&#39;tagName&#39;)</code>:等同于<code>soup.div</code></li>
<li>属性定位：<br>  <code>soup.find(&#39;div&#39;,class_/id/attr=&#39;song&#39;)</code></li>
</ul>
</li>
<li><code>soup.find_all(&#39;tagName&#39;)</code>:返回符合要求的所有标签（列表）</li>
</ul>
</li>
<li><code>select</code>：<ul>
<li>select(‘某种选择器（id，class，标签…选择器）’),返回的是一个列表。</li>
<li>层级选择器：<ul>
<li><code>soup.select(&#39;.tang &gt; ul &gt; li &gt; a&#39;)</code>：&gt;表示的是一个层级</li>
<li><code>oup.select(&#39;.tang &gt; ul a&#39;)</code>：空格表示的多个层级</li>
</ul>
</li>
</ul>
</li>
<li>获取标签之间的文本数据：<ul>
<li>soup.a.text/string/get_text()</li>
<li>text/get_text():可以获取某一个标签中所有的文本内容</li>
<li>string：只可以获取该标签下面直系的文本内容</li>
</ul>
</li>
<li>获取标签中属性值：<ul>
<li>soup.a[‘href’]</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="xpath解析"><a href="#xpath解析" class="headerlink" title="xpath解析"></a>xpath解析</h5><blockquote>
<p>最常用且最便捷高效的一种解析方式。通用性。</p>
</blockquote>
<ul>
<li>xpath解析原理：<ul>
<li>1.实例化一个etree的对象，且需要将被解析的页面源码数据加载到该对象中。</li>
<li>2.调用etree对象中的xpath方法结合着xpath表达式实现标签的定位和内容的捕获。</li>
</ul>
</li>
<li>环境的安装：<ul>
<li>pip install lxml</li>
</ul>
</li>
<li>如何实例化一个etree对象:from lxml import etree<ul>
<li>1.将<strong>本地</strong>的html文档中的源码数据加载到etree对象中：<br>  etree.parse(filePath)</li>
<li>2.可以将从<strong>互联网</strong>上获取的源码数据加载到该对象中<br>  etree.HTML(‘page_text’)</li>
<li>xpath(‘xpath表达式’)</li>
</ul>
</li>
<li>xpath表达式:<ul>
<li><strong>/</strong>: 表示的是从根节点开始定位。表示的是一个层级。</li>
<li><strong>//</strong>: 表示的是多个层级。可以表示从任意位置开始定位。</li>
<li><strong>属性定位</strong>：//div[@class=’song’] tag[@attrName=”attrValue”]</li>
<li><strong>索引定位</strong>：//div[@class=”song”]/p[3] 索引是从1开始的。</li>
<li><strong>取文本</strong>：<ul>
<li>/text() 获取的是标签中直系的文本内容</li>
<li>//text() 标签中非直系的文本内容（所有的文本内容）</li>
</ul>
</li>
<li><strong>取属性</strong>：<br>  /@attrName     ==&gt;img/src</li>
</ul>
</li>
</ul>
<p>作业：<br>    爬取站长素材中免费简历模板</p>
<h2 id="四、验证码识别"><a href="#四、验证码识别" class="headerlink" title="四、验证码识别"></a>四、验证码识别</h2><h5 id="验证码和爬虫之间的关系"><a href="#验证码和爬虫之间的关系" class="headerlink" title="验证码和爬虫之间的关系"></a>验证码和爬虫之间的关系</h5><ul>
<li>反爬机制：验证码.识别验证码图片中的数据，用于模拟登陆操作。</li>
</ul>
<h5 id="识别验证码的操作"><a href="#识别验证码的操作" class="headerlink" title="识别验证码的操作"></a>识别验证码的操作</h5><pre><code>- 人工肉眼识别。（不推荐）
    - 第三方自动识别（推荐）
    - 云打码：http://www.yundama.com/demo.html
</code></pre>
<ul>
<li>云打码的使用流程：<ul>
<li>注册：普通和开发者用户</li>
<li>登录：<ul>
<li>普通用户的登录：查询该用户是否还有剩余的题分</li>
<li>开发者用户的登录：<ul>
<li>创建一个软件：我的软件-》添加新软件-》录入软件名称-》提交（软件id和秘钥）</li>
<li>下载示例代码：开发文档-》点此下载：云打码接口DLL-》PythonHTTP示例下载</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="实战：识别古诗文网登录页面中的验证码"><a href="#实战：识别古诗文网登录页面中的验证码" class="headerlink" title="实战：识别古诗文网登录页面中的验证码"></a>实战：识别古诗文网登录页面中的验证码</h5><p>使用打码平台识别验证码的编码流程：</p>
<ul>
<li>将验证码图片进行本地下载</li>
<li>调用平台提供的示例代码进行图片数据识别</li>
</ul>
<h2 id="五、request高级"><a href="#五、request高级" class="headerlink" title="五、request高级"></a>五、request高级</h2><h4 id="模拟登录"><a href="#模拟登录" class="headerlink" title="模拟登录"></a>模拟登录</h4><ul>
<li>爬取基于某些用户的用户信息。</li>
</ul>
<h4 id="需求1"><a href="#需求1" class="headerlink" title="需求1"></a>需求1</h4><blockquote>
<p>对人人网进行模拟登录。</p>
</blockquote>
<ul>
<li>点击登录按钮之后会发起一个post请求</li>
<li>post请求中会携带登录之前录入的相关的登录信息（用户名，密码，验证码……）</li>
<li>验证码：每次请求都会变化</li>
</ul>
<h4 id="需求2"><a href="#需求2" class="headerlink" title="需求2"></a>需求2</h4><blockquote>
<p>爬取当前用户的相关的用户信息（个人主页中显示的用户信息）</p>
</blockquote>
<h4 id="cookie与session"><a href="#cookie与session" class="headerlink" title="cookie与session"></a>cookie与session</h4><p>http/https协议特性：无状态。<br>没有请求到对应页面数据的原因：<br>    发起的第二次基于个人主页页面请求的时候，服务器端并不知道该此请求是基于登录状态下的请求。<br>cookie：用来让服务器端记录客户端的相关状态。</p>
<ul>
<li>手动处理：通过抓包工具获取cookie值，将该值封装到headers中。（不建议）</li>
<li>自动处理：<ul>
<li>cookie值的来源是哪里？<ul>
<li>模拟登录post请求后，由服务器端创建。</li>
</ul>
</li>
<li><strong>session会话对象</strong>：<ul>
<li>作用：<br>  1.可以进行请求的发送。<br>  2.如果请求过程中产生了cookie，则该cookie会被自动存储/携带在该session对象中。</li>
</ul>
</li>
<li>创建一个session对象：session = requests.Session()</li>
<li>使用session对象进行模拟登录post请求的发送（cookie就会被存储在session中）</li>
<li>session对象对个人主页对应的get请求进行发送（携带了cookie）</li>
</ul>
</li>
</ul>
<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><blockquote>
<p>破解封IP这种反爬机制。</p>
</blockquote>
<p>什么是代理：</p>
<ul>
<li>代理服务器。</li>
</ul>
<p>代理的作用：</p>
<ul>
<li>突破自身IP访问的限制。</li>
<li>隐藏自身真实IP</li>
</ul>
<p>代理相关的网站：</p>
<ul>
<li>快代理</li>
<li>西祠代理</li>
<li><a href="http://www.goubanjia.com/">www.goubanjia.com</a></li>
</ul>
<p>代理ip的类型：</p>
<ul>
<li>http：应用到http协议对应的url中</li>
<li>https：应用到https协议对应的url中</li>
</ul>
<p>代理ip的匿名度：</p>
<ul>
<li>透明：服务器知道该次请求使用了代理，也知道请求对应的真实ip</li>
<li>匿名：知道使用了代理，不知道真实ip</li>
<li>高匿：不知道使用了代理，更不知道真实的ip</li>
</ul>
<h2 id="六、异步爬虫"><a href="#六、异步爬虫" class="headerlink" title="六、异步爬虫"></a>六、异步爬虫</h2><p>目的：在爬虫中使用异步实现高性能的数据爬取操作。</p>
<p>异步爬虫的方式：<br>    - 1.多线程，多进程（不建议）：<br>            好处：可以为相关阻塞的操作单独开启线程或者进程，阻塞操作就可以异步执行。<br>            弊端：无法无限制的开启多线程或者多进程。<br>    - 2.线程池、进程池（适当的使用）：<br>    好处：我们可以降低系统对进程或者线程创建和销毁的一个频率，从而很好的降低系统的开销。<br>    弊端：池中线程或进程的数量是有上限。</p>
<ul>
<li><p>3.单线程+异步协程（推荐）：<br>  <strong>event_loop</strong>：事件循环，相当于一个无限循环，我们可以把一些函数注册到这个事件循环上，<br>  当满足某些条件的时候，函数就会被循环执行。</p>
<p>  <strong>coroutine</strong>：协程对象，我们可以将协程对象注册到事件循环中，它会被事件循环调用。<br>  我们可以使用 async 关键字来定义一个方法，这个方法在调用时不会立即被执行，而是返回<br>  一个协程对象。</p>
<p>  <strong>task</strong>：任务，它是对协程对象的进一步封装，包含了任务的各个状态。</p>
<p>  <strong>future</strong>：代表将来执行或还没有执行的任务，实际上和 task 没有本质区别。</p>
<p>  <strong>async</strong> 定义一个协程.</p>
<p>  await 用来挂起阻塞方法的执行。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>code</category>
        <category>backend</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>小舍免费图片Api</title>
    <url>/2021/07/21/xiaoshesapi/</url>
    <content><![CDATA[<blockquote>
<p>项目名称：小舍图片Api接口</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>开发人员：熙子黒</p>
<p>开源协议：MIT</p>
<p>感谢你的使用，如果喜欢请给仓库点个star：<a href="https://github.com/bai-23/photosapi">https://github.com/bai-23/photosapi</a></p>
<p>此接口已接入本人项目(小舍社交app)，请放心食用：<a href="https://github.com/bai-23/italk-uniapp">https://github.com/bai-23/italk-uniapp</a></p>
<p>注意：<strong>个人接口，请勿商用。图片收集不易，请珍惜食用。部分图片较大加载缓慢，请耐心等待。</strong></p>
</blockquote>
<h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><p>地址：<code>http://api.aoau.top</code></p>
<p>方法：<code>GET</code></p>
<table>
<thead>
<tr>
<th>url</th>
<th>参数</th>
<th>值</th>
<th>必须</th>
</tr>
</thead>
<tbody><tr>
<td>/photos/api</td>
<td>page</td>
<td>number</td>
<td>是</td>
</tr>
</tbody></table>
<h3 id="ajax请求示例"><a href="#ajax请求示例" class="headerlink" title="ajax请求示例"></a>ajax请求示例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">fetchPhotos</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="built_in">this</span>.$http.get(<span class="string">&#x27;http://api.aoau.top/photos/api?page=9&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>示例url：<code>http://api.aoau.top/photos/api?page=9</code></p>
<p>返回值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res:&#123;</span><br><span class="line">    <span class="string">&quot;status&quot;</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="string">&quot;msg&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;photoNum&quot;</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="string">&quot;category&quot;</span>: <span class="string">&quot;写真4&quot;</span>,</span><br><span class="line">        <span class="string">&quot;author&quot;</span>: <span class="string">&quot;收集不易，请珍惜接口，更多资源请访问Github:https://github.com/bai-23/photosapi&quot;</span>,</span><br><span class="line">        <span class="string">&quot;photoList&quot;</span>: [</span><br><span class="line">            xxx.jpg</span><br><span class="line">            ...</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;tips&quot;</span>: <span class="string">&quot;部分图片较大，加载速度较慢，请谅解。图片来源于互联网，仅供个人使用，请勿商用！&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：参数page范围为：1~14，请填写正确。</p>
<p>（建议线路5~14）</p>
</blockquote>
<hr>
<p>下面是测试，其他线路请自行尝试<br><a href="http://api.aoau.top:9999/photos/1/%20%2816%29.png">线路1</a><br><a href="http://api.aoau.top:9999/photos/2/%20%2819%29.png">线路2</a><br><a href="http://api.aoau.top:9999/photos/3/%20%2834%29.png">线路3</a><br><a href="http://api.aoau.top:9999/photos/4/%20%2883%29.png">线路4</a><br><a href="http://api.aoau.top:9999/photos/8/%20%2830%29.jpg">线路8</a><br><a href="http://api.aoau.top:9999/photos/14/%20%2860%29.jpg">线路14</a></p>
]]></content>
      <categories>
        <category>apis</category>
        <category>图片api</category>
      </categories>
      <tags>
        <tag>图片Api</tag>
        <tag>NodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title>【JavaScript 随笔】DOM事件之——拖拽的实现与简单优化</title>
    <url>/2021/07/21/%E3%80%90JavaScript%20%E9%9A%8F%E7%AC%94%E3%80%91DOM%E4%BA%8B%E4%BB%B6%E4%B9%8B%E2%80%94%E2%80%94%E6%8B%96%E6%8B%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h5 id="效果"><a href="#效果" class="headerlink" title="效果"></a><em>效果</em></h5><p><code>鼠标点击文档中任意元素拖拽至任意位置。</code></p>
<span id="more"></span>

<h5 id="思路与流程"><a href="#思路与流程" class="headerlink" title="思路与流程"></a><em>思路与流程</em></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">鼠标按下时，开始拖拽：onmousedown</span><br><span class="line">鼠标移动，元素被拖动：onmousemove</span><br><span class="line">鼠标松开，被拖拽元素固定：onmouseup</span><br></pre></td></tr></table></figure>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a><em>代码</em></h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-id">#box1</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: bisque;</span></span><br><span class="line"><span class="css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#box2</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">184</span>, <span class="number">127</span>, <span class="number">59</span>);</span></span><br><span class="line"><span class="css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">            <span class="attribute">left</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">top</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#img1</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">250px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//拖拽box1元素</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">/*流程</span></span></span><br><span class="line"><span class="comment"><span class="javascript">             *  1.当鼠标按下时，开始拖拽：onmousedown</span></span></span><br><span class="line"><span class="comment"><span class="javascript">             *  2.鼠标移动，元素被拖动：onmousemove</span></span></span><br><span class="line"><span class="comment"><span class="javascript">             *  3.鼠标松开，被拖拽元素固定：onmouseup</span></span></span><br><span class="line"><span class="comment"><span class="javascript">            */</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> box1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;box1&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> box2 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;box2&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> img = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;img1&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="comment">//开启box1</span></span></span><br><span class="line"><span class="javascript">            drag(box1);</span></span><br><span class="line"><span class="javascript">            drag(box2);</span></span><br><span class="line"><span class="javascript">            drag(img);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">//优化：3提前一个专门用来设置拖拽的函数</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//参数：obj</span></span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">drag</span>(<span class="params">obj</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//第一步</span></span></span><br><span class="line"><span class="javascript">                obj.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//设置box1捕获所有鼠标按下的事件</span></span></span><br><span class="line"><span class="javascript">                obj.setPointerCapture;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//优化 1</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">//div的偏移量 鼠标.clientX - 元素.offsetLeft</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">//div的偏移量 鼠标.clientY - 元素.offsetTop</span></span></span><br><span class="line"><span class="javascript">                event = event || <span class="built_in">window</span>.event;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> ol = event.clientX - obj.offsetLeft;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> ot = event.clientY - obj.offsetTop;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">                <span class="comment">//第二部</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    event = event || <span class="built_in">window</span>.event;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">//第三部</span></span></span><br><span class="line"><span class="javascript">                    <span class="comment">//获取鼠标坐标</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> left = event.clientX - ol;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> top = event.clientY - ot;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">//修改box1的位置</span></span></span><br><span class="line"><span class="javascript">                    obj.style.left = left+<span class="string">&#x27;px&#x27;</span>;</span></span><br><span class="line"><span class="javascript">                    obj.style.top = top+<span class="string">&#x27;px&#x27;</span>;</span></span><br><span class="line"><span class="javascript">                    obj.innerHTML = <span class="string">&#x27;x=&#x27;</span>+left+<span class="string">&#x27; y=&#x27;</span>+top;</span></span><br><span class="line"><span class="javascript">                &#125;;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.onmouseup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">//鼠标松开时，固定在当前位置</span></span></span><br><span class="line"><span class="javascript">                    <span class="comment">//取消onmousemove</span></span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.onmousemove = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">//取消onmouseup(一次性事件)</span></span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.onmouseup = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">//事件松开时，取消对事件的捕获</span></span></span><br><span class="line"><span class="javascript">                    obj.releasePointerCapture;</span></span><br><span class="line"><span class="javascript">                &#125;;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//优化 2</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./img/1.jpg&quot;</span> <span class="attr">id</span>=<span class="string">&quot;img1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a><em>优化</em></h5><ol>
<li><p>鼠标的偏移量</p>
<blockquote>
<p>初始代码的拖拽效果，会出现明显的偏移，即鼠标在移动时，偏离最初点击的位置，用户体验差。</p>
</blockquote>
<p><strong>解决方法</strong></p>
<blockquote>
<p>元素的偏移量 鼠标.clientX - 元素.offsetLeft<br>元素的偏移量 鼠标.clientY - 元素.offsetTop</p>
</blockquote>
</li>
<li><p>拖拽内容时，浏览器会默认去搜索引擎中搜索内容</p>
<p> <strong>解决方法1</strong></p>
<blockquote>
<p>return false (不兼容ie8及以下)</p>
</blockquote>
<p> <strong>解决方法2</strong></p>
<blockquote>
<p>setCapture()方法 (不支持Chrome)</p>
</blockquote>
<blockquote>
<p>setPointerCapture属性：鼠标单击时，捕获所有鼠标按下的事件。<br> releasePointerCapture属性：事件松开时，取消对事件的捕获</p>
</blockquote>
</li>
<li><p>提取该拖拽函数</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化：3提前一个专门用来设置拖拽的函数</span></span><br><span class="line"><span class="comment">//参数：obj</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drag</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//第一步</span></span><br><span class="line">    obj.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//设置box1捕获所有鼠标按下的事件</span></span><br><span class="line">    obj.setPointerCapture;</span><br><span class="line">    <span class="comment">//优化 1</span></span><br><span class="line">    <span class="comment">//div的偏移量 鼠标.clientX - 元素.offsetLeft</span></span><br><span class="line">    <span class="comment">//div的偏移量 鼠标.clientY - 元素.offsetTop</span></span><br><span class="line">    event = event || <span class="built_in">window</span>.event;</span><br><span class="line">    <span class="keyword">var</span> ol = event.clientX - obj.offsetLeft;</span><br><span class="line">    <span class="keyword">var</span> ot = event.clientY - obj.offsetTop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二部</span></span><br><span class="line">    <span class="built_in">document</span>.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        event = event || <span class="built_in">window</span>.event;</span><br><span class="line">        <span class="comment">//第三部</span></span><br><span class="line">        <span class="comment">//获取鼠标坐标</span></span><br><span class="line">        <span class="keyword">var</span> left = event.clientX - ol;</span><br><span class="line">        <span class="keyword">var</span> top = event.clientY - ot;</span><br><span class="line">        <span class="comment">//修改box1的位置</span></span><br><span class="line">        obj.style.left = left+<span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">        obj.style.top = top+<span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">        obj.innerHTML = <span class="string">&#x27;x=&#x27;</span>+left+<span class="string">&#x27; y=&#x27;</span>+top;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">document</span>.onmouseup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//鼠标松开时，固定在当前位置</span></span><br><span class="line">        <span class="comment">//取消onmousemove</span></span><br><span class="line">        <span class="built_in">document</span>.onmousemove = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//取消onmouseup(一次性事件)</span></span><br><span class="line">        <span class="built_in">document</span>.onmouseup = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//事件松开时，取消对事件的捕获</span></span><br><span class="line">        obj.releasePointerCapture;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//优化 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>code</category>
        <category>frontend</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax跨域解决方案</title>
    <url>/2021/07/21/%E5%8A%A0%E8%BD%BD%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%87%BA%E7%8E%B0%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h5 id="本地-Ajax-跨域报错-Cross-origin-requests-are-only-supported-for-protocol-schemes-http-data-chrome-chrome-extension-chrome-untrusted-https"><a href="#本地-Ajax-跨域报错-Cross-origin-requests-are-only-supported-for-protocol-schemes-http-data-chrome-chrome-extension-chrome-untrusted-https" class="headerlink" title="本地 Ajax 跨域报错 Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, chrome-untrusted, https."></a>本地 Ajax 跨域报错 Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, chrome-untrusted, https.</h5><span id="more"></span>

<hr>
<p>当我们在做练习或者写 Demo 的时候，有访问本地文件的需求，当我们在加载的时候发现不能加载，会报如下错误： </p>
<p><img src="https://images.cnblogs.com/cnblogs_com/xzsj/1888303/o_210325085243filecross.png"></p>
<p>根据错误信息大概知道原因在于使用了 File 协议，应该使用它提示的 http, data, chrome, chrome-extension, chrome-untrusted, https 这些协议，可是只是做个练习，写些小 Demo，不至于自己去创建一个服务器，开个端口。那么应该如何解决这个问题呢？各位看官，往下看。</p>
<h2 id="1-换编辑器"><a href="#1-换编辑器" class="headerlink" title="1.换编辑器"></a>1.换编辑器</h2><hr>
<p>使用 webstorm 或是 visual studio 这种重量级 IDE 的同学，应该不会遇到这种问题，这类 IDE 都内置了 HTTP 服务器。<br>但是对于一些喜欢使用 VSCode，Sublime Text 这类轻量级编辑器的同学，我们继续往下看。</p>
<h2 id="2-安装Server插件"><a href="#2-安装Server插件" class="headerlink" title="2.安装Server插件"></a>2.安装Server插件</h2><hr>
<p>这里针对 VSCode 和 Sublime 分别安利一款插件。</p>
<h3 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h3><hr>
<p>Live Server 插件，这个插件功能十分强大，不止可以解决 ajax 不支持 file 协议的问题，还可以实现在编辑器里保存修改后，页面自动刷新的功能。具体使用方法在插件安装的地方有说明，用起来也十分简单。<br>安装完成之后，打开 html 文件后，点击右下角的 GoLive 即可。</p>
<h3 id="Sublime"><a href="#Sublime" class="headerlink" title="Sublime"></a>Sublime</h3><hr>
<p>SublimeServer 插件，安装完成之后，点击 Tools-&gt;SublimeServer-&gt;Start SublimeServer，启动服务器，然后在 html 文件中，注意是文件中点击右键，选择 View in SublimeServer 即可。<br>（注意一定要以文件夹的方式打开 html 文件所在目录，否则可能失效。）</p>
<h2 id="3-换浏览器"><a href="#3-换浏览器" class="headerlink" title="3.换浏览器"></a>3.换浏览器</h2><hr>
<p>火狐支持 file 协议，对 Chorme 没有什么执念的童鞋，可以换成火狐。</p>
<h2 id="4-配置Chrome浏览器支持file协议"><a href="#4-配置Chrome浏览器支持file协议" class="headerlink" title="4.配置Chrome浏览器支持file协议"></a>4.配置Chrome浏览器支持file协议</h2><hr>
<p>如果你是那种非常喜欢 Chrome 开发者工具的人，也可以尝试如下方式。</p>
<p>Windows：<br>设置 Chrome 的快捷方式属性，在“目标”后面加上–allow-file-access-from-files，注意前面有个空格，重新打开 Chrome 即可。</p>
<p>Mac：<br>打开终端，输入下面命令：open -a “Google Chrome” –args –disable-web-security 然后就可以屏蔽安全访问了[ –args：此参数可有可无]</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><hr>
<p>只是更改浏览器配置使之支持 file 协议，还是有很大的局限性的，建议最好采用前两种方式，配置 http 服务器才是长久之计。</p>
<p>如需前端指导、前端资料、Java 指导和 Java 资料的请联系本人，感谢您的支持。</p>
<blockquote>
<p>WECHAT：xzsj07<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>code</category>
        <category>frontend</category>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript学习笔记</title>
    <url>/2021/07/21/TypeScript/</url>
    <content><![CDATA[<h1 id="第一章-快速入门"><a href="#第一章-快速入门" class="headerlink" title="第一章 快速入门"></a>第一章 快速入门</h1><span id="more"></span>

<h2 id="0、TypeScript简介"><a href="#0、TypeScript简介" class="headerlink" title="0、TypeScript简介"></a>0、TypeScript简介</h2><ol>
<li><p>TypeScript是<strong>JavaScript的超集</strong>。</p>
</li>
<li><p>它对JS进行了扩展，向JS中引入了类型的概念，并添加了许多新的特性。</p>
</li>
<li><p>TS代码需要通过编译器编译为JS，然后再交由JS解析器执行。</p>
</li>
<li><p>TS完全兼容JS，换言之，任何的JS代码都可以直接当成JS使用。</p>
</li>
</ol>
<ul>
<li>相较于JS而言，TS拥有了静态类型，更加严格的语法，更强大的功能；</li>
<li>TS可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；</li>
<li>TS代码可以编译为任意版本的JS代码，可有效解决不同JS运行环境的兼容问题；</li>
<li>同样的功能，TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS。</li>
</ul>
<h2 id="1、TypeScript-开发环境搭建"><a href="#1、TypeScript-开发环境搭建" class="headerlink" title="1、TypeScript 开发环境搭建"></a>1、TypeScript 开发环境搭建</h2><ol>
<li><p>下载Node.js</p>
<ul>
<li>64位：<a href="https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi">https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi</a></li>
<li>32位：<a href="https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi">https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi</a></li>
</ul>
</li>
<li><p>安装Node.js</p>
</li>
<li><p>使用npm全局安装typescript</p>
<ul>
<li>进入命令行</li>
<li>输入：npm i -g typescript</li>
</ul>
</li>
<li><p>创建一个ts文件</p>
</li>
<li><p>使用tsc对ts文件进行<strong>编译</strong></p>
<ul>
<li><p>进入命令行</p>
</li>
<li><p>进入ts文件所在目录</p>
</li>
<li><p>执行命令：tsc xxx.ts</p>
</li>
</ul>
</li>
</ol>
<h2 id="2、基本类型"><a href="#2、基本类型" class="headerlink" title="2、基本类型"></a>2、基本类型</h2><ul>
<li><h4 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h4><ul>
<li><p>类型声明是TS非常重要的一个特点</p>
</li>
<li><p>通过类型声明可以指定TS中变量（参数、形参）的类型</p>
</li>
<li><p>指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错</p>
</li>
<li><p><strong>简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值</strong></p>
</li>
<li><p>语法：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> 变量: 类型;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> 变量: 类型 = 值;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">参数: 类型, 参数: 类型</span>): 类型</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h4 id="自动类型判断"><a href="#自动类型判断" class="headerlink" title="自动类型判断"></a>自动类型判断</h4><ul>
<li>TS拥有自动的类型判断机制</li>
<li><strong>当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型</strong></li>
<li>所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明</li>
</ul>
</li>
<li><h4 id="类型："><a href="#类型：" class="headerlink" title="类型："></a>类型：</h4><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">例子</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">number</td>
<td align="center">1, -33, 2.5</td>
<td align="center">任意数字</td>
</tr>
<tr>
<td align="center">string</td>
<td align="center">‘hi’, “hi”, <code>hi</code></td>
<td align="center">任意字符串</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">true、false</td>
<td align="center">布尔值true或false</td>
</tr>
<tr>
<td align="center">字面量</td>
<td align="center">其本身</td>
<td align="center">限制变量的值就是该字面量的值</td>
</tr>
<tr>
<td align="center">any</td>
<td align="center">*</td>
<td align="center">任意类型</td>
</tr>
<tr>
<td align="center">unknown</td>
<td align="center">*</td>
<td align="center">类型安全的any</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">空值（undefined）</td>
<td align="center">没有值（或undefined）</td>
</tr>
<tr>
<td align="center">never</td>
<td align="center">没有值</td>
<td align="center">不能是任何值</td>
</tr>
<tr>
<td align="center">object</td>
<td align="center">{name:’孙悟空’}</td>
<td align="center">任意的JS对象</td>
</tr>
<tr>
<td align="center">array</td>
<td align="center">[1,2,3]</td>
<td align="center">任意JS数组</td>
</tr>
<tr>
<td align="center">tuple</td>
<td align="center">[4,5]</td>
<td align="center">元素，TS新增类型，固定长度数组</td>
</tr>
<tr>
<td align="center">enum</td>
<td align="center">enum{A, B}</td>
<td align="center">枚举，TS中新增类型</td>
</tr>
</tbody></table>
</li>
<li><p>number</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> decimal: <span class="built_in">number</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> hex: <span class="built_in">number</span> = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="keyword">let</span> binary: <span class="built_in">number</span> = <span class="number">0b1010</span>;</span><br><span class="line"><span class="keyword">let</span> octal: <span class="built_in">number</span> = <span class="number">0o744</span>;</span><br><span class="line"><span class="keyword">let</span> big: bigint = <span class="number">100n</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>boolean</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>string</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> color: <span class="built_in">string</span> = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fullName: <span class="built_in">string</span> = <span class="string">`Bob Bobbington`</span>;</span><br><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="number">37</span>;</span><br><span class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123;fullName&#125;</span>.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I&#x27;ll be <span class="subst">$&#123;age + <span class="number">1</span>&#125;</span> years old next month.`</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>字面量</p>
<ul>
<li><p>也可以使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围</p>
</li>
<li><p>```typescript<br>let color: ‘red’ | ‘blue’ | ‘black’;<br>let num: 1 | 2 | 3 | 4 | 5;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- any</span><br><span class="line"></span><br><span class="line">  - 相当于关闭该变量的ts语法，开发时不建议使用</span><br><span class="line"></span><br><span class="line">  - ```typescript</span><br><span class="line">    let d: any = 4;</span><br><span class="line">    d = &#x27;hello&#x27;;</span><br><span class="line">    d = true;</span><br><span class="line">    </span><br><span class="line">    // 声明变量如果不指定类型，则TS解析器会自动判断变量的类型为any （隐式的any）</span><br><span class="line">    let d;</span><br><span class="line">    d = 10;</span><br><span class="line">    d = &#x27;hello&#x27;;</span><br><span class="line">    d = true;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>unknown</p>
<ul>
<li><p>区别any</p>
<ul>
<li>any，可以赋值给任意变量</li>
<li>unknown类型的变量，不能直接赋值给其他变量</li>
</ul>
</li>
<li><p>```typescript<br>let notSure: unknown = 4;<br>notSure = ‘hello’;<br>// unknown 实际上就是一个类型安全的any</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- void</span><br><span class="line"></span><br><span class="line">  ```typescript</span><br><span class="line">  let unusable: void = undefined;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>never</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>object（没啥用）</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj: <span class="built_in">object</span> = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.&#123;&#125; 用来指定对象中可以包含哪些属性// 语法：&#123;属性名:属性值,属性名:属性值&#125;// 在属性名后边加上?，表示属性是可选的let b: &#123;name: string, age?: number&#125;;b = &#123;name: &#x27;孙悟空&#x27;, age: 18&#125;;// 2.[propName: string]: any 表示任意类型的属性let c: &#123;name: string, [propName: string]: any&#125;;c = &#123;name: &#x27;猪八戒&#x27;, age: 18, gender: &#x27;男&#x27;&#125;;/**  3.设置函数结构的类型声明：*       语法：(形参:类型, 形参:类型 ...) =&gt; 返回值* */let d: (a: number ,b: number)=&gt;number;let d = function (n1: string, n2: string): number&#123;   return 10;&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>array</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**   数组的类型声明：*       类型[]*       Array&lt;类型&gt;* */</span><span class="keyword">let</span> list: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];<span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];<span class="comment">// string[] 表示字符串数组let e: string[];// number[] 表示数值数值let f: number[];let g: Array&lt;number&gt;;</span></span><br></pre></td></tr></table></figure></li>
<li><p>tuple</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**   元组，元组就是固定长度的数组*       语法：[类型, 类型, 类型]* */</span><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>];x = [<span class="string">&quot;hello&quot;</span>, <span class="number">10</span>]; </span><br></pre></td></tr></table></figure></li>
<li><p>enum</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//enum 枚举enum Color &#123;  Red,  Green,  Blue,&#125;let c: Color = Color.Green;enum Color &#123;  Red = 1,  Green,  Blue,&#125;let c: Color = Color.Green;enum Color &#123;  Red = 1,  Green = 2,  Blue = 4,&#125;let c: Color = Color.Green;// 补充let j: &#123; name: string &#125; &amp; &#123; age: number &#125;;// j = &#123;name: &#x27;孙悟空&#x27;, age: 18&#125;;</span></span><br></pre></td></tr></table></figure></li>
<li><p>类型别名</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> myType = <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span>;<span class="keyword">let</span> k: myType;<span class="keyword">let</span> l: myType;<span class="keyword">let</span> m: myType;k = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>类型断言</p>
<ul>
<li><p>有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，<strong>可以通过类型断言来告诉编译器变量的类型</strong>，类比强制转换。</p>
</li>
<li><p>断言有两种形式：</p>
<ul>
<li><p>第一种</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: unknown = <span class="string">&quot;this is a string&quot;</span>;<span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br></pre></td></tr></table></figure></li>
<li><p>第二种</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: unknown = <span class="string">&quot;this is a string&quot;</span>;<span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3、编译选项"><a href="#3、编译选项" class="headerlink" title="3、编译选项"></a>3、编译选项</h2><h3 id="自动编译文件"><a href="#自动编译文件" class="headerlink" title="自动编译文件"></a>自动编译文件</h3><ul>
<li><p>编译文件时，使用 <code>-w</code> 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。</p>
</li>
<li><p>示例：</p>
<ul>
<li><p>```powershell<br>tsc xxx.ts -w</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 自动编译整个项目</span><br><span class="line"></span><br><span class="line">- 如果直接使用**tsc**指令，则可以自动将当前项目下的所有ts文件编译为js文件。</span><br><span class="line">- 但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 **tsconfig.json**</span><br><span class="line">- tsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc 命令即可完成对整个项目的编译</span><br><span class="line"></span><br><span class="line">#### 配置选项</span><br><span class="line"></span><br><span class="line">##### **include**</span><br><span class="line"></span><br><span class="line">- 定义希望被编译文件所在的目录</span><br><span class="line"></span><br><span class="line">- 默认值：[&quot;\*\*/\*&quot;]</span><br><span class="line"></span><br><span class="line">- 示例：</span><br><span class="line"></span><br><span class="line">  ```json</span><br><span class="line">  &quot;include&quot;:[    &quot;src/**/*&quot;,     &quot;tests/**/*&quot;]// &quot;**&quot;表示任意目录，“*”表示任意文件</span><br></pre></td></tr></table></figure></li>
<li><p>上述示例中，所有src目录和tests目录下的文件都会被编译</p>
</li>
</ul>
</li>
</ul>
<h5 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a><strong>exclude</strong></h5><ul>
<li><p>定义需要排除在外的目录</p>
</li>
<li><p>默认值：[“node_modules”, “bower_components”, “jspm_packages”]</p>
</li>
<li><p>示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;exclude&quot;</span>: [<span class="string">&quot;./src/hello/**/*&quot;</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>上述示例中，src下hello目录下的文件都不会被编译</li>
</ul>
</li>
</ul>
<h5 id="extends"><a href="#extends" class="headerlink" title="extends"></a><strong>extends</strong></h5><ul>
<li><p>定义被继承的配置文件</p>
</li>
<li><p>示例：</p>
<ul>
<li><p>```json<br>“extends”: “./configs/base”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 上述示例中，当前配置文件中会自动包含config目录下**base.json**中的所有配置信息</span><br><span class="line"></span><br><span class="line">##### **files**</span><br><span class="line"></span><br><span class="line">- 指定被编译文件的列表，只有需要编译的文件少时才会用到</span><br><span class="line"></span><br><span class="line">- 示例：</span><br><span class="line"></span><br><span class="line">  - ```json</span><br><span class="line">    &quot;files&quot;: [    &quot;core.ts&quot;,    &quot;sys.ts&quot;,    &quot;types.ts&quot;,    &quot;scanner.ts&quot;,    &quot;parser.ts&quot;,    &quot;utilities.ts&quot;,    &quot;binder.ts&quot;,    &quot;checker.ts&quot;,    &quot;tsc.ts&quot;  ]</span><br></pre></td></tr></table></figure></li>
<li><p>列表中的文件都会被TS编译器所编译</p>
</li>
</ul>
</li>
</ul>
<h5 id="compilerOptions"><a href="#compilerOptions" class="headerlink" title="compilerOptions"></a><strong>compilerOptions</strong></h5><ul>
<li><p><strong>编译选项</strong>是配置文件中非常重要也比较复杂的配置选项</p>
</li>
<li><p>在compilerOptions中包含多个子选项，用来完成对编译的配置</p>
</li>
</ul>
<h6 id="项目选项"><a href="#项目选项" class="headerlink" title="项目选项"></a>项目选项</h6><ul>
<li><p><strong>target</strong></p>
<ul>
<li><p>设置ts代码编译的目标版本</p>
</li>
<li><p>可选值：</p>
<ul>
<li>ES3（默认）、ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;ES6&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>lib</strong></p>
<ul>
<li><p>指定代码运行时所包含的库（宿主环境）</p>
</li>
<li><p>可选值：</p>
<ul>
<li>ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ……</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;ES6&quot;</span>,    <span class="attr">&quot;lib&quot;</span>: [<span class="string">&quot;ES6&quot;</span>, <span class="string">&quot;DOM&quot;</span>],    <span class="attr">&quot;outDir&quot;</span>: <span class="string">&quot;dist&quot;</span>,    <span class="attr">&quot;outFile&quot;</span>: <span class="string">&quot;dist/aa.js&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>module</strong></p>
<ul>
<li><p>设置编译后代码使用的模块化系统</p>
</li>
<li><p>可选值：</p>
<ul>
<li>CommonJS、UMD、AMD、System、ES2020、ESNext、None</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;    <span class="string">&quot;module&quot;</span>: <span class="string">&quot;CommonJS&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>outDir</strong></p>
<ul>
<li><p>编译后文件的所在目录</p>
</li>
<li><p>默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置</p>
</li>
<li><p>示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;    <span class="attr">&quot;outDir&quot;</span>: <span class="string">&quot;dist&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置后编译后的js文件将会生成到dist目录</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>outFile</strong></p>
<ul>
<li><p>将所有的文件编译为一个js文件</p>
</li>
<li><p>默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中</p>
</li>
<li><p>示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;    <span class="attr">&quot;outFile&quot;</span>: <span class="string">&quot;dist/app.js&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>rootDir</strong></p>
<ul>
<li><p>指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录</p>
</li>
<li><p>示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;    <span class="attr">&quot;rootDir&quot;</span>: <span class="string">&quot;./src&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>allowJs</strong></p>
<ul>
<li>是否对js文件编译，默认是false</li>
</ul>
</li>
<li><p><strong>checkJs</strong></p>
<ul>
<li><p>是否检查js代码是否符合语法规范，默认是false</p>
</li>
<li><p>示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;    <span class="attr">&quot;allowJs&quot;</span>: <span class="literal">true</span>,    <span class="attr">&quot;checkJs&quot;</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>removeComments</strong></p>
<ul>
<li>是否删除注释</li>
<li>默认值：false</li>
</ul>
</li>
<li><p><strong>noEmit</strong></p>
<ul>
<li>不生成编译后的文件</li>
<li>默认值：false</li>
</ul>
</li>
<li><p><strong>sourceMap</strong></p>
<ul>
<li>是否生成sourceMap</li>
<li>默认值：false</li>
</ul>
</li>
<li><p><strong>noEmitOnError</strong></p>
<ul>
<li>当有错误时不生成编译后的文件</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>严格检查</strong></p>
</li>
<li><p>strict</p>
<ul>
<li>启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查</li>
<li>alwaysStrict<ul>
<li>总是以严格模式对代码进行编译</li>
</ul>
</li>
<li>noImplicitAny<ul>
<li>禁止隐式的any类型</li>
</ul>
</li>
<li>noImplicitThis<ul>
<li>禁止类型不明确的this</li>
</ul>
</li>
<li>strictBindCallApply<ul>
<li>严格检查bind、call和apply的参数列表</li>
</ul>
</li>
<li>strictFunctionTypes<ul>
<li>严格检查函数的类型</li>
</ul>
</li>
<li>strictNullChecks<ul>
<li>严格的空值检查</li>
</ul>
</li>
<li>strictPropertyInitialization<ul>
<li>严格检查属性是否初始化</li>
</ul>
</li>
</ul>
</li>
<li><p>额外检查</p>
<ul>
<li>noFallthroughCasesInSwitch<ul>
<li>检查switch语句包含正确的break</li>
</ul>
</li>
<li>noImplicitReturns<ul>
<li>检查函数没有隐式的返回值</li>
</ul>
</li>
<li>noUnusedLocals<ul>
<li>检查未使用的局部变量</li>
</ul>
</li>
<li>noUnusedParameters<ul>
<li>检查未使用的参数</li>
</ul>
</li>
</ul>
</li>
<li><p>高级</p>
<ul>
<li>allowUnreachableCode<ul>
<li>检查不可达代码</li>
<li>可选值：<ul>
<li>true，忽略不可达代码</li>
<li>false，不可达代码将引起错误</li>
</ul>
</li>
</ul>
</li>
<li>noEmitOnError<ul>
<li>有错误的情况下不进行编译</li>
<li>默认值：false</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4、webpack"><a href="#4、webpack" class="headerlink" title="4、webpack"></a>4、webpack</h2><ul>
<li><p>通常情况下，实际开发中我们都需要使用构建工具对代码进行打包，TS同样也可以结合构建工具一起使用，下边以webpack为例介绍一下如何结合构建工具使用TS。</p>
</li>
<li><p>步骤：</p>
<ol>
<li><p>初始化项目</p>
<ul>
<li>进入项目根目录，执行命令 <code> npm init -y</code><ul>
<li>主要作用：创建package.json文件</li>
</ul>
</li>
</ul>
</li>
<li><p>下载构建工具</p>
<ul>
<li><code>npm i -D webpack webpack-cli webpack-dev-server typescript ts-loader clean-webpack-plugin</code><ul>
<li>共安装了7个包<ul>
<li><strong>webpack</strong><ul>
<li>构建工具webpack</li>
</ul>
</li>
<li><strong>webpack-cli</strong><ul>
<li>webpack的命令行工具</li>
</ul>
</li>
<li><strong>webpack-dev-server</strong><ul>
<li>webpack的开发服务器</li>
</ul>
</li>
<li><strong>typescript</strong><ul>
<li>ts编译器</li>
</ul>
</li>
<li><strong>ts-loader</strong><ul>
<li>ts加载器，用于在webpack中编译ts文件</li>
</ul>
</li>
<li><strong>html-webpack-plugin</strong><ul>
<li>webpack中html插件，用来自动创建html文件</li>
</ul>
</li>
<li><strong>clean-webpack-plugin</strong><ul>
<li>webpack中的清除插件，每次构建都会先清除目录</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>根目录下创建webpack的配置文件webpack.config.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);<span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);<span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&quot;clean-webpack-plugin&quot;</span>);<span class="built_in">module</span>.exports = &#123;    <span class="attr">optimization</span>:&#123;        <span class="attr">minimize</span>: <span class="literal">false</span> <span class="comment">// 关闭代码压缩，可选    &#125;,    entry: &quot;./src/index.ts&quot;,        devtool: &quot;inline-source-map&quot;,        devServer: &#123;        contentBase: &#x27;./dist&#x27;    &#125;,    output: &#123;        path: path.resolve(__dirname, &quot;dist&quot;),        filename: &quot;bundle.js&quot;,        environment: &#123;            arrowFunction: false // 关闭webpack的箭头函数，可选        &#125;    &#125;,	// 用来设置引用模块    resolve: &#123;        extensions: [&quot;.ts&quot;, &quot;.js&quot;]    &#125;,        module: &#123;        // 指定要加载的规则        rules: [            &#123;                // test指定的是规则生效的文件                test: /\.ts$/,                // 配置babel                use: &#123;                   loader: &quot;ts-loader&quot;                     &#125;,                // 要排除的文件                exclude: /node_modules/            &#125;        ]    &#125;,    plugins: [        new CleanWebpackPlugin(),        new HtmlWebpackPlugin(&#123;            title:&#x27;TS测试&#x27;        &#125;),    ]&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>根目录下创建tsconfig.json，配置可以根据自己需要</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;    <span class="attr">&quot;compilerOptions&quot;</span>: &#123;        <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;ES2015&quot;</span>,        <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;ES2015&quot;</span>,        <span class="attr">&quot;strict&quot;</span>: <span class="literal">true</span>    &#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改package.json添加如下配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;  ...略...  <span class="attr">&quot;scripts&quot;</span>: &#123;    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span>,    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;webpack serve --open chrome.exe&quot;</span>  &#125;,  ...略...&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在src下创建ts文件，并在并命令行执行<code>npm run build</code>对代码进行编译，或者执行<code>npm start</code>来启动开发服务器</p>
</li>
</ol>
</li>
</ul>
<h2 id="5、Babel"><a href="#5、Babel" class="headerlink" title="5、Babel"></a>5、Babel</h2><ul>
<li><p>经过一系列的配置，使得TS和webpack已经结合到了一起，除了webpack，开发中还经常需要结合babel来<strong>对代码进行转换</strong>以使其可以<strong>兼容到更多的浏览器</strong>，在上述步骤的基础上，通过以下步骤再将babel引入到项目中。</p>
<ol>
<li><p>安装依赖包：</p>
<ul>
<li><code>npm i -D @babel/core @babel/preset-env babel-loader core-js</code></li>
<li>共安装了4个包，分别是：<ul>
<li>@babel/core<ul>
<li>babel的核心工具</li>
</ul>
</li>
<li>@babel/preset-env<ul>
<li>babel的预定义环境</li>
</ul>
</li>
<li>@babel-loader<ul>
<li>babel在webpack中的加载器</li>
</ul>
</li>
<li>core-js<ul>
<li>core-js用来使老版本的浏览器支持新版ES语法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>修改webpack.config.js配置文件</p>
<ul>
<li>```javascript<br>…略…module: {  rules: [    {      test: /.ts$/,      use: [        {           loader: “babel-loader”,// 指定加载器            // 设置babel           options:{               // 设置预定义环境             presets: [                   [                  “@babel/preset-env”,// 指定环境的插件                    // 配置信息                     {                        “targets”:{                            // 要兼容的目标浏览器                           “chrome”: “58”,                              “ie”: “11”                          },                          “corejs”:”3”,// 指定corejs版本                          “useBuiltIns”: “usage” // 按需加载                       }                ]             ]            }          },          {             loader: “ts-loader”,           }          ],            exclude: /node_modules/        }    ]}…略…<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">     - 如此一来，使用ts编译后的文件将会再次被babel处理，使得代码可以在大部分浏览器中直接使用，可以在配置选项的targets中指定要兼容的浏览器版本。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第二章：面向对象</span><br><span class="line"></span><br><span class="line">面向对象是程序中一个非常重要的思想，它被很多同学理解成了一个比较难，比较深奥的问题，其实不然。面向对象很简单，简而言之就是**程序之中所有的操作都需要通过对象来完成**。</span><br><span class="line"></span><br><span class="line">- 举例来说：</span><br><span class="line">  - 操作浏览器要使用window对象</span><br><span class="line">  - 操作网页要使用document对象</span><br><span class="line">  - 操作控制台要使用console对象</span><br><span class="line"></span><br><span class="line">一切操作都要通过对象，也就是所谓的面向对象，那么对象到底是什么呢？这就要先说到程序是什么，计算机程序的本质就是**对现实事物的抽象**，**抽象**的反义词是**具体**，比如：照片是对一个具体的人的抽象，汽车模型是对具体汽车的抽象等等。程序也是对事物的抽象，在程序中我们可以表示一个人、一条狗、一把枪、一颗子弹等等所有的事物。一个事物到了程序中就变成了一个对象。</span><br><span class="line"></span><br><span class="line">在程序中所有的对象都被分成了两个部分：**数据**和**功能**，以人为例，人的姓名、性别、年龄、身高、体重等属于数据，人可以说话、走路、吃饭、睡觉这些属于人的功能。数据在对象中被成为属性，而功能就被称为方法。所以简而言之，**在程序中一切皆是对象。**</span><br><span class="line"></span><br><span class="line">## 1、类（class）</span><br><span class="line"></span><br><span class="line">要想面向对象，操作对象，首先便要拥有对象，那么下一个问题就是如何**创建对象**。要创建对象，必须要**先定义类**，所谓的类可以理解为**对象的模型**，程序中可以根据类创建指定类型的对象，举例来说：可以通过Person类来创建人的对象，通过Dog类创建狗的对象，通过Car类来创建汽车的对象，不同的类可以用来创建不同的对象。</span><br><span class="line"></span><br><span class="line">- 定义类：</span><br><span class="line"></span><br><span class="line">  ```typescript</span><br><span class="line">  class 类名 &#123;	属性名: 类型;		constructor(参数: 类型)&#123;		this.属性名 = 参数;	&#125;		方法名()&#123;		....	&#125;&#125;/*    *   1.直接定义的属性是实例属性，需要通过对象的实例去访问：    *       const per = new Person();    *       per.name    *    *   2.使用static开头的属性是静态属性（类属性），可以直接通过类去访问    *       Person.age    *    *   readonly开头的属性表示一个只读的属性无法修改    * */</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>两种属性：</p>
<ul>
<li><strong>实例属性</strong><ul>
<li>直接定义的属性是实例属性，需要通过对象的实例去访问</li>
</ul>
</li>
<li><strong>静态属性</strong><ul>
<li>使用static开头的属性是静态属性（类属性），可以直接通过类去访问</li>
</ul>
</li>
</ul>
</li>
<li><p>构造函数constructor：</p>
<ul>
<li>```typescript<br>constructor(name: string, age: number) {    // 在实例方法中，this就表示当前当前的实例    // 在构造函数中当前对象就是当前新建的那个对象    // 可以通过this向新建的对象中添加属性    this.name = name;    this.age = age;}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 示例：</span><br><span class="line"></span><br><span class="line">  ```typescript</span><br><span class="line">  class Person&#123;    name: string;    age: number;    constructor(name: string, age: number)&#123;        this.name = name;        this.age = age;    &#125;    sayHello()&#123;        console.log(`大家好，我是$&#123;this.name&#125;`);    &#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用类：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;孙悟空&#x27;</span>, <span class="number">18</span>);p.sayHello();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2、面向对象的特点"><a href="#2、面向对象的特点" class="headerlink" title="2、面向对象的特点"></a>2、面向对象的特点</h2><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ul>
<li><p>对象实质上就是属性和方法的容器，它的主要作用就是<strong>存储属性和方法</strong>，这就是所谓的封装</p>
</li>
<li><p>默认情况下，对象的属性是可以任意的修改的，为了<strong>确保数据的安全性</strong>，在TS中可以对属性的权限进行设置</p>
</li>
<li><p>只读属性（readonly）：</p>
<ul>
<li>如果在声明属性时添加一个readonly，则属性便成了只读属性无法修改</li>
</ul>
</li>
<li><p>TS中<strong>属性</strong>具有三种<strong>修饰符</strong>：</p>
<ul>
<li><strong>public</strong>（默认值），可以在类、子类和对象中修改</li>
<li><strong>protected</strong> ，可以在类、子类中修改</li>
<li><strong>private</strong> ，可以在类中修改</li>
</ul>
</li>
<li><p>示例：</p>
<ul>
<li><p>public</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;    <span class="keyword">public</span> name: <span class="built_in">string</span>; <span class="comment">// 写或什么都不写都是public    public age: number;    constructor(name: string, age: number)&#123;        this.name = name; // 可以在类中修改        this.age = age;    &#125;    sayHello()&#123;        console.log(`大家好，我是$&#123;this.name&#125;`);    &#125;&#125;class Employee extends Person&#123;    constructor(name: string, age: number)&#123;        super(name, age);        this.name = name; //子类中可以修改    &#125;&#125;const p = new Person(&#x27;孙悟空&#x27;, 18);p.name = &#x27;猪八戒&#x27;;// 可以通过对象修改</span></span><br></pre></td></tr></table></figure></li>
<li><p>protected</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;    <span class="keyword">protected</span> name: <span class="built_in">string</span>;    <span class="keyword">protected</span> age: <span class="built_in">number</span>;    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span>&#123;        <span class="built_in">this</span>.name = name; <span class="comment">// 可以修改        this.age = age;    &#125;    sayHello()&#123;        console.log(`大家好，我是$&#123;this.name&#125;`);    &#125;&#125;class Employee extends Person&#123;    constructor(name: string, age: number)&#123;        super(name, age);        this.name = name; //子类中可以修改    &#125;&#125;const p = new Person(&#x27;孙悟空&#x27;, 18);p.name = &#x27;猪八戒&#x27;;// 不能修改</span></span><br></pre></td></tr></table></figure></li>
<li><p>private</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;    <span class="keyword">private</span> name: <span class="built_in">string</span>;    <span class="keyword">private</span> age: <span class="built_in">number</span>;    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span>&#123;        <span class="built_in">this</span>.name = name; <span class="comment">// 可以修改        this.age = age;    &#125;    sayHello()&#123;        console.log(`大家好，我是$&#123;this.name&#125;`);    &#125;&#125;class Employee extends Person&#123;    constructor(name: string, age: number)&#123;        super(name, age);        this.name = name; //子类中不能修改    &#125;&#125;const p = new Person(&#x27;孙悟空&#x27;, 18);p.name = &#x27;猪八戒&#x27;;// 不能修改</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>属性存取器</p>
<ul>
<li><p>对于一些不希望被任意修改的属性，可以将其设置为private</p>
</li>
<li><p>直接将其设置为private将导致无法再通过对象修改其中的属性</p>
</li>
<li><p>我们可以在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的存取器</p>
</li>
<li><p>读取属性的方法叫做setter方法，设置属性的方法叫做getter方法</p>
</li>
<li><p>示例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;    <span class="keyword">private</span> _name: <span class="built_in">string</span>;    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span>&#123;        <span class="built_in">this</span>._name = name;    &#125;    <span class="keyword">get</span> <span class="title">name</span>()&#123;        <span class="keyword">return</span> <span class="built_in">this</span>._name;    &#125;    <span class="keyword">set</span> <span class="title">name</span>(<span class="params">name: <span class="built_in">string</span></span>)&#123;        <span class="built_in">this</span>._name = name;    &#125;&#125;<span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;孙悟空&#x27;</span>);<span class="built_in">console</span>.log(p1.name); <span class="comment">// 通过getter读取name属性p1.name = &#x27;猪八戒&#x27;; // 通过setter修改name属性</span></span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;    <span class="comment">// 定义一个表示人的类    class Person&#123;        // TS可以在属性前添加属性的修饰符        /*        *   public 修饰的属性可以在任意位置访问（修改） 默认值        *   private 私有属性，私有属性只能在类内部进行访问（修改）        *       - 通过在类中添加方法使得私有属性可以被外部访问        *   protected 受包含的属性，只能在当前类和当前类的子类中访问（修改）        *        * */        private _name: string;        private _age: number;        constructor(name: string, age: number) &#123;            this._name = name;            this._age = age;        &#125;        /*        *   getter方法用来读取属性        *   setter方法用来设置属性        *       - 它们被称为属性的存取器        * */        // 定义方法，用来获取name属性        // getName()&#123;        //     return this._name;        // &#125;        //        // // 定义方法，用来设置name属性        // setName(value: string)&#123;        //     this._name = value;        // &#125;        //        // getAge()&#123;        //     return this._age;        // &#125;        //        // setAge(value: number)&#123;        //     // 判断年龄是否合法        //     if(value &gt;= 0)&#123;        //         this._age = value;        //     &#125;        // &#125;        // TS中设置getter方法的方式        get name()&#123;            // console.log(&#x27;get name()执行了！！&#x27;);            return this._name;        &#125;        set name(value)&#123;            this._name = value;        &#125;        get age()&#123;            return this._age;        &#125;        set age(value)&#123;            if(value &gt;= 0)&#123;                this._age = value            &#125;        &#125;    &#125;    const per = new Person(&#x27;孙悟空&#x27;, 18);    /*    * 现在属性是在对象中设置的，属性可以任意的被修改,    *   属性可以任意被修改将会导致对象中的数据变得非常不安全    * */    // per.setName(&#x27;猪八戒&#x27;);    // per.setAge(-33);    per.name = &#x27;猪八戒&#x27;;    per.age = -33;    // console.log(per);    class A&#123;        protected num: number;        constructor(num: number) &#123;            this.num = num;        &#125;    &#125;    class B extends A&#123;        test()&#123;            console.log(this.num);        &#125;    &#125;    const b = new B(123);    // b.num = 33;   /* class C&#123;        name: string;        age: number        // 可以直接将属性定义在构造函数中        constructor(name: string, age: number) &#123;            this.name = name;             this.age = age;        &#125;    &#125;*/    class C&#123;        // 可以直接将属性定义在构造函数中        constructor(public name: string, public age: number) &#123;        &#125;    &#125;    const c = new C(&#x27;xxx&#x27;, 111);    console.log(c);&#125;)();</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>静态属性</p>
<ul>
<li><p>静态属性（方法），也称为类属性。使用静态属性无需创建实例，通过类即可直接使用</p>
</li>
<li><p>静态属性（方法）使用static开头</p>
</li>
<li><p>示例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tools</span></span>&#123;    <span class="keyword">static</span> PI = <span class="number">3.1415926</span>;        <span class="keyword">static</span> <span class="function"><span class="title">sum</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>)</span>&#123;        <span class="keyword">return</span> num1 + num2    &#125;&#125;<span class="built_in">console</span>.log(Tools.PI);<span class="built_in">console</span>.log(Tools.sum(<span class="number">123</span>, <span class="number">456</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>this</p>
<ul>
<li>在类中，使用this表示当前对象</li>
</ul>
</li>
</ul>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul>
<li><p>继承时面向对象中的又一个特性</p>
</li>
<li><p>通过继承可以将其他类中的属性和方法引入到当前类中</p>
<ul>
<li><p>示例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;    name: <span class="built_in">string</span>;    age: <span class="built_in">number</span>;    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span>&#123;        <span class="built_in">this</span>.name = name;        <span class="built_in">this</span>.age = age;    &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;    <span class="function"><span class="title">bark</span>(<span class="params"></span>)</span>&#123;        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>在汪汪叫！`</span>);    &#125;&#125;<span class="keyword">const</span> dog = <span class="keyword">new</span> Dog(<span class="string">&#x27;旺财&#x27;</span>, <span class="number">4</span>);dog.bark();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>通过继承可以在不修改类的情况下完成对类的扩展</p>
</li>
</ul>
<h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><ul>
<li><p>发生继承时，如果子类中的方法会<strong>替换</strong>掉父类中的同名方法，这就称为方法的重写</p>
</li>
<li><p>示例：</p>
<ul>
<li>```typescript<br>class Animal{    name: string;    age: number;    constructor(name: string, age: number){        this.name = name;        this.age = age;    }    run(){        console.log(<code>父类中的run方法！</code>);    }}class Dog extends Animal{    bark(){        console.log(<code>$&#123;this.name&#125;在汪汪叫！</code>);    }    run(){        console.log(<code>子类中的run方法，会重写父类中的run方法！</code>);    }}const dog = new Dog(‘旺财’, 4);dog.bark();<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **super**</span><br><span class="line"></span><br><span class="line">  - 在类的方法中 **super就表示当前类的父类**</span><br><span class="line">  - 如果在子类中写了构造函数，在子类构造函数中必须对父类的构造函数进行调用</span><br><span class="line"></span><br><span class="line">  ```typescript</span><br><span class="line">  (function () &#123;    class Animal &#123;        name: string;        constructor(name: string) &#123;            this.name = name;        &#125;        sayHello() &#123;            console.log(&#x27;动物在叫~&#x27;);        &#125;    &#125;    class Dog extends Animal&#123;        age: number;        // 相当于重写了        constructor(name: string, age: number) &#123;            // 如果在子类中写了构造函数，在子类构造函数中必须对父类的构造函数进行调用            super(name); // 调用父类的构造函数            this.age = age;        &#125;        sayHello() &#123;            // 在类的方法中 super就表示当前类的父类            //super.sayHello();            console.log(&#x27;汪汪汪汪！&#x27;);        &#125;    &#125;    const dog = new Dog(&#x27;旺财&#x27;, 3);    dog.sayHello();&#125;)();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>抽象类</strong>（abstract class）</p>
<ul>
<li><p>抽象类是专门用来被其他类所继承的类，它<strong>只能被其他类所继承不能用来创建实例</strong></p>
</li>
<li><p>```typescript<br>abstract class Animal{    abstract run(): void;    bark(){        console.log(‘动物在叫<del>‘);    }}class Dog extends Animals{    run(){        console.log(‘狗在跑</del>‘);    }}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 使用**abstract**开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，继承抽象类时抽象方法必须要实现（必须重写）</span><br><span class="line"></span><br><span class="line">  ```typescript</span><br><span class="line">  abstract sayHello():void;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="3、接口（Interface）"><a href="#3、接口（Interface）" class="headerlink" title="3、接口（Interface）"></a>3、接口（Interface）</h2><ul>
<li><p>接口的作用<strong>类似于抽象类</strong>，不同点在于接口中的所有方法和属性都是<strong>没有实值</strong>的，换句话说接口中的所有方法<strong>都是抽象方法</strong>。</p>
</li>
<li><p>接口主要负责定义一个类的结构，接口可以去限制一个对象的接口，对象只有包含接口中定义的所有属性和方法时才能匹配接口。</p>
</li>
<li><p>示例（检查对象类型）：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person&#123;    name: <span class="built_in">string</span>;    sayHello():<span class="built_in">void</span>;&#125;<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">per: Person</span>)</span>&#123;    per.sayHello();&#125;fn(&#123;<span class="attr">name</span>:<span class="string">&#x27;孙悟空&#x27;</span>, <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;<span class="built_in">console</span>.log(<span class="string">`Hello, 我是 <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>)&#125;&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性。</p>
</li>
<li><p>实现接口就是使类满足接口的要求</p>
</li>
<li><p>示例（实现）</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person&#123;    name: <span class="built_in">string</span>;    sayHello():<span class="built_in">void</span>;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="title">implements</span> <span class="title">Person</span></span>&#123;    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>)</span> &#123;    &#125;    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;        <span class="built_in">console</span>.log(<span class="string">&#x27;大家好，我是&#x27;</span>+<span class="built_in">this</span>.name);    &#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4、泛型（Generic）"><a href="#4、泛型（Generic）" class="headerlink" title="4、泛型（Generic）"></a>4、泛型（Generic）</h2><ul>
<li><p>概念</p>
<ul>
<li>不确定某个类型</li>
<li><strong>自定义表示某个类型。</strong></li>
</ul>
</li>
<li><p>使用条件</p>
<ul>
<li>在定义函数或是类时，如果遇到类型不明确就可以使用泛型</li>
<li>定义一个函数或类时，有些情况下<strong>无法确定其中要使用的具体类型</strong>（返回值、参数、属性的类型不能确定），此时泛型便能够发挥作用。</li>
</ul>
</li>
<li><p>举个例子：</p>
<ul>
<li><p>```typescript<br>function test(arg: any): any{    return arg;}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的，由于类型不确定所以参数和返回值**均使用了any**，但是很明显这样做是不合适的，首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型</span><br><span class="line"></span><br><span class="line">- 使用泛型：</span><br><span class="line"></span><br><span class="line">- ```typescript</span><br><span class="line">  function test&lt;T&gt;(arg: T): T&#123;	return arg;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>这里的<code>&lt;T&gt;</code>就是泛型，T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型。所以泛型其实很好理解，就<strong>表示某个类型。</strong></p>
</li>
<li><p>那么如何使用上边的函数呢？</p>
<ul>
<li><p>方式一（直接使用）：</p>
<ul>
<li><p>```typescript<br>test(10)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式</span><br><span class="line"></span><br><span class="line">- 方式二（指定类型）：</span><br><span class="line"></span><br><span class="line">  - ```typescript</span><br><span class="line">    test&lt;number&gt;(10)</span><br></pre></td></tr></table></figure></li>
<li><p>也可以在函数后手动指定泛型</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>可以同时指定多个泛型，泛型间使用逗号隔开：</p>
<ul>
<li>```typescript<br>function test&lt;T, K&gt;(a: T, b: K): K{    return b;}test&lt;number, string&gt;(10, “hello”);<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 使用泛型时，完全可以将泛型当成是一个普通的类去使用</span><br><span class="line"></span><br><span class="line">- 类中同样可以使用泛型：</span><br><span class="line"></span><br><span class="line">  - ```typescript</span><br><span class="line">    class MyClass&lt;T&gt;&#123;    prop: T;    constructor(prop: T)&#123;        this.prop = prop;    &#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>除此之外，也可以对泛型的范围进行约束</p>
<ul>
<li><pre><code class="typescript">interface MyInter&#123;    length: number;&#125;function test&lt;T extends MyInter&gt;(arg: T): number&#123;    return arg.length;&#125;
</code></pre>
</li>
<li><p>使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口类和抽象类同样适用。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>code</category>
        <category>frontend</category>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>frontEnd</tag>
      </tags>
  </entry>
</search>
