<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【WebGL之巅】05-通过鼠标点击绘点_v2_彩色版</title>
    <url>/2021/07/25/ClickedPoints-color/</url>
    <content><![CDATA[<blockquote>
<p>对应《WebGL编程指南》代码：05-ColorPoints</p>
<p>要点：注册js事件、匿名函数、坐标转换、g_points.push()</p>
</blockquote>
<span id="more"></span>

<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><h5 id="一、为何使用匿名函数？"><a href="#一、为何使用匿名函数？" class="headerlink" title="一、为何使用匿名函数？"></a>一、为何使用匿名函数？</h5><p>先看示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册鼠标点击事件响应函数(匿名函數)</span></span><br><span class="line">canvas.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    click(event, gl, canvas, a_Position);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当你要画一个点时，需要传入三个变量（gl、canvas、a_Position），这三个变量是定义在<code>main()</code>函数中的局部变量。</p>
<p>当用户点击鼠标时，浏览器会自动调用注册到<code>&lt;canvas&gt;</code>的ommousedown属性上的函数，并传入<code>event</code>（后面简写为‘e’）参数，通常你会这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">canvas.onmousedown = mousedown	<span class="comment">// 注册响应函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mousedown</span>(<span class="params">e</span>) </span>&#123; ... &#125;<span class="comment">// 接收事件响应参数</span></span><br></pre></td></tr></table></figure>

<p>但是，这样写会出现一个问题，定义在main()函数外部的mousedown()函数就无法获取 main函数中的局部变量，而使用匿名函数就可以解决这个问题。</p>
<p>当用户点击鼠标后，程序先调用匿名函数function(e)，再调用匿名函数中的click()传入参数。</p>
<p>当然，这里也可以使用<code>ES6</code>的箭头函数更加简洁：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">canvas.onmousedown = <span class="function"><span class="params">ev</span> =&gt;</span> click(ev, gl, canvas, a_Position);</span><br></pre></td></tr></table></figure>

<h5 id="二、坐标转换"><a href="#二、坐标转换" class="headerlink" title="二、坐标转换"></a>二、坐标转换</h5><p>区别：</p>
<p>​    ①**客户区原点(0,0)**：位于浏览器视图区的左上角顶点处</p>
<p>​    ②<strong>canvas原点</strong>：位于绘图区左上角顶点处（…）</p>
<p>​    ③<strong>WebGL原点</strong>：位于绘图区中心点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;canvas&gt;在浏览器客户区中的坐标</span></span><br><span class="line"><span class="keyword">var</span> rect = ev.target.getBoundingClientRect();</span><br><span class="line">x = ((x - rect.left) - canvas.height / <span class="number">2</span>) / (canvas.height / <span class="number">2</span>);</span><br><span class="line">y = (canvas.width / <span class="number">2</span> - (y - rect.top)) / (canvas.width / <span class="number">2</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">rect.left：<canvas>原点在客户区中x坐标</th>
<th>使用*{margin:0;padding:0;list-style: none;}清除默认样式后，与客户区原点重和,即(0,0)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">rect.top：<canvas>原点在客户区中y坐标</td>
<td>若不清除默认样式后，canvas原点可能位于(8,8)，仅限博主浏览器测试。</td>
</tr>
<tr>
<td align="left">x</td>
<td>相对于浏览器左上角顶点处的鼠标横轴位置</td>
</tr>
<tr>
<td align="left">y</td>
<td>相对于浏览器左上角顶点处的鼠标纵轴位置</td>
</tr>
<tr>
<td align="left"><strong>x - rect.left：鼠标点击处相对于canvas原点位置</strong></td>
<td>将(x,y)转换成canvas坐标系的坐标</td>
</tr>
<tr>
<td align="left"><strong>y - rect.top：鼠标点击处相对于canvas原点位置</strong></td>
<td>将(x,y)转换成canvas坐标系的坐标</td>
</tr>
<tr>
<td align="left">canvas.height/width</td>
<td>绘图区的宽高</td>
</tr>
<tr>
<td align="left">(canvas.height/width) / 2</td>
<td>绘图区的中心点</td>
</tr>
<tr>
<td align="left">(x - rect.left) - canvas.width / 2</td>
<td>WebGL系统的原点</td>
</tr>
<tr>
<td align="left">canvas.height / 2 - (y - rect.top)</td>
<td>WebGL系统的原点</td>
</tr>
<tr>
<td align="left">((x - rect.left) - canvas.width / 2) / (canvas.width / 2)</td>
<td>将canvas坐标系下的坐标转换为WebGL坐标系中，最终渲染位置</td>
</tr>
<tr>
<td align="left">(canvas.height / 2 - (y - rect.top))</td>
<td>将canvas坐标系下的坐标转换为WebGL坐标系中，最终渲染位置</td>
</tr>
</tbody></table>
<h5 id="三、为啥用g-points-push"><a href="#三、为啥用g-points-push" class="headerlink" title="三、为啥用g_points.push()"></a>三、为啥用g_points.push()</h5><p>因为WebGL系统中的绘制操作实际上是在颜色缓冲区中进行绘制，绘制结束后系统将缓冲区中的内容显示在屏幕上，然后颜色缓冲区就会被重置，其中内容就会丢失。也由此，每次点击后，浏览器会重新绘制之前的并绘制新点击的。</p>
<h5 id="四、uniform变量"><a href="#四、uniform变量" class="headerlink" title="四、uniform变量"></a>四、uniform变量</h5><p>作用：从js程序向顶点和片元着色器传输“一致的”（不变的）数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">声明变量：&lt;存储限定符&gt;&lt;类型&gt;&lt;变量名&gt;</span><br><span class="line">          uniform    vec4  u_FragColor</span><br><span class="line">精度限定词：指定变量的范围和精度</span><br><span class="line">precision mediump float(中等精度)</span><br></pre></td></tr></table></figure>





<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>ColoredPoints<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="comment">/* body &#123;</span></span></span><br><span class="line"><span class="comment"><span class="css">            margin:0;</span></span></span><br><span class="line"><span class="comment"><span class="css">            padding:0;</span></span></span><br><span class="line"><span class="comment"><span class="css">        &#125; */</span></span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;main()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;webgl&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span>&gt;</span></span><br><span class="line">        Please use the browser supporting &quot;canvas&quot;.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/webgl-utils.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/webgl-debug.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/cuon-utils.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;ClickedPoints.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ColoredPoints.js</span></span><br><span class="line"><span class="comment">//顶点着色器程序</span></span><br><span class="line"><span class="keyword">var</span> VSHADER_SOURCE =</span><br><span class="line">    <span class="string">&#x27;attribute vec4 a_Position;&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;void main()&#123;&#x27;</span>+</span><br><span class="line">        <span class="string">&#x27;gl_Position=a_Position;&#x27;</span>+</span><br><span class="line">        <span class="string">&#x27;gl_PointSize=10.0;&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//片元着色器程序</span></span><br><span class="line"><span class="keyword">var</span> FSHADER_SOURCE=</span><br><span class="line">    <span class="string">&#x27;precision mediump float;&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;uniform vec4 u_FragColor;&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;void main()&#123;&#x27;</span>+</span><br><span class="line">        <span class="string">&#x27;gl_FragColor = u_FragColor;&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取canvas元素</span></span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;webgl&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!canvas)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to retrieve the &lt;canvas&gt; element&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取WebGL绘图上下文</span></span><br><span class="line">    <span class="keyword">var</span> gl = getWebGLContext(canvas);</span><br><span class="line">    <span class="keyword">if</span>(!gl)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to get the rendering context for WebGL&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化着色器</span></span><br><span class="line">    <span class="keyword">if</span>(!initShaders(gl,VSHADER_SOURCE,FSHADER_SOURCE))&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to initialize shaders.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取a_Position变量存储位置</span></span><br><span class="line">    <span class="keyword">var</span> a_Position = gl.getAttribLocation(gl.program, <span class="string">&#x27;a_Position&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(a_Position &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to get the storage location of a_Position&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取u_FragColor 变量存储位置</span></span><br><span class="line">    <span class="keyword">var</span> u_FragColor = gl.getUniformLocation(gl.program, <span class="string">&#x27;u_FragColor&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!u_FragColor)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Failed to get the storage location of u_FragColor&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    canvas.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">        click(ev,gl,canvas,a_Position,u_FragColor);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定清空&lt;canvas&gt;颜色</span></span><br><span class="line">    gl.clearColor(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空&lt;canvas&gt;</span></span><br><span class="line">    gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g_points = [];</span><br><span class="line"><span class="keyword">var</span> g_colors = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params">ev, gl, canvas, a_Position,u_FragColor</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x= ev.clientX;</span><br><span class="line">    <span class="keyword">var</span> y = ev.clientY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> rect = ev.target.getBoundingClientRect();</span><br><span class="line">    x = ((x - rect.left) - canvas.width / <span class="number">2</span>) / (canvas.width / <span class="number">2</span>);</span><br><span class="line">    y = (canvas.height / <span class="number">2</span> - (y - rect.top)) / (canvas.height / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//将坐标存储到g_points数组中</span></span><br><span class="line">    g_points.push([x, y]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 教程示例</span></span><br><span class="line">    <span class="comment">// if(x &gt;= 0.0 &amp;&amp; y &gt;= 0.0)&#123;  //第一象限</span></span><br><span class="line">    <span class="comment">//     g_colors.push([1.0, 0.0, 0.0, 1.0]);  //红色</span></span><br><span class="line">    <span class="comment">// &#125;else if(x &lt; 0.0 &amp;&amp; y &lt; 0.0)&#123;  //第三象限</span></span><br><span class="line">    <span class="comment">//     g_colors.push([0.0, 1.0, 0.0, 1.0]);  //绿色</span></span><br><span class="line">    <span class="comment">// &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//     g_colors.push([1.0, 1.0, 1.0, 1.0]);  //白色</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改示例</span></span><br><span class="line">    g_colors.push([<span class="built_in">Math</span>.random(), <span class="built_in">Math</span>.random(), <span class="built_in">Math</span>.random(), <span class="built_in">Math</span>.random()])</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清除&lt;canvas&gt;</span></span><br><span class="line">    gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> len = g_points.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">var</span> xy=g_points[i];</span><br><span class="line">        <span class="keyword">var</span> rgba = g_colors[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将点的位置传递到a_Position变量中</span></span><br><span class="line">        gl.vertexAttrib3f(a_Position, xy[<span class="number">0</span>], xy[<span class="number">1</span>], <span class="number">0.0</span>);</span><br><span class="line">        <span class="comment">//将点的颜色传递到u_FragColor变量中</span></span><br><span class="line">        gl.uniform4f(u_FragColor, rgba[<span class="number">0</span>],  rgba[<span class="number">1</span>], rgba[<span class="number">2</span>], rgba[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绘制点</span></span><br><span class="line">        gl.drawArrays(gl.POINTS, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p><img src="/images/ColorPoints.png" alt="1"></p>
]]></content>
      <categories>
        <category>code</category>
        <category>frontend</category>
        <category>webgl</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>WebGL</tag>
      </tags>
  </entry>
  <entry>
    <title>【WebGL之巅】00-使用canvas绘制2d矩形</title>
    <url>/2021/07/22/HelloCanvas2d/</url>
    <content><![CDATA[<blockquote>
<p>对应《WebGL编程指南》代码：00-HelloCanvas2d</p>
</blockquote>
<span id="more"></span>

<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ol>
<li><p>canvas绘图机制：上下文。要在<canvas>上绘制图像，须先获取绘图上下文，“2d”代表我们要绘制二维图形。</p>
</li>
<li><p><code>fillstyle</code>：设置或返回用于填充绘画的颜色、渐变或模式。</p>
</li>
<li><p>使用填充颜色填充矩形。<br><code>fillRect(x,y,width,height)</code></p>
<p>参数：x    矩形左上角的 x 坐标</p>
<pre><code>      y    矩形左上角的 y 坐标
      width        矩形的宽度
      height   矩形的高度
</code></pre>
</li>
</ol>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p><code>HelloCanvas2d.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Clear canvas<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;main()&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;mycanvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span>&gt;</span></span><br><span class="line">		Please use the browser supporting &quot;canvas&quot;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;HelloCanvas2d.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>HelloCanvas2d.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HelloCanvas2d.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">//获取&lt;canvas&gt;标签</span></span><br><span class="line">	<span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;mycanvas&quot;</span>);</span><br><span class="line">	<span class="comment">//如果没找到&lt;canvas&gt;标签，则输出错误信息</span></span><br><span class="line">	<span class="keyword">if</span> (!canvas) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;Failed to retrieve the &lt;canvas&gt; element.&#x27;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// canvas绘图机制：上下文。要在&lt;canvas&gt;上绘制图像，须先获取绘图上下文，“2d”代表我们要绘制二维图形。</span></span><br><span class="line">	<span class="comment">// 注意区分‘2d’大小写</span></span><br><span class="line">	<span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ctx.fillStyle = <span class="string">&quot;rgba(0,100,0,1)&quot;</span>;</span><br><span class="line">	ctx.fillRect(<span class="number">120</span>, <span class="number">10</span>, <span class="number">150</span>, <span class="number">150</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>code</category>
        <category>frontend</category>
        <category>webgl</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>WebGL</tag>
      </tags>
  </entry>
  <entry>
    <title>【WebGL之巅】01-使用webgl清空绘图区</title>
    <url>/2021/07/24/HellCanvas/</url>
    <content><![CDATA[<blockquote>
<p>对应《WebGL编程指南》代码：01-HelloCanvas</p>
</blockquote>
<span id="more"></span>

<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>获取<code>&lt;canvas&gt;</code>元素</li>
<li>获取webgl绘图上下文</li>
<li>设置背景色</li>
<li>清空<code>&lt;canvas&gt;</code></li>
</ol>
<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ol>
<li><p>gl.cleanColor()的参数</p>
</li>
<li><p>一旦指定了背景色，背景色就会驻存在WebGL系统中，在下次调用clearColor前不会改变</p>
</li>
<li><p>若想显示webgl调试错误，在调用getWebGLContext时，传入第二个参数<code>true</code>即可开启，例:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gl = getWebGLContext(canvas, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>gl.clear(buffer)清空背景色; 关于缓冲区，可以<a href="">查看这里</a></p>
</li>
</ol>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p><code>HelloCanvas.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Clear canvas<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;main()&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;webgl&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span>&gt;</span></span><br><span class="line">		Please use the browser supporting &quot;canvas&quot;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/webgl-utils.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/webgl-debug.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/cuon-utils.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;HelloCanvas.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>HelloCanvas.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HelloCanvas.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//获取&lt;canvas&gt;元素</span></span><br><span class="line">	<span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;webgl&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取WebGl绘图上下文</span></span><br><span class="line">	<span class="keyword">var</span> gl = getWebGLContext(canvas);</span><br><span class="line">	<span class="keyword">if</span>(!gl)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;Failed to get the rendering context for WebGL&#x27;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指定清空&lt;canvas&gt;的颜色</span></span><br><span class="line">	gl.clearColor(<span class="number">0.6</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清空&lt;canvas&gt;</span></span><br><span class="line">	gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p><img src="/images/HellCanvas.png"></p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p><code>getWebGLContext()</code>是《webgl编程指南》一书所编写的工具库(<code>cuon-utils.js</code>)中的方法，若有需要，可找博主私信即可。</p>
]]></content>
      <categories>
        <category>code</category>
        <category>frontend</category>
        <category>webgl</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>WebGL</tag>
      </tags>
  </entry>
  <entry>
    <title>【WebGL之巅】04-通过鼠标点击绘点_v1</title>
    <url>/2021/07/24/ClickedPoints/</url>
    <content><![CDATA[<blockquote>
<p>对应《WebGL编程指南》代码：04-ClickPoint</p>
<p>要点：注册js事件</p>
</blockquote>
<span id="more"></span>

<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ol>
<li>为何使用匿名函数？</li>
</ol>
<p>先看示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册鼠标点击事件响应函数(匿名函數)</span></span><br><span class="line">canvas.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    click(event, gl, canvas, a_Position);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当你要画一个点时，需要传入三个变量（gl、canvas、a_Position），这三个变量是定义在<code>main()</code>函数中的局部变量。</p>
<p>当用户点击鼠标时，浏览器会自动调用注册到<code>&lt;canvas&gt;</code>的ommousedown属性上的函数，并传入<code>event</code>（后面简写为‘e’）参数，通常你会这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">canvas.onmousedown = mousedown	<span class="comment">// 注册响应函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mousedown</span>(<span class="params">e</span>) </span>&#123; ... &#125;<span class="comment">// 接收事件响应参数</span></span><br></pre></td></tr></table></figure>

<p>但是，这样写会出现一个问题，定义在main()函数外部的mousedown()函数就无法获取 main函数中的局部变量，而使用匿名函数就可以解决这个问题。</p>
<p>当用户点击鼠标后，程序先调用匿名函数function(e)，再调用匿名函数中的click()传入参数。</p>
<p>当然，这里也可以使用<code>ES6</code>的箭头函数更加简洁：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">canvas.onmousedown = <span class="function"><span class="params">ev</span> =&gt;</span> click(ev, gl, canvas, a_Position);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>坐标转换</p>
<p>区别：</p>
<p>​    ①**客户区原点(0,0)**：位于浏览器视图区的左上角顶点处</p>
<p>​    ②<strong>canvas原点</strong>：位于绘图区左上角顶点处（…）</p>
<p>​    ③<strong>WebGL原点</strong>：位于绘图区中心点</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;canvas&gt;在浏览器客户区中的坐标</span></span><br><span class="line"><span class="keyword">var</span> rect = ev.target.getBoundingClientRect();</span><br><span class="line">x = ((x - rect.left) - canvas.height / <span class="number">2</span>) / (canvas.height / <span class="number">2</span>);</span><br><span class="line">y = (canvas.width / <span class="number">2</span> - (y - rect.top)) / (canvas.width / <span class="number">2</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">rect.left：<canvas>原点在客户区中x坐标</th>
<th>使用*{margin:0;padding:0;list-style: none;}清除默认样式后，与客户区原点重和,即(0,0)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">rect.top：<canvas>原点在客户区中y坐标</td>
<td>若不清除默认样式后，canvas原点可能位于(8,8)，仅限博主浏览器测试。</td>
</tr>
<tr>
<td align="left">x</td>
<td>相对于浏览器左上角顶点处的鼠标横轴位置</td>
</tr>
<tr>
<td align="left">y</td>
<td>相对于浏览器左上角顶点处的鼠标纵轴位置</td>
</tr>
<tr>
<td align="left"><strong>x - rect.left：鼠标点击处相对于canvas原点位置</strong></td>
<td>将(x,y)转换成canvas坐标系的坐标</td>
</tr>
<tr>
<td align="left"><strong>y - rect.top：鼠标点击处相对于canvas原点位置</strong></td>
<td>将(x,y)转换成canvas坐标系的坐标</td>
</tr>
<tr>
<td align="left">canvas.height/width</td>
<td>绘图区的宽高</td>
</tr>
<tr>
<td align="left">(canvas.height/width) / 2</td>
<td>绘图区的中心点</td>
</tr>
<tr>
<td align="left">(x - rect.left) - canvas.width / 2</td>
<td>WebGL系统的原点</td>
</tr>
<tr>
<td align="left">canvas.height / 2 - (y - rect.top)</td>
<td>WebGL系统的原点</td>
</tr>
<tr>
<td align="left">((x - rect.left) - canvas.width / 2) / (canvas.width / 2)</td>
<td>将canvas坐标系下的坐标转换为WebGL坐标系中，最终渲染位置</td>
</tr>
<tr>
<td align="left">(canvas.height / 2 - (y - rect.top))</td>
<td>将canvas坐标系下的坐标转换为WebGL坐标系中，最终渲染位置</td>
</tr>
</tbody></table>
<ol start="3">
<li><p>为啥用g_points.push()</p>
<p>因为WebGL系统中的绘制操作实际上是在颜色缓冲区中进行绘制，绘制结束后系统将缓冲区中的内容显示在屏幕上，然后颜色缓冲区就会被重置，其中内容就会丢失。也由此，每次点击后，浏览器会重新绘制之前的并绘制新点击的。</p>
</li>
</ol>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>ClickedPoints<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="comment">/* body &#123;</span></span></span><br><span class="line"><span class="comment"><span class="css">            margin:0;</span></span></span><br><span class="line"><span class="comment"><span class="css">            padding:0;</span></span></span><br><span class="line"><span class="comment"><span class="css">        &#125; */</span></span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;main()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;webgl&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span>&gt;</span></span><br><span class="line">        Please use the browser supporting &quot;canvas&quot;.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/webgl-utils.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/webgl-debug.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/cuon-utils.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;ClickedPoints.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ClickedPoints.js</span></span><br><span class="line"><span class="keyword">var</span> VSHADER_SOURCE =</span><br><span class="line">    <span class="string">&#x27;attribute vec4 a_Position;&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;void main()&#123;&#x27;</span>+</span><br><span class="line">        <span class="string">&#x27;gl_Position=a_Position;&#x27;</span>+</span><br><span class="line">        <span class="string">&#x27;gl_PointSize=15.0;&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> FSHADER_SOURCE=</span><br><span class="line">    <span class="string">&#x27;void main()&#123;&#x27;</span>+</span><br><span class="line">        <span class="string">&#x27;gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取canvas元素</span></span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;webgl&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!canvas)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to retrieve the &lt;canvas&gt; element&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取WebGL绘图上下文</span></span><br><span class="line">    <span class="keyword">var</span> gl = getWebGLContext(canvas);</span><br><span class="line">    <span class="keyword">if</span>(!gl)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to get the rendering context for WebGL&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化着色器</span></span><br><span class="line">    <span class="keyword">if</span>(!initShaders(gl,VSHADER_SOURCE,FSHADER_SOURCE))&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to initialize shaders.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取attribute变量存储位置</span></span><br><span class="line">    <span class="keyword">var</span> a_Position = gl.getAttribLocation(gl.program, <span class="string">&#x27;a_Position&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(a_Position &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to get the storage location of a_Position&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册鼠标点击事件响应函数(匿名函數)</span></span><br><span class="line">    canvas.onmousedown = <span class="function"><span class="params">ev</span> =&gt;</span> click(ev, gl, canvas, a_Position);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定清空&lt;canvas&gt;颜色</span></span><br><span class="line">    gl.clearColor(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空&lt;canvas&gt;</span></span><br><span class="line">    gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g_points = [];  <span class="comment">// 鼠标点击位置数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params">ev, gl, canvas, a_Position</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x= ev.clientX;  <span class="comment">// 鼠标点击处的x坐标</span></span><br><span class="line">    <span class="keyword">var</span> y = ev.clientY; <span class="comment">// 鼠标点击处的y坐标</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> rect = ev.target.getBoundingClientRect();</span><br><span class="line">    x = ((x - rect.left) - canvas.width / <span class="number">2</span>) / (canvas.width / <span class="number">2</span>);</span><br><span class="line">    y = (canvas.height / <span class="number">2</span> - (y - rect.top)) / (canvas.height / <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将坐标存储到g_points数组中</span></span><br><span class="line">    g_points.push(x);</span><br><span class="line">    g_points.push(y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除&lt;canvas&gt;</span></span><br><span class="line">    gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> len = g_points.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">// 将点的位置传递到变量中</span></span><br><span class="line">        gl.vertexAttrib3f(a_Position, g_points[i], g_points[i+<span class="number">1</span>], <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制点</span></span><br><span class="line">        gl.drawArrays(gl.POINTS, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h4><p>将计算出来的x、y值以数组方式存入g_points中，简化程序并提高可读性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params">ev, gl, canvas, a_Position</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x= ev.clientX;  <span class="comment">// 鼠标点击处的x坐标</span></span><br><span class="line">    <span class="keyword">var</span> y = ev.clientY; <span class="comment">// 鼠标点击处的y坐标</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> rect = ev.target.getBoundingClientRect();</span><br><span class="line">    x = ((x - rect.left) - canvas.width / <span class="number">2</span>) / (canvas.width / <span class="number">2</span>);</span><br><span class="line">    y = (canvas.height / <span class="number">2</span> - (y - rect.top)) / (canvas.height / <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将坐标存储到g_points数组中</span></span><br><span class="line">    g_points.push([x, y]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除&lt;canvas&gt;</span></span><br><span class="line">    gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> len = g_points.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> xy = g_points[i]</span><br><span class="line">        <span class="comment">// 将点的位置传递到变量中</span></span><br><span class="line">        gl.vertexAttrib3f(a_Position, xy[<span class="number">0</span>], xy[<span class="number">1</span>], <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制点</span></span><br><span class="line">        gl.drawArrays(gl.POINTS, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p><img src="/images/ClickPoints-v1.png" alt="1"></p>
]]></content>
      <categories>
        <category>code</category>
        <category>frontend</category>
        <category>webgl</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>WebGL</tag>
      </tags>
  </entry>
  <entry>
    <title>【WebGL之巅】02-绘制一个点_v1</title>
    <url>/2021/07/24/HelloPoint-v1/</url>
    <content><![CDATA[<blockquote>
<p>对应《WebGL编程指南》代码：02-HelloPoint1</p>
<p>要点：着色器、着色器代码规范、vec4（齐次坐标）、gl.drawArrays()</p>
</blockquote>
<span id="more"></span>

<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>获取<code>&lt;canvas&gt;</code>元素</li>
<li>获取WebGL上下文</li>
<li><strong>初始化着色器</strong></li>
<li>设置<code>&lt;canvas&gt;</code>背景色</li>
<li>清除<code>&lt;canvas&gt;</code></li>
<li>绘图</li>
</ol>
<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ol>
<li><h6 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h6><p><strong>顶点着色器</strong>：用来描述顶点特性（位置、颜色等）的程序。<code>顶点</code>是指二维或三维空间中的一个点（端点或交点）。</p>
<p><strong>片元着色器</strong>：进行逐片元处理过程如’光照‘的程序。<code>片元</code>是一个WebGL术语，可理解为<code>像素</code>（图像的单元）。</p>
</li>
<li><h6 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h6><p>因为着色器程序代码必须预先处理成单个字符串形式，所以用<code>+</code>将多行字符串连成长字符串，当着色器内部出错时，可以获取出错行号，也可以不使用<code>\n</code></p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顶点着色器程序</span></span><br><span class="line"><span class="keyword">var</span> VSHADER_SOURCE =</span><br><span class="line">    <span class="string">&#x27;void main() &#123;\n&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;gl_Position = vec4(0.1, 0.1, 0.0, 1.0);\n&#x27;</span> + <span class="comment">//设置坐标</span></span><br><span class="line">        <span class="string">&#x27;gl_PointSize = 10.0;\n&#x27;</span> +                    <span class="comment">//设置尺寸</span></span><br><span class="line">    <span class="string">&#x27;&#125;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片元着色器程序</span></span><br><span class="line"><span class="keyword">var</span> FSHADER_SOURCE=</span><br><span class="line">    <span class="string">&#x27;void main()&#123;\n&#x27;</span>+</span><br><span class="line">        <span class="string">&#x27;gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n&#x27;</span>+ <span class="comment">//设置颜色</span></span><br><span class="line">    <span class="string">&#x27;&#125;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><h6 id="initShaders-gl-vshader-fshader-初始化着色器，"><a href="#initShaders-gl-vshader-fshader-初始化着色器，" class="headerlink" title="initShaders(gl, vshader, fshader)初始化着色器，"></a>initShaders(gl, vshader, fshader)初始化着色器，</h6><p>返回值：true/false</p>
<p>作用：将字符串形式的着色器代码从js传给webgl系统，并建立着色器。</p>
<p>运行位置：着色器运行在WebGL系统，而不是js程序中。</p>
</li>
<li><p><strong>WebGL程序 = 运行在浏览器中的js + 运行在WebGL系统的着色器程序</strong></p>
</li>
<li><h6 id="vec4：表示三个浮点数组成的矢量（vector）"><a href="#vec4：表示三个浮点数组成的矢量（vector）" class="headerlink" title="vec4：表示三个浮点数组成的矢量（vector）"></a>vec4：表示<strong>三个浮点数</strong>组成的<strong>矢量</strong>（vector）</h6></li>
<li><h6 id="vec4-v0-v1-v2-v3"><a href="#vec4-v0-v1-v2-v3" class="headerlink" title="vec4(v0, v1, v2, v3)"></a>vec4(v0, v1, v2, v3)</h6><p>作用：创建vec4类型的变量</p>
<p>返回值：由v0~v3组成的vec4对象</p>
<p>参数：X、Y、Z坐标 + 1.0</p>
</li>
<li><h6 id="齐次坐标：由4个分离组成的矢量被称为其次坐标。"><a href="#齐次坐标：由4个分离组成的矢量被称为其次坐标。" class="headerlink" title="齐次坐标：由4个分离组成的矢量被称为其次坐标。"></a><strong>齐次坐标</strong>：由4个分离组成的矢量被称为其次坐标。</h6><p>齐次坐标用如下符号描述：(x,y,z,w)，等价于(x/w, y/w, z/w)。所以当w等于1，就可以当成三维坐标使用。w值必须大于0，若w趋近于0， 那么它表示的点趋近于无穷远。</p>
<p>作用：用矩阵乘法来描述顶点变化称为可能。</p>
</li>
<li><h6 id="gl-drawArrays"><a href="#gl-drawArrays" class="headerlink" title="gl.drawArrays()"></a>gl.drawArrays()</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">作用：执行顶点着色器，按照mode参数指定的方式绘制图形</span><br><span class="line">参数：</span><br><span class="line">	mode，指定绘制的方式（gl.POINTS/gl.LINES/gl.LINE_STRIP/gl.LINE_LOOP/gl.TRIANGLES/gl.TRIANGLE_STRIP/gl.TRIANGLE_FAN）。</span><br><span class="line">	first, 指定从那个顶点开始绘制（整数型），<span class="number">0</span>表示从第一个顶点开始画起。</span><br><span class="line">	count, 指定绘制需要多少个顶点（整数型），顶点着色器执行的次数，每次处理一个顶点。执行完后，片元着色器开始执行</span><br><span class="line">返回值：无</span><br><span class="line">错误：/</span><br></pre></td></tr></table></figure></li>
<li><h6 id="WebGL坐标系统：右手坐标系（暂时这么认为）"><a href="#WebGL坐标系统：右手坐标系（暂时这么认为）" class="headerlink" title="WebGL坐标系统：右手坐标系（暂时这么认为）"></a>WebGL坐标系统：右手坐标系（暂时这么认为）</h6></li>
</ol>
<p><img src="/images/HelloPoint-v1-01.png" alt="1"></p>
<p><img src="/images/HelloPoint-v1-02.png" alt="1"></p>
<ol start="10">
<li>WebGL不需要交换颜色缓冲区</li>
</ol>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Draw a point<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;main()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;webgl&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span>&gt;</span></span><br><span class="line">        Please use the browser supporting &quot;canvas&quot;.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/webgl-utils.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/webgl-debug.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/cuon-utils.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;HelloPoint1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HelloPoint1.js</span></span><br><span class="line"><span class="comment">// 顶点着色器程序</span></span><br><span class="line"><span class="keyword">var</span> VSHADER_SOURCE =</span><br><span class="line">    <span class="string">&#x27;void main() &#123;\n&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;gl_Position = vec4(-0.5, -0.5, 0.0, 1.0);\n&#x27;</span> + <span class="comment">//设置坐标：顶点位置</span></span><br><span class="line">        <span class="string">&#x27;gl_PointSize = 10.0;\n&#x27;</span> +                    <span class="comment">//设置尺寸（px数），默认值1.0</span></span><br><span class="line">    <span class="string">&#x27;&#125;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片元着色器程序</span></span><br><span class="line"><span class="keyword">var</span> FSHADER_SOURCE=</span><br><span class="line">    <span class="string">&#x27;void main()&#123;\n&#x27;</span>+</span><br><span class="line">        <span class="string">&#x27;gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n&#x27;</span>+ <span class="comment">//设置颜色，RGBA格式</span></span><br><span class="line">    <span class="string">&#x27;&#125;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;webgl&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> gl = getWebGLContext(canvas);</span><br><span class="line">    <span class="keyword">if</span>( !gl )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Failed to get the rendering context for WebGL&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化着色器</span></span><br><span class="line">    <span class="keyword">if</span>(!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE))&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Failed to initialize shaders.&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gl.clearColor(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    gl.drawArrays(gl.POINTS, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p><img src="/images/HelloPoint-v1-03.png" alt="1"></p>
]]></content>
      <categories>
        <category>code</category>
        <category>frontend</category>
        <category>webgl</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>WebGL</tag>
      </tags>
  </entry>
  <entry>
    <title>【WebGL之巅】03-绘制一个点_v2_attribute变量</title>
    <url>/2021/07/24/HelloPoint-v2/</url>
    <content><![CDATA[<blockquote>
<p>对应《WebGL编程指南》代码：03-HelloPoint2</p>
<p>要点：JavaScript与着色器之前数据的传输（attribute变量使用步骤）、存储限定符（attribute）、gl.getAttribLocation()、gl.vertexAttrib3f()、WebGL函数命名规范</p>
</blockquote>
<span id="more"></span>

<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ol>
<li><h6 id="位置信息的传输"><a href="#位置信息的传输" class="headerlink" title="位置信息的传输"></a>位置信息的传输</h6><p>方式1：attribute变量，传输与顶点相关的数据</p>
<p>方式2：uniform变量，传输对于所有顶点都相同（与顶点无关）的数据</p>
</li>
<li><h6 id="attribute变量使用步骤"><a href="#attribute变量使用步骤" class="headerlink" title="attribute变量使用步骤"></a>attribute变量使用步骤</h6><p>① 在顶点着色器中，声明attribute变量</p>
<p>② 将attribute变量赋值给gl_Position变量</p>
<p>③ 向attribute变量传输数据</p>
</li>
<li><h6 id="存储限定符"><a href="#存储限定符" class="headerlink" title="存储限定符"></a>存储限定符</h6><p>关键词attribute被称为存储限定符</p>
<p>声明attribute变量：**&lt;存储限定符&gt;&lt;类型&gt;&lt;变量名&gt;**</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">存储限定符  类型    变量名</span><br><span class="line">     ↓      ↓        ↓</span><br><span class="line"><span class="string">&#x27;attribute vec4 a_Position;&#x27;</span></span><br><span class="line"></span><br><span class="line">注意：以后所有attribute变量名都使用‘a_’，uniform变量名使用‘u_’规范</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> VSHADER_SOURCE =</span><br><span class="line">    <span class="string">&#x27;attribute vec4 a_Position;\n&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;attribute float a_PointSize;\n&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;void main() &#123;\n&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;gl_Position = a_Position;\n&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;gl_PointSize = a_PointSize;\n&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;&#125;\n&#x27;</span>;</span><br><span class="line">准备好从外部接收顶点坐标及尺寸</span><br></pre></td></tr></table></figure></li>
<li><h6 id="gl-getAttribLocation"><a href="#gl-getAttribLocation" class="headerlink" title="gl.getAttribLocation()"></a>gl.getAttribLocation()</h6></li>
</ol>
<table>
<thead>
<tr>
<th>作用</th>
<th>获取attribute变量地址</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>参数</td>
<td>program：程序对象，包含了顶点和片元着色器</td>
<td>name：attribute变量名称</td>
</tr>
<tr>
<td>返回值</td>
<td>大于等于0：attribute变量的存储地址</td>
<td>-1：attribute变量不存在或命名错误</td>
</tr>
<tr>
<td>错误</td>
<td>INVALID_OPERATION 程序对象未能成功连接</td>
<td>INVALID_VALUE name参数长度越界</td>
</tr>
</tbody></table>
<ol start="5">
<li><h6 id="gl-vertexAttrib3f"><a href="#gl-vertexAttrib3f" class="headerlink" title="gl.vertexAttrib3f()"></a>gl.vertexAttrib3f()</h6></li>
</ol>
<table>
<thead>
<tr>
<th>作用</th>
<th>将顶点位置传输给attribute变量</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>参数</td>
<td>location：指定将要修改的attribute变量的存储位置(a_Position)</td>
<td>v0,v1,v2,[,1.0]: 指定填充值(x,y,z坐标)</td>
</tr>
<tr>
<td>返回值</td>
<td>无</td>
<td></td>
</tr>
<tr>
<td>错误</td>
<td>INVALID_OPERATION 没有当前的program对象</td>
<td>INVALID_VALUE location数目大于attribute变量的最大数目</td>
</tr>
<tr>
<td>同族函数</td>
<td>gl.vertexAttrib1f、gl.vertexAttrib2f、gl.vertexAttrib4f</td>
<td>矢量版本：gl.vertexAttrib3f<strong>v</strong>, 可接受数组作为参数</td>
</tr>
</tbody></table>
<ol start="6">
<li><h6 id="WebGL函数命名规范"><a href="#WebGL函数命名规范" class="headerlink" title="WebGL函数命名规范"></a>WebGL函数命名规范</h6><p>遵循openGL：&lt;基础函数名&gt;&lt;参数个数&gt;&lt;参数类型&gt;</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gl.vertexAttrib <span class="number">3</span>     f ()</span><br><span class="line">       ↑        ↑     ↑</span><br><span class="line">  基础函数名  参数个数  参数类型（f：浮点数，i：整数）</span><br></pre></td></tr></table></figure>



<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>draw a point 2<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;main()&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;webgl&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span>&gt;</span></span><br><span class="line">    Please use the browser supporting &quot;canvas&quot;.</span><br><span class="line"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/webgl-utils.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/webgl-debug.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/cuon-utils.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;HelloPoint2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HelloPoint2</span></span><br><span class="line"><span class="keyword">var</span> VSHADER_SOURCE =</span><br><span class="line">    <span class="string">&#x27;attribute vec4 a_Position;\n&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;attribute float a_PointSize;\n&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;void main() &#123;\n&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;gl_Position = a_Position;\n&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;gl_PointSize = a_PointSize;\n&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;&#125;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片元着色器程序</span></span><br><span class="line"><span class="keyword">var</span> FSHADER_SOURCE=</span><br><span class="line">    <span class="string">&#x27;void main()&#123;\n&#x27;</span>+</span><br><span class="line">        <span class="string">&#x27;gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n&#x27;</span>+ <span class="comment">// 设置颜色</span></span><br><span class="line">    <span class="string">&#x27;&#125;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;webgl&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> gl=getWebGLContext(canvas);</span><br><span class="line">    <span class="keyword">if</span>(!gl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Failed to get the rendering context for WebGL&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化着色器</span></span><br><span class="line">    <span class="keyword">if</span>(!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE))&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Failed to initialize shaders.&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取attribute变量的存储位置</span></span><br><span class="line">    <span class="keyword">var</span> a_Position = gl.getAttribLocation(gl.program, <span class="string">&#x27;a_Position&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(a_Position &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Failed to get the storage location of a_Position&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取attribute变量的存储位置</span></span><br><span class="line">    <span class="keyword">var</span> a_PointSize = gl.getAttribLocation(gl.program, <span class="string">&#x27;a_PointSize&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(a_PointSize&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Failed to get the storage location of a_PointSize&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将顶点位置传输给attribute变量</span></span><br><span class="line">    <span class="comment">// gl.vertexAttrib2f(a_Position, 0.2,0.5);</span></span><br><span class="line">    gl.vertexAttrib3f(a_Position, <span class="number">0.2</span>, <span class="number">0.5</span>, <span class="number">0.0</span>);</span><br><span class="line">    gl.vertexAttrib1f(a_PointSize, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    gl.clearColor(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    gl.drawArrays(gl.POINTS, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p><img src="/images/HelloPoint-v2.png" alt="1"></p>
]]></content>
      <categories>
        <category>code</category>
        <category>frontend</category>
        <category>webgl</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>WebGL</tag>
      </tags>
  </entry>
  <entry>
    <title>【WebGL之巅】08-绘制一个矩形</title>
    <url>/2021/07/25/HelloRectangle/</url>
    <content><![CDATA[<blockquote>
<p>对应《WebGL编程指南》代码：08-HelloRectangle</p>
<p>要点：缓冲区对象、gl.drawArrays()参数</p>
<p>复习：<a href="https://freepiao.cn/2021/07/25/HelloTriangle/">【WebGL之巅】07-绘制三角形</a></p>
</blockquote>
<span id="more"></span>

<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HelloRectangle.js</span></span><br><span class="line"><span class="comment">// 顶点着色器程序</span></span><br><span class="line"><span class="keyword">var</span> VSHADER_SOURCE =</span><br><span class="line">    <span class="string">&#x27;attribute vec4 a_Position;&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;void main()&#123;&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;gl_Position=a_Position;&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片元着色器程序</span></span><br><span class="line"><span class="keyword">var</span> FSHADER_SOURCE=</span><br><span class="line">    <span class="string">&#x27;void main()&#123;&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取canvas元素</span></span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;webgl&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!canvas)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to retrieve the &lt;canvas&gt; element&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取WebGL绘图上下文</span></span><br><span class="line">    <span class="keyword">var</span> gl = getWebGLContext(canvas);</span><br><span class="line">    <span class="keyword">if</span>(!gl)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to get the rendering context for WebGL&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化着色器</span></span><br><span class="line">    <span class="keyword">if</span>(!initShaders(gl,VSHADER_SOURCE,FSHADER_SOURCE))&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to initialize shaders.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置顶点位置</span></span><br><span class="line">    <span class="keyword">var</span> n = initVertexBuffers(gl);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Failed to set the positions of the vertices&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定清空&lt;canvas&gt;颜色</span></span><br><span class="line">    gl.clearColor(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空&lt;canvas&gt;</span></span><br><span class="line">    gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制4个点</span></span><br><span class="line">    <span class="comment">// gl.drawArrays(gl.TRIANGLE_STRIP, 0, n);  // 矩形</span></span><br><span class="line">    gl.drawArrays(gl.LINE_LOOP, <span class="number">0</span>, n);  <span class="comment">// 矩形框</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initVertexBuffers</span>(<span class="params">gl</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> vertices = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span><br><span class="line">        <span class="comment">// -0.5, 0.5, -0.5, -0.5, 0.5, 0.5, 0.5, -0.5 // 矩形</span></span><br><span class="line">        -<span class="number">0.5</span>, <span class="number">0.5</span>, -<span class="number">0.5</span>, -<span class="number">0.5</span>, <span class="number">0.5</span>, -<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span> <span class="comment">// 矩形框</span></span><br><span class="line">    ]);</span><br><span class="line">    <span class="keyword">var</span> n=<span class="number">4</span>; <span class="comment">// 点的个数+1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建缓冲区对象</span></span><br><span class="line">    <span class="keyword">var</span> vertexBuffer = gl.createBuffer();</span><br><span class="line">    <span class="keyword">if</span>(!vertexBuffer)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to create thie buffer object&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将缓冲区对象保存到目标上</span></span><br><span class="line">    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向缓存对象写入数据</span></span><br><span class="line">    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a_Position = gl.getAttribLocation(gl.program, <span class="string">&#x27;a_Position&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(a_Position &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to get the storage location of a_Position&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将缓冲区对象分配给a_Postion变量</span></span><br><span class="line">    gl.vertexAttribPointer(a_Position, <span class="number">2</span>, gl.FLOAT, <span class="literal">false</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接a_Postion变量与分配给它的缓冲区对象</span></span><br><span class="line">    gl.enableVertexAttribArray(a_Position);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p><img src="/images/HelloRectangle01.png" alt="1"></p>
<p><img src="/images/HelloRectangle02.png" alt="2"></p>
]]></content>
      <categories>
        <category>code</category>
        <category>frontend</category>
        <category>webgl</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>WebGL</tag>
      </tags>
  </entry>
  <entry>
    <title>【WebGL之巅】07-绘制三角形</title>
    <url>/2021/07/25/HelloTriangle/</url>
    <content><![CDATA[<blockquote>
<p>对应《WebGL编程指南》代码：07-HelloTriangle</p>
<p>要点：缓冲区对象、gl.drawArrays</p>
<p>复习：<a href="https://freepiao.cn/2021/07/25/MultiPoints/">【WebGL之巅】06-绘制三个点</a></p>
<p>参考：《WebGL编程指南》p82~84讲解</p>
</blockquote>
<span id="more"></span>



<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>set first triangle<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;main()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;webgl&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span>&gt;</span></span><br><span class="line">     Please use the browser supporting &quot;canvas&quot;.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/webgl-utils.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/webgl-debug.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/cuon-utils.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;HelloTriangle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HelloTriangle.js</span></span><br><span class="line"><span class="comment">// 顶点着色器程序</span></span><br><span class="line"><span class="keyword">var</span> VSHADER_SOURCE =</span><br><span class="line">    <span class="string">&#x27;attribute vec4 a_Position;&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;void main()&#123;&#x27;</span>+</span><br><span class="line">        <span class="string">&#x27;gl_Position=a_Position;&#x27;</span>+</span><br><span class="line">        <span class="comment">// &#x27;gl_PointSize=10.0;&#x27;+   // 修改1 绘制单个点时起作用</span></span><br><span class="line">    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片元着色器程序</span></span><br><span class="line"><span class="keyword">var</span> FSHADER_SOURCE=</span><br><span class="line">    <span class="string">&#x27;void main()&#123;&#x27;</span>+</span><br><span class="line">    	<span class="string">&#x27;gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取canvas元素</span></span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;webgl&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!canvas)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to retrieve the &lt;canvas&gt; element&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取WebGL绘图上下文</span></span><br><span class="line">    <span class="keyword">var</span> gl = getWebGLContext(canvas);</span><br><span class="line">    <span class="keyword">if</span>(!gl)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to get the rendering context for WebGL&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化着色器</span></span><br><span class="line">    <span class="keyword">if</span>(!initShaders(gl,VSHADER_SOURCE,FSHADER_SOURCE))&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to initialize shaders.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置顶点位置</span></span><br><span class="line">    <span class="keyword">var</span> n = initVertexBuffers(gl);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Failed to set the positions of the vertices&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定清空&lt;canvas&gt;颜色</span></span><br><span class="line">    gl.clearColor(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空&lt;canvas&gt;</span></span><br><span class="line">    gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改2 绘制三角形 </span></span><br><span class="line">    gl.drawArrays(gl.TRIANGLES, <span class="number">0</span>, n);     <span class="comment">// 三角形</span></span><br><span class="line">    <span class="comment">// gl.drawArrays(gl.LINE_LOOP, 0, n);  // 三角框</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initVertexBuffers</span>(<span class="params">gl</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> vertices = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span><br><span class="line">        <span class="number">0.0</span>, <span class="number">0.5</span>, -<span class="number">0.5</span>, -<span class="number">0.5</span>, <span class="number">0.5</span>, -<span class="number">0.5</span></span><br><span class="line">    ]);</span><br><span class="line">    <span class="keyword">var</span> n=<span class="number">3</span>; <span class="comment">// 点的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建缓冲区对象</span></span><br><span class="line">    <span class="keyword">var</span> vertexBuffer = gl.createBuffer();</span><br><span class="line">    <span class="keyword">if</span>(!vertexBuffer)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to create thie buffer object&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将缓冲区对象保存到目标上</span></span><br><span class="line">    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向缓存对象写入数据</span></span><br><span class="line">    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a_Position = gl.getAttribLocation(gl.program, <span class="string">&#x27;a_Position&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(a_Position &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to get the storage location of a_Position&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将缓冲区对象分配给a_Postion变量</span></span><br><span class="line">    gl.vertexAttribPointer(a_Position, <span class="number">2</span>, gl.FLOAT, <span class="literal">false</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接a_Postion变量与分配给它的缓冲区对象</span></span><br><span class="line">    gl.enableVertexAttribArray(a_Position);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p><img src="/images/HelloTriangle01.png" alt="1"></p>
<p><img src="/images/HelloTriangle02.png" alt="2"></p>
]]></content>
      <categories>
        <category>code</category>
        <category>frontend</category>
        <category>webgl</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>WebGL</tag>
      </tags>
  </entry>
  <entry>
    <title>【WebGL之巅】06-绘制三个点</title>
    <url>/2021/07/25/MultiPoints/</url>
    <content><![CDATA[<blockquote>
<p>对应《WebGL编程指南》代码：06-MultiPoints</p>
<p>要点：缓冲区对象、gl.drawArrays、缓冲区对象向着色器传入多个顶点的数据的5个步骤</p>
<p>复习：<a href="https://freepiao.cn/2021/07/24/HelloPoint-v2/">03-绘制一个点_v2_attribute变量</a></p>
</blockquote>
<span id="more"></span>

<h4 id="绘制步骤"><a href="#绘制步骤" class="headerlink" title="绘制步骤"></a>绘制步骤</h4><p>获取WebGL上下文 <code>→</code> 初始化着色器 <code>→</code> <strong>设置点的坐标信息</strong> <code>→</code> 设置<code>&lt;canvas&gt;</code>背景色 <code>→</code> 清空<code>&lt;canvas&gt;</code> <code>→</code> 绘制</p>
<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><h5 id="一、缓冲区对象"><a href="#一、缓冲区对象" class="headerlink" title="一、缓冲区对象"></a>一、缓冲区对象</h5><p>​    作用：可以一次性地向着色器传入多个顶点的数据。</p>
<p>​    本质：是WebGL系统中的的一块内存区域。</p>
<h5 id="二、initVertexBuffers-gl"><a href="#二、initVertexBuffers-gl" class="headerlink" title="二、initVertexBuffers(gl)"></a>二、initVertexBuffers(gl)</h5><p>​    作用：创建顶点缓冲区对象，并将多个顶点的数据保存在缓冲区中，然后将缓冲区传给顶点着色器.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initVertexBuffers</span>(<span class="params">gl</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> vertices = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span><br><span class="line">        <span class="number">0.0</span>, <span class="number">0.5</span>, </span><br><span class="line">        -<span class="number">0.5</span>, -<span class="number">0.5</span>, </span><br><span class="line">        <span class="number">0.5</span>, -<span class="number">0.5</span></span><br><span class="line">    ]);</span><br><span class="line">    <span class="keyword">var</span> n=<span class="number">3</span>; <span class="comment">//点的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建缓冲区对象</span></span><br><span class="line">    <span class="keyword">var</span> vertexBuffer = gl.createBuffer();</span><br><span class="line">    <span class="keyword">if</span>(!vertexBuffer)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to create thie buffer object&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.将缓冲区对象保存到目标上</span></span><br><span class="line">    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.向缓存对象写入数据</span></span><br><span class="line">    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a_Position = gl.getAttribLocation(gl.program, <span class="string">&#x27;a_Position&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(a_Position &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to get the storage location of a_Position&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.将缓冲区对象分配给a_Postion变量</span></span><br><span class="line">    gl.vertexAttribPointer(a_Position, <span class="number">2</span>, gl.FLOAT, <span class="literal">false</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.连接a_Postion变量与分配给它的缓冲区对象(开启attribute变量)</span></span><br><span class="line">    gl.enableVertexAttribArray(a_Position);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三、缓冲区对象向着色器传入多个顶点的数据的5个步骤"><a href="#三、缓冲区对象向着色器传入多个顶点的数据的5个步骤" class="headerlink" title="三、缓冲区对象向着色器传入多个顶点的数据的5个步骤"></a>三、缓冲区对象向着色器传入多个顶点的数据的5个步骤</h5><h6 id="1-创建缓冲区对象"><a href="#1-创建缓冲区对象" class="headerlink" title="1.创建缓冲区对象"></a>1.创建缓冲区对象</h6><table>
<thead>
<tr>
<th>gl.createBuffer()</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>返回值</td>
<td>非null：新创建的缓冲区对象</td>
<td>null：创建失败</td>
</tr>
<tr>
<td>ERROR</td>
<td>/</td>
<td></td>
</tr>
</tbody></table>
<p>​    补充：</p>
<table>
<thead>
<tr>
<th>gl.deleteBuffer(Buffer)</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>参数</td>
<td>buffer：待删除的的缓冲区对象</td>
</tr>
<tr>
<td>返回值</td>
<td>/</td>
</tr>
</tbody></table>
<h6 id="2-将缓冲区对象保存到目标上"><a href="#2-将缓冲区对象保存到目标上" class="headerlink" title="2.将缓冲区对象保存到目标上"></a>2.将缓冲区对象保存到目标上</h6><table>
<thead>
<tr>
<th>gl.bindBuffer(target, buffer)</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>参数</td>
<td>target（gl.ARRAY_BUFFER表示缓冲区对象中包含了顶点的数据 / gl.ELEMENT_ARRAT_BUFFER表示缓冲区对象中包含了顶点的索引值）</td>
<td>buffer：由gl.createBuffer()创建的缓冲区对象</td>
</tr>
<tr>
<td>返回值</td>
<td>/</td>
<td></td>
</tr>
<tr>
<td>错误</td>
<td>INVALID_ENUM：target不是上述值之一</td>
<td></td>
</tr>
</tbody></table>
<p>​    注解：</p>
<p>​        ①gl.ARRAY_BUFFER，缓冲区对象存储者关于顶点的数据（顶点的位置坐标）</p>
<h6 id="3-向缓存对象写入数据"><a href="#3-向缓存对象写入数据" class="headerlink" title="3.向缓存对象写入数据"></a>3.向缓存对象写入数据</h6><table>
<thead>
<tr>
<th>gl.bufferData(target, data, usage)</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>参数</td>
<td>target（gl.ARRAY_BUFFER / gl.ELEMENT_ARRAT_BUFFER）</td>
<td>data：写入缓冲区对象的数据</td>
<td>usage：程序将如何使用存储在缓冲区对象中的数据</td>
</tr>
<tr>
<td>返回值</td>
<td>/</td>
<td></td>
<td></td>
</tr>
<tr>
<td>错误</td>
<td>INVALID_ENUM：target不是上述值之一</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>​    注解：</p>
<p>​        ①usage值：</p>
<p>​            gl.STATIC_DRAW：只会向缓冲区对象中写入一次数据，但需要绘制很多次</p>
<p>​            gl.STREAM_DRAW：只会向缓冲区对象中写入一次数据，然后绘制若干次</p>
<p>​            gl.DYNAMIC_DRAW：会向缓冲区对象中写入多次数据，并绘制很多次</p>
<p>​        ②Float32Array()：通常用来存储顶点坐标或颜色数据，类型化数组，解决了js一般Array数组存储类型杂乱问题，不支持pop、push方法，且只能使用new运算符创建，不能使用<code>[]</code></p>
<p>​    常见类型化数组：</p>
<table>
<thead>
<tr>
<th align="center">数组类型</th>
<th align="center">每个元素所占字节数</th>
<th align="center">描述（c语言中的数据类型）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Int8Array</td>
<td align="center">1</td>
<td align="center">8位整型数</td>
</tr>
<tr>
<td align="center">UInt8Array</td>
<td align="center">1</td>
<td align="center">8位无符号整型数</td>
</tr>
<tr>
<td align="center">Int16Array</td>
<td align="center">2</td>
<td align="center">16位整型数</td>
</tr>
<tr>
<td align="center">UInt16Array</td>
<td align="center">2</td>
<td align="center">16位无符号整型数</td>
</tr>
<tr>
<td align="center">Int32Array</td>
<td align="center">4</td>
<td align="center">32位整型数</td>
</tr>
<tr>
<td align="center">UInt32Array</td>
<td align="center">4</td>
<td align="center">32位无符号整型数</td>
</tr>
<tr>
<td align="center">Float32Array</td>
<td align="center">4</td>
<td align="center">单精度32位浮点数</td>
</tr>
<tr>
<td align="center">Float64Array</td>
<td align="center">8</td>
<td align="center">双精度64位浮点数</td>
</tr>
</tbody></table>
<h6 id="4-将缓冲区对象分配给a-Postion变量"><a href="#4-将缓冲区对象分配给a-Postion变量" class="headerlink" title="4.将缓冲区对象分配给a_Postion变量"></a>4.将缓冲区对象分配给a_Postion变量</h6><p><code>gl.vertexAttribPointer(location, size, type, normalized, stride, offset);</code></p>
<ul>
<li><p><strong>参数1：location</strong><br>指定要修改的顶点属性的索引。（a_Position）</p>
</li>
<li><p><strong>参数2：size</strong><br>指定每个顶点属性的组成数量，必须是1，2，3或4。</p>
</li>
<li><p><strong>参数3：type</strong><br>指定数组中每个元素的数据类型可能是：</p>
<ul>
<li><p><code>gl.BYTE</code>: signed 8-bit integer, with values in [-128, 127]<br>有符号的8位整数，范围[-128, 127]</p>
</li>
<li><p><code>gl.SHORT</code>: signed 16-bit integer, with values in [-32768, 32767]<br>有符号的16位整数，范围[-32768, 32767]</p>
</li>
<li><p><code>gl.UNSIGNED_BYTE</code>: unsigned 8-bit integer, with values in [0, 255]<br>无符号的8位整数，范围[0, 255]</p>
</li>
<li><p><code>gl.UNSIGNED_SHORT</code>: unsigned 16-bit integer, with values in [0, 65535]<br>无符号的16位整数，范围[0, 65535]</p>
</li>
<li><p><code>gl.FLOAT</code>: 32-bit IEEE floating point number<br>32位IEEE标准的浮点数</p>
</li>
<li><p>使用WebGL2版本的还可以使用以下值：</p>
<ul>
<li><code>gl.HALF_FLOAT</code>: 16-bit IEEE floating point number<br>16位IEEE标准的浮点数</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>参数4：normalized</strong><br>当转换为浮点数时是否应该将整数数值归一化到特定的范围（true/false）。</p>
<ul>
<li>For types <code>gl.BYTE</code> and <code>gl.SHORT</code>, normalizes the values to [-1, 1] if <strong>true</strong>.<br>对于类型<code>gl.BYTE</code>和<code>gl.SHORT</code>，如果是true则将值归一化为[-1, 1]</li>
<li>For types <code>gl.UNSIGNED_BYTE</code> and <code>gl.UNSIGNED_SHORT</code>, normalizes the values to [0, 1] if true.<br>对于类型<code>gl.UNSIGNED_BYTE</code>和<code>gl.UNSIGNED_SHORT</code>，如果是true则将值归一化为[0, 1]</li>
<li>For types <code>gl.FLOAT</code> and <code>gl.HALF_FLOAT</code>, this parameter has no effect.<br>对于类型<code>gl.FLOAT</code>和<code>gl.HALF_FLOAT</code>，此参数无效</li>
</ul>
</li>
<li><p><strong>参数5：stride</strong></p>
<p>指定相邻两个顶点间的字节数，默认为0.</p>
<p>一个GLsizei，以字节为单位指定连续顶点属性开始之间的偏移量(即数组中一行长度)。不能大于255。如果stride为0，则假定该属性是紧密打包的，即不交错属性，每个属性在一个单独的块中，下一个顶点的属性紧跟当前顶点之后。</p>
</li>
<li><p><strong>参数6：offset</strong></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Types"><code>GLintptr</code> (en-US)</a>指定顶点属性数组中第一部分的字节偏移量。即attribute变量从缓冲区何处开始存储。必须是类型的字节长度的倍数。</p>
</li>
</ul>
<h6 id="5-连接a-Postion变量与分配给它的缓冲区对象-开启attribute变量"><a href="#5-连接a-Postion变量与分配给它的缓冲区对象-开启attribute变量" class="headerlink" title="5.连接a_Postion变量与分配给它的缓冲区对象(开启attribute变量)"></a>5.连接a_Postion变量与分配给它的缓冲区对象(开启attribute变量)</h6><p>​    <code>gl.enableVertexAttribArray(a_Position)</code></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>location：指定attribute变量的存储位置</th>
</tr>
</thead>
<tbody><tr>
<td>返回值</td>
<td>/</td>
</tr>
<tr>
<td>错误</td>
<td>INVALID_VALUE</td>
</tr>
</tbody></table>
<p>​    关闭分配：</p>
<p>​    <code>gl.disableVertexAttribArray(a_Position)</code></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>location：指定attribute变量的存储位置</th>
</tr>
</thead>
<tbody><tr>
<td>返回值</td>
<td>/</td>
</tr>
<tr>
<td>错误</td>
<td>INVALID_VALUE</td>
</tr>
</tbody></table>
<h5 id="四、gl-drawArrays-gl-POINTS-first-count"><a href="#四、gl-drawArrays-gl-POINTS-first-count" class="headerlink" title="四、gl.drawArrays(gl.POINTS, first, count)"></a>四、gl.drawArrays(gl.POINTS, first, count)</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">作用：执行顶点着色器，按照mode参数指定的方式绘制图形</span><br><span class="line">参数：</span><br><span class="line">	mode，指定绘制的方式（gl.POINTS/gl.LINES/gl.LINE_STRIP/gl.LINE_LOOP/gl.TRIANGLES/gl.TRIANGLE_STRIP/gl.TRIANGLE_FAN）。</span><br><span class="line">	first, 指定从那个顶点开始绘制（整数型），<span class="number">0</span>表示从第一个顶点开始画起。</span><br><span class="line">	count, 指定绘制需要多少个顶点（整数型），顶点着色器执行的次数，每次处理一个顶点。执行完后，片元着色器开始执行</span><br><span class="line">返回值：无</span><br><span class="line">错误：/</span><br></pre></td></tr></table></figure>

<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>setPoint<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;main()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;webgl&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span>&gt;</span></span><br><span class="line">     Please use the browser supporting &quot;canvas&quot;.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/webgl-utils.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/webgl-debug.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/cuon-utils.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;MultiPoints.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MultiPoints.js</span></span><br><span class="line"><span class="comment">// 顶点着色器程序</span></span><br><span class="line"><span class="keyword">var</span> VSHADER_SOURCE =</span><br><span class="line">    <span class="string">&#x27;attribute vec4 a_Position;&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;void main()&#123;&#x27;</span>+</span><br><span class="line">        <span class="string">&#x27;gl_Position=a_Position;&#x27;</span>+</span><br><span class="line">        <span class="string">&#x27;gl_PointSize=10.0;&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片元着色器程序</span></span><br><span class="line"><span class="keyword">var</span> FSHADER_SOURCE=</span><br><span class="line">    <span class="string">&#x27;void main()&#123;&#x27;</span>+</span><br><span class="line">        <span class="string">&#x27;gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取canvas元素</span></span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;webgl&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!canvas)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to retrieve the &lt;canvas&gt; element&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取WebGL绘图上下文</span></span><br><span class="line">    <span class="keyword">var</span> gl = getWebGLContext(canvas);</span><br><span class="line">    <span class="keyword">if</span>(!gl)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to get the rendering context for WebGL&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化着色器</span></span><br><span class="line">    <span class="keyword">if</span>(!initShaders(gl,VSHADER_SOURCE,FSHADER_SOURCE))&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to initialize shaders.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置顶点位置</span></span><br><span class="line">    <span class="keyword">var</span> n = initVertexBuffers(gl);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Failed to set the positions of the vertices&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定清空&lt;canvas&gt;颜色</span></span><br><span class="line">    gl.clearColor(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空&lt;canvas&gt;</span></span><br><span class="line">    gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制三个点</span></span><br><span class="line">    gl.drawArrays(gl.POINTS, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initVertexBuffers</span>(<span class="params">gl</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> vertices = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span><br><span class="line">        <span class="number">0.0</span>, <span class="number">0.5</span>, </span><br><span class="line">        -<span class="number">0.5</span>, -<span class="number">0.5</span>, </span><br><span class="line">        <span class="number">0.5</span>, -<span class="number">0.5</span></span><br><span class="line">    ]);</span><br><span class="line">    <span class="keyword">var</span> n=<span class="number">3</span>; <span class="comment">//点的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建缓冲区对象</span></span><br><span class="line">    <span class="keyword">var</span> vertexBuffer = gl.createBuffer();</span><br><span class="line">    <span class="keyword">if</span>(!vertexBuffer)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to create thie buffer object&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.将缓冲区对象保存到目标上</span></span><br><span class="line">    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.向缓存对象写入数据</span></span><br><span class="line">    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// attribute变量的存储位置</span></span><br><span class="line">    <span class="keyword">var</span> a_Position = gl.getAttribLocation(gl.program, <span class="string">&#x27;a_Position&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(a_Position &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to get the storage location of a_Position&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.将缓冲区对象分配给a_Postion变量</span></span><br><span class="line">    gl.vertexAttribPointer(a_Position, <span class="number">2</span>, gl.FLOAT, <span class="literal">false</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.连接a_Postion变量与分配给它的缓冲区对象(开启attribute变量)</span></span><br><span class="line">    gl.enableVertexAttribArray(a_Position);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p><img src="/images/MultiPoints.png" alt="1"></p>
]]></content>
      <categories>
        <category>code</category>
        <category>frontend</category>
        <category>webgl</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>WebGL</tag>
      </tags>
  </entry>
  <entry>
    <title>【WebGL之巅】11-使用Matrix变换矩阵实现三角形旋转、平移、缩放</title>
    <url>/2021/07/26/RotatedTriangle-Matrix/</url>
    <content><![CDATA[<blockquote>
<p>对应《WebGL编程指南》代码：12-RotatedTriangle_Matrix</p>
<p>要点：矩阵变换（旋转矩阵）</p>
</blockquote>
<span id="more"></span>

<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><h5 id="一、矩阵和矢量的乘法"><a href="#一、矩阵和矢量的乘法" class="headerlink" title="一、矩阵和矢量的乘法"></a>一、矩阵和矢量的乘法</h5><p>矩阵示例：</p>
<p>​    $<br>\begin{bmatrix}<br>​    8 &amp; 3 &amp; 0 \\<br>​    4 &amp; 3 &amp; 6 \\<br>​    3 &amp; 2 &amp; 6<br>\end{bmatrix}<br>$​</p>
<p>矩阵相乘：</p>
<p>​    $<br>\begin{bmatrix}<br>​    x’  \\<br>​    y’  \\<br>​    z’<br>\end{bmatrix}<br> = $$<br>\begin{bmatrix}<br>​    a &amp; b &amp; c \\<br>​    d &amp; e &amp; f \\<br>​    g &amp; h &amp; i<br>\end{bmatrix}<br>$ * $<br>\begin{bmatrix}<br>​    x  \\<br>​    y  \\<br>​    z<br>\end{bmatrix}$</p>
<p>结果：</p>
<p>$  \begin{cases} x’ = ax + by + cz \\ y’ = dx + ey + fz \\ z’ = gx + hy + iz \end{cases} $​​</p>
<p>注意：只有在矩阵列数与矢量的行数相等时才能相乘，且不满足交换律</p>
<h5 id="二、变换矩阵：旋转"><a href="#二、变换矩阵：旋转" class="headerlink" title="二、变换矩阵：旋转"></a>二、变换矩阵：旋转</h5><p>对比上一节计算角度变换的公式：</p>
<p>$  \begin{cases} x’ = xcosβ - ysinβ \\ y’ = xsinβ + ycosβ \\ z’ = z \end{cases} $</p>
<p>这里假设 </p>
<p>$  \begin{cases} a = cosβ, b = -sinβ, c = 0 \\ d = sinβ, e = cosβ, f = 0 \\ g = 0, h = 0, i = 1 \end{cases} $</p>
<p>那么此时矩阵的乘法就可以变成：</p>
<p>​    $<br>\begin{bmatrix}<br>​    x’  \\<br>​    y’  \\<br>​    z’<br>\end{bmatrix}<br> = $$<br>\begin{bmatrix}<br>​    cosβ &amp; -sinβ &amp; 0 \\<br>​    sinβ &amp; cosβ &amp; 0 \\<br>​    0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>$ * $<br>\begin{bmatrix}<br>​    x  \\<br>​    y  \\<br>​    z<br>\end{bmatrix}$</p>
<p>这个矩阵就被称为<strong>变换矩阵</strong>，将（x, y, z）变换成（x’, y’, z’），这个矩阵又可以称为<strong>旋转矩阵</strong></p>
<p>接下来就是代码中的变换矩阵：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xformMatrix = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(</span><br><span class="line">    [</span><br><span class="line">        cosB, sinB, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">        -sinB, cosB, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">        <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>,</span><br><span class="line">        <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span></span><br><span class="line">    ]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u_xformMatrix = gl.getUniformLocation(gl.program, <span class="string">&#x27;u_xformMatrix&#x27;</span>);</span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">gl.uniformMatrix4fv(u_xformMatrix, <span class="literal">false</span>, xformMatrix);</span><br></pre></td></tr></table></figure>

<h5 id="三、变换矩阵：平移"><a href="#三、变换矩阵：平移" class="headerlink" title="三、变换矩阵：平移"></a>三、变换矩阵：平移</h5><p>对比一般平移计算公式：</p>
<p>​    $x’ = ax+by+cz$</p>
<p>​    $x’ = x + Tx$     (一般方法)</p>
<p>分析：这里的<code>Tx</code>是一个常量，但是第一个等式中没有常量，意味着3X3的矩阵无法表示平移，所有这里使用4X4矩阵，以及具有第4个分量的矢量（通常设为1.0），也就是说，假设要进行平移的点<code>p(x, y, z, 1)</code>，平移后坐标为<code>p&#39;(x&#39;, y&#39;, z&#39;, 1)</code>，如下等式：</p>
<p>$<br>\begin{bmatrix}<br>    x’  \\<br>    y’  \\<br>    z’  \\<br>    1<br>\end{bmatrix}<br> = $$<br>\begin{bmatrix}<br>    a &amp; b &amp; c &amp; d \\<br>    e &amp; f &amp; g &amp; h \\<br>    i &amp; j &amp; k &amp; l \\<br>    m &amp; n &amp; o &amp; p<br>\end{bmatrix}<br>$​ * $<br>\begin{bmatrix}<br>    x  \\<br>    y  \\<br>    z  \\<br>    1<br>\end{bmatrix}$​​​​</p>
<p>结果如下：</p>
<p>$  \begin{cases} x’ = ax + by + cz + d \\ y’ = ex + fy + gz + h \\ z’ = ix + jy + kz + l \\ 1 = mx + ny + oz + p \end{cases} $​</p>
<p>根据式子$1 = mx + ny + oz + p$​​，计算出$m=0，n=0，o=0，p=1$​​，其中d、h、lp均为常数​，比较等式：</p>
<p>$  \begin{cases} x’ = x + Tx \\ y’ = y + Ty \\ z’ = z + Tz \end{cases} $</p>
<p>得出<strong>平移矩阵</strong></p>
<p>$<br>\begin{bmatrix}<br>    x’  \\<br>    y’  \\<br>    z’  \\<br>    1<br>\end{bmatrix}<br> = $$<br>\begin{bmatrix}<br>    1 &amp; 0 &amp; 0 &amp; Tx \\<br>    0 &amp; 1 &amp; 0 &amp; Ty \\<br>    0 &amp; 0 &amp; 1 &amp; Tz \\<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>$​ * $<br>\begin{bmatrix}<br>    x  \\<br>    y  \\<br>    z  \\<br>    1<br>\end{bmatrix}$​​</p>
<p>程序示例代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xformMatrix = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(</span><br><span class="line">        [</span><br><span class="line">            <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">            <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">            <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>,</span><br><span class="line">            Tx, Ty, Tz, <span class="number">1.0</span></span><br><span class="line">        ]</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u_xformMatrix = gl.getUniformLocation(gl.program, <span class="string">&#x27;u_xformMatrix&#x27;</span>);</span><br><span class="line">gl.uniformMatrix4fv(u_xformMatrix, <span class="literal">false</span>, xformMatrix);</span><br></pre></td></tr></table></figure>

<h5 id="四、4x4旋转矩阵——先旋转再平移"><a href="#四、4x4旋转矩阵——先旋转再平移" class="headerlink" title="四、4x4旋转矩阵——先旋转再平移"></a>四、4x4旋转矩阵——先旋转再平移</h5><p>分析：要达到先旋转再平移的效果，需要将两个矩阵组合起来，而旋转矩阵（3x3）与平移矩阵（4x4）的阶数不同，需要某种手段使两者阶数一致</p>
<p>将3x3阶矩阵转换为4X4阶矩阵，可以比较：</p>
<p>$  \begin{cases} x’ = xcosβ - ysinβ \\ y’ = xsinβ + ycosβ \\ z’ = z \end{cases} 与$​ $  \begin{cases} x’ = ax + by + cz + d \\ y’ = ex + fy + gz + h \\ z’ = ix + jy + kz + l \\ 1 = mx + ny + oz + p \end{cases} $</p>
<p>可知，例如两者x’表达式中，令a=cosβ，b=-sinβ，c=0，d=0即可相等，以此类推解出y’、z’中的系数，得出<strong>4x4的旋转矩阵</strong>:</p>
<p>$<br>\begin{bmatrix}<br>    x’  \\<br>    y’  \\<br>    z’  \\<br>    1<br>\end{bmatrix}<br> = $$<br>\begin{bmatrix}<br>    cosβ &amp; -sinβ &amp; 0 &amp; 0 \\<br>    sinβ &amp; cosβ &amp; 0 &amp; 0 \\<br>    0 &amp; 0 &amp; 1 &amp; 0 \\<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>$​​ * $<br>\begin{bmatrix}<br>    x  \\<br>    y  \\<br>    z  \\<br>    1<br>\end{bmatrix}$​​</p>
<h5 id="五、变换矩阵：缩放"><a href="#五、变换矩阵：缩放" class="headerlink" title="五、变换矩阵：缩放"></a>五、变换矩阵：缩放</h5><p>仍然假设最初的点p(x, y, z)，缩放过后的点p’(x’, y’, z’)，假设缩放因子Sx，Sy，Sz，那么有</p>
<p>$  \begin{cases} x’ = Sx * x \\ y’ = Sy * y \\ z’ = Sz * z \end{cases} $   与等式   $  \begin{cases} x’ = ax + by + cz + d \\ y’ = ex + fy + gz + h \\ z’ = ix + jy + kz + l \\ 1 = mx + ny + oz + p \end{cases} $​    比较</p>
<p>可知<strong>缩放矩阵</strong>如下：</p>
<p>$<br>\begin{bmatrix}<br>    x’  \\<br>    y’  \\<br>    z’  \\<br>    1<br>\end{bmatrix}<br> = $​$<br>\begin{bmatrix}<br>    Sx &amp; 0 &amp; 0 &amp; 0 \\<br>    0 &amp; Sy &amp; 0 &amp; 0 \\<br>    0 &amp; 0 &amp; Sz &amp; 0 \\<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>$​​ * $<br>\begin{bmatrix}<br>    x  \\<br>    y  \\<br>    z  \\<br>    1<br>\end{bmatrix}$​​</p>
<h5 id="六、gl-uniformMatrix4fv-location-transpose-array"><a href="#六、gl-uniformMatrix4fv-location-transpose-array" class="headerlink" title="六、gl.uniformMatrix4fv(location, transpose, array);"></a>六、gl.uniformMatrix4fv(location, transpose, array);</h5><p>作用：将array表示的4x4矩阵分配给location指定的uniform变量</p>
<p>参数：</p>
<p>​    location：uniform变量的存储位置</p>
<p>​    transpose：表示是否转置矩阵，在webGl中必须设置为false</p>
<p>​    array：待传输的类型化数组（按列主序的4x4矩阵）</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h5 id="固定代码"><a href="#固定代码" class="headerlink" title="固定代码"></a>固定代码</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>rotate triangle<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;main()&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;webgl&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span>&gt;</span></span><br><span class="line">    Please use the browser supporting &quot;canvas&quot;.</span><br><span class="line"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/webgl-utils.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/webgl-debug.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/cuon-utils.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;RotatedTriangle_Matrix.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initVertexBuffers</span>(<span class="params">gl</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> vertices = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(</span><br><span class="line">        [<span class="number">0.0</span>, <span class="number">0.5</span>, -<span class="number">0.5</span>, -<span class="number">0.5</span>, <span class="number">0.5</span>, -<span class="number">0.5</span>]</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">var</span> n=<span class="number">3</span>; <span class="comment">//点的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建缓冲区对象</span></span><br><span class="line">    <span class="keyword">var</span> vertexBuffer = gl.createBuffer();</span><br><span class="line">    <span class="keyword">if</span>(!vertexBuffer)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to create thie buffer object&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将缓冲区对象保存到目标上</span></span><br><span class="line">    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向缓存对象写入数据</span></span><br><span class="line">    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a_Position = gl.getAttribLocation(gl.program, <span class="string">&#x27;a_Position&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(a_Position &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to get the storage location of a_Position&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将缓冲区对象分配给a_Postion变量</span></span><br><span class="line">    gl.vertexAttribPointer(a_Position, <span class="number">2</span>, gl.FLOAT, <span class="literal">false</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接a_Postion变量与分配给它的缓冲区对象</span></span><br><span class="line">    gl.enableVertexAttribArray(a_Position);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4x4旋转"><a href="#4x4旋转" class="headerlink" title="4x4旋转"></a>4x4旋转</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> VSHADER_SOURCE =</span><br><span class="line">    <span class="comment">//x&#x27; = x cos b - y sin b</span></span><br><span class="line">    <span class="comment">//y&#x27; = x sin b + y cosb</span></span><br><span class="line">    <span class="comment">//z&#x27; = z</span></span><br><span class="line">    <span class="string">&#x27;attribute vec4 a_Position;\n&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;uniform mat4 u_xformMatrix;\n&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;void main() &#123;\n&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;gl_Position = u_xformMatrix * a_Position;\n&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;&#125;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> FSHADER_SOURCE=</span><br><span class="line">    <span class="string">&#x27;void main()&#123;&#x27;</span>+</span><br><span class="line">        <span class="string">&#x27;gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ANGLE = <span class="number">90.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;webgl&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!canvas)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to retrieve the &lt;canvas&gt; element&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> gl = getWebGLContext(canvas);</span><br><span class="line">    <span class="keyword">if</span>(!gl)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to get the rendering context for WebGL&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!initShaders(gl,VSHADER_SOURCE,FSHADER_SOURCE))&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to initialize shaders.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置顶点位置</span></span><br><span class="line">    <span class="keyword">var</span> n = initVertexBuffers(gl);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Failed to set the positions of the vertices&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 角度转弧度制</span></span><br><span class="line">    <span class="keyword">var</span> radian = <span class="built_in">Math</span>.PI * ANGLE / <span class="number">180.0</span>;</span><br><span class="line">    <span class="keyword">var</span> cosB = <span class="built_in">Math</span>.cos(radian);</span><br><span class="line">    <span class="keyword">var</span> sinB = <span class="built_in">Math</span>.sin(radian);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> xformMatrix = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(</span><br><span class="line">        [</span><br><span class="line">            cosB, sinB, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">            -sinB, cosB, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">            <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>,</span><br><span class="line">            <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span></span><br><span class="line">        ]</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> u_xformMatrix = gl.getUniformLocation(gl.program, <span class="string">&#x27;u_xformMatrix&#x27;</span>);</span><br><span class="line">	<span class="comment">// 将旋转矩阵传输给顶点着色器</span></span><br><span class="line">    gl.uniformMatrix4fv(u_xformMatrix, <span class="literal">false</span>, xformMatrix);</span><br><span class="line"></span><br><span class="line">    gl.clearColor(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    gl.drawArrays(gl.TRIANGLES, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="分析代码1：顶点着色器——-’uniform-mat4-u-xformMatrix-n’"><a href="#分析代码1：顶点着色器——-’uniform-mat4-u-xformMatrix-n’" class="headerlink" title="分析代码1：顶点着色器——*’uniform mat4 u_xformMatrix;\n’*"></a>分析代码1：顶点着色器——*’uniform mat4 u_xformMatrix;\n’*</h6><p>​    u_xformMatrix：旋转矩阵</p>
<p>​    a_Position：顶点坐标，即4x4旋转矩阵右侧矢量</p>
<p>​    mat4类型：表示4x4的矩阵变量</p>
<h6 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h6><p><img src="/images/RotatedTriangle_Matrix01.png" alt="1"></p>
<h5 id="4x4平移矩阵"><a href="#4x4平移矩阵" class="headerlink" title="4x4平移矩阵"></a>4x4平移矩阵</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> VSHADER_SOURCE =</span><br><span class="line">    <span class="comment">//x&#x27; = x cos b - y sin b</span></span><br><span class="line">    <span class="comment">//y&#x27; = x sin b + y cosb</span></span><br><span class="line">    <span class="comment">//z&#x27; = z</span></span><br><span class="line">    <span class="string">&#x27;attribute vec4 a_Position;\n&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;uniform mat4 u_xformMatrix;\n&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;void main() &#123;\n&#x27;</span> +</span><br><span class="line">    	<span class="string">&#x27;gl_Position = u_xformMatrix * a_Position;\n&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;&#125;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> FSHADER_SOURCE=</span><br><span class="line">    <span class="string">&#x27;void main()&#123;&#x27;</span>+</span><br><span class="line">    	<span class="string">&#x27;gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Tx = <span class="number">0.5</span>, Ty = <span class="number">0.5</span>, Tz = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;webgl&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> gl = getWebGLContext(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!initShaders(gl,VSHADER_SOURCE,FSHADER_SOURCE))&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to initialize shaders.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置顶点位置</span></span><br><span class="line">    <span class="keyword">var</span> n = initVertexBuffers(gl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> xformMatrix = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(</span><br><span class="line">        [</span><br><span class="line">            <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">            <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">            <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>,</span><br><span class="line">            Tx, Ty, Tz, <span class="number">1.0</span></span><br><span class="line">        ]</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> u_xformMatrix = gl.getUniformLocation(gl.program, <span class="string">&#x27;u_xformMatrix&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    gl.uniformMatrix4fv(u_xformMatrix, <span class="literal">false</span>, xformMatrix);</span><br><span class="line"></span><br><span class="line">    gl.clearColor(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    gl.drawArrays(gl.TRIANGLES, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="分析代码2："><a href="#分析代码2：" class="headerlink" title="分析代码2："></a>分析代码2：</h6><p>​    这是我们计算出的平移矩阵：</p>
<p>$<br>\begin{bmatrix}<br>    x’  \\<br>    y’  \\<br>    z’  \\<br>    1<br>\end{bmatrix}<br> = $$<br>\begin{bmatrix}<br>    1 &amp; 0 &amp; 0 &amp; Tx \\<br>    0 &amp; 1 &amp; 0 &amp; Ty \\<br>    0 &amp; 0 &amp; 1 &amp; Tz \\<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>$ * $<br>\begin{bmatrix}<br>    x  \\<br>    y  \\<br>    z  \\<br>    1<br>\end{bmatrix}$</p>
<p>​    然而，JavaScript只能定义数组，没有表示矩阵的类型，数组只是一维，其元素只能排成一行，而矩阵是多维。这里，有两种方式来存储矩阵元素：<strong>按行主序</strong>和<strong>按列主序</strong></p>
<p>​    WebGL与OpenGL都是采用<strong>按列主序</strong>的方式来存储矩阵：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xformMatrix = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(</span><br><span class="line">    [</span><br><span class="line">        <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">        <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">        <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>,</span><br><span class="line">        Tx, Ty, Tz, <span class="number">1.0</span></span><br><span class="line">    ]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h6 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h6><p><img src="/images/RotatedTriangle_Matrix02.png" alt="2"></p>
<h5 id="4x4缩放矩阵"><a href="#4x4缩放矩阵" class="headerlink" title="4x4缩放矩阵"></a>4x4缩放矩阵</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变换矩阵缩放</span></span><br><span class="line"><span class="keyword">var</span> VSHADER_SOURCE =</span><br><span class="line">    <span class="comment">//x&#x27; = x cos b - y sin b</span></span><br><span class="line">    <span class="comment">//y&#x27; = x sin b + y cosb</span></span><br><span class="line">    <span class="comment">//z&#x27; = z</span></span><br><span class="line">    <span class="string">&#x27;attribute vec4 a_Position;\n&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;uniform mat4 u_xformMatrix;\n&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;void main() &#123;\n&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;gl_Position = u_xformMatrix * a_Position;\n&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;&#125;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> FSHADER_SOURCE=</span><br><span class="line">    <span class="string">&#x27;void main()&#123;&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Sx = <span class="number">1.5</span>, Sy = <span class="number">1.7</span>, Sz = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;webgl&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!canvas)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to retrieve the &lt;canvas&gt; element&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> gl = getWebGLContext(canvas);</span><br><span class="line">    <span class="keyword">if</span>(!gl)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to get the rendering context for WebGL&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!initShaders(gl,VSHADER_SOURCE,FSHADER_SOURCE))&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to initialize shaders.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置顶点位置</span></span><br><span class="line">    <span class="keyword">var</span> n = initVertexBuffers(gl);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Failed to set the positions of the vertices&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> xformMatrix = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(</span><br><span class="line">        [</span><br><span class="line">            Sx, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">            <span class="number">0.0</span>, Sy, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">            <span class="number">0.0</span>, <span class="number">0.0</span>, Sz, <span class="number">0.0</span>,</span><br><span class="line">            <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span></span><br><span class="line">        ]</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> u_xformMatrix = gl.getUniformLocation(gl.program, <span class="string">&#x27;u_xformMatrix&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(u_xformMatrix &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to get the storage location of u_xformMatrix&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gl.uniformMatrix4fv(u_xformMatrix, <span class="literal">false</span>, xformMatrix);</span><br><span class="line"></span><br><span class="line">    gl.clearColor(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    gl.drawArrays(gl.TRIANGLES, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="效果-2"><a href="#效果-2" class="headerlink" title="效果"></a>效果</h6><p><img src="/images/RotatedTriangle_Matrix03.png" alt="3"></p>
]]></content>
      <categories>
        <category>code</category>
        <category>frontend</category>
        <category>webgl</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>WebGL</tag>
      </tags>
  </entry>
  <entry>
    <title>【WebGL之巅】10-仿射变换之旋转三角形</title>
    <url>/2021/07/26/RotatedTriangle/</url>
    <content><![CDATA[<blockquote>
<p>对应《WebGL编程指南》代码：11-RotatedTriangle</p>
<p>要点：旋转变换、gl.uniform4f()、gl.getUniformLocation()、矢量的加法</p>
</blockquote>
<span id="more"></span>

<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>目的：将三角形逆时针旋转90度</p>
<p>计算90度的正余弦值 → 传给顶点着色器uniform变量</p>
<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><h5 id="一、正旋转"><a href="#一、正旋转" class="headerlink" title="一、正旋转"></a>一、正旋转</h5><p>​    ①描述旋转操作：绕Z轴，逆时针旋转β角度。</p>
<p>​    ②关于“逆时针”的约定：如果β是正值，观察者在Z轴正半轴某处，<strong>视线沿着Z轴负方向</strong>观察，看到的物体是逆时针旋转的，称为为正旋转。同时满足<strong>右手法则旋转</strong>（右手握拳，大拇指指向旋转轴的正方向，其余手指的方向就是旋转的方向。）</p>
<h5 id="二、角度计算"><a href="#二、角度计算" class="headerlink" title="二、角度计算"></a>二、角度计算</h5><p>$x’ = x<em>cosβ - y</em>sinβ$</p>
<p>$y’ = x<em>sinβ + y</em>cosβ$</p>
<p>$z’ = z$</p>
<p>代码实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;uniform float u_CosB, u_SinB;\n&#x27;</span> +</span><br><span class="line"><span class="string">&#x27;void main() &#123;\n&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;gl_Position.x = a_Position.x * u_CosB - a_Position.y * u_SinB;\n&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;gl_Position.y = a_Position.x * u_SinB + a_Position.y * u_CosB;\n&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;gl_Position.z = a_Position.z;\n&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;gl_Position.w = 1.0;\n&#x27;</span> +</span><br><span class="line"><span class="string">&#x27;&#125;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>角度转弧度制（三角函数的计算一般是用弧度计算）：<code>弧度 = π*角度/180°</code>，单位：rad</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> radian = <span class="built_in">Math</span>.PI * ANGLE / <span class="number">180.0</span>;   <span class="comment">// 转为弧度制（πβ/180°）= π/2</span></span><br><span class="line"><span class="keyword">var</span> cosB = <span class="built_in">Math</span>.cos(radian); <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">var</span> sinB = <span class="built_in">Math</span>.sin(radian); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(cosB, sinB) <span class="comment">// 6.123233995736766e-17 1</span></span><br></pre></td></tr></table></figure>

<h5 id="三、a-Position的分量访问"><a href="#三、a-Position的分量访问" class="headerlink" title="三、a_Position的分量访问"></a>三、a_Position的分量访问</h5><p>vec4 a_Position = (x, y, z, w)</p>
<p>可用 a_Position.x、a_Position.y来访问</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>rotate triangle<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;main()&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;webgl&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span>&gt;</span></span><br><span class="line">    Please use the browser supporting &quot;canvas&quot;.</span><br><span class="line"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/webgl-utils.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/webgl-debug.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/cuon-utils.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;RotatedTriangle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hushhw on 17/12/14.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//RotatedTriangle.js</span></span><br><span class="line"><span class="keyword">var</span> VSHADER_SOURCE =</span><br><span class="line">    <span class="comment">//x&#x27; = x cos b - y sin b</span></span><br><span class="line">    <span class="comment">//y&#x27; = x sin b + y cosb</span></span><br><span class="line">    <span class="comment">//z&#x27; = z</span></span><br><span class="line">    <span class="string">&#x27;attribute vec4 a_Position;\n&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;uniform float u_CosB, u_SinB;\n&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;void main() &#123;\n&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;gl_Position.x = a_Position.x * u_CosB - a_Position.y * u_SinB;\n&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;gl_Position.y = a_Position.x * u_SinB + a_Position.y * u_CosB;\n&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;gl_Position.z = a_Position.z;\n&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;gl_Position.w = 1.0;\n&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;&#125;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> FSHADER_SOURCE=</span><br><span class="line">    <span class="string">&#x27;void main()&#123;&#x27;</span>+</span><br><span class="line">        <span class="string">&#x27;gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旋转角度 </span></span><br><span class="line"><span class="keyword">var</span> ANGLE = <span class="number">90.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;webgl&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!canvas)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to retrieve the &lt;canvas&gt; element&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> gl = getWebGLContext(canvas);</span><br><span class="line">    <span class="keyword">if</span>(!gl)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to get the rendering context for WebGL&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!initShaders(gl,VSHADER_SOURCE,FSHADER_SOURCE))&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to initialize shaders.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置顶点位置</span></span><br><span class="line">    <span class="keyword">var</span> n = initVertexBuffers(gl);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Failed to set the positions of the vertices&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 角度计算</span></span><br><span class="line">    <span class="keyword">var</span> radian = <span class="built_in">Math</span>.PI * ANGLE / <span class="number">180.0</span>;   <span class="comment">// 转为弧度制（πβ/180°）</span></span><br><span class="line">    <span class="keyword">var</span> cosB = <span class="built_in">Math</span>.cos(radian);</span><br><span class="line">    <span class="keyword">var</span> sinB = <span class="built_in">Math</span>.sin(radian);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> u_CosB = gl.getUniformLocation(gl.program, <span class="string">&#x27;u_CosB&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(u_CosB &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to get the storage location of u_CosB&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> u_SinB = gl.getUniformLocation(gl.program, <span class="string">&#x27;u_SinB&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(u_SinB &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to get the storage location of u_SinB&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 赋值给uniform变量</span></span><br><span class="line">    gl.uniform1f(u_CosB, cosB);</span><br><span class="line">    gl.uniform1f(u_SinB, sinB);</span><br><span class="line"></span><br><span class="line">    gl.clearColor(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    gl.drawArrays(gl.TRIANGLES, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initVertexBuffers</span>(<span class="params">gl</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> vertices = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(</span><br><span class="line">        [<span class="number">0.0</span>, <span class="number">0.5</span>, -<span class="number">0.5</span>, -<span class="number">0.5</span>, <span class="number">0.5</span>, -<span class="number">0.5</span>]</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">var</span> n=<span class="number">3</span>; <span class="comment">//点的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建缓冲区对象</span></span><br><span class="line">    <span class="keyword">var</span> vertexBuffer = gl.createBuffer();</span><br><span class="line">    <span class="keyword">if</span>(!vertexBuffer)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to create thie buffer object&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将缓冲区对象保存到目标上</span></span><br><span class="line">    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向缓存对象写入数据</span></span><br><span class="line">    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a_Position = gl.getAttribLocation(gl.program, <span class="string">&#x27;a_Position&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(a_Position &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to get the storage location of a_Position&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将缓冲区对象分配给a_Postion变量</span></span><br><span class="line">    gl.vertexAttribPointer(a_Position, <span class="number">2</span>, gl.FLOAT, <span class="literal">false</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接a_Postion变量与分配给它的缓冲区对象</span></span><br><span class="line">    gl.enableVertexAttribArray(a_Position);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p><img src="/images/RotatedTriangle.png" alt="1"></p>
]]></content>
      <categories>
        <category>code</category>
        <category>frontend</category>
        <category>webgl</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>WebGL</tag>
      </tags>
  </entry>
  <entry>
    <title>【WebGL之巅】09-仿射变换之平移三角形</title>
    <url>/2021/07/26/TranslatedTriangle/</url>
    <content><![CDATA[<blockquote>
<p>对应《WebGL编程指南》代码：10-TranslatedTriangle</p>
<p>要点：平移变换、gl.uniform4f()、gl.getUniformLocation()、矢量的加法</p>
</blockquote>
<span id="more"></span>

<h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>将一个三角形向上和向右平移0.5个单位</p>
<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><h5 id="一、逐顶点操作"><a href="#一、逐顶点操作" class="headerlink" title="一、逐顶点操作"></a>一、逐顶点操作</h5><p>​    为顶点坐标的每个分量加上一个常量就可以实现</p>
<h4 id="二、矢量的加法"><a href="#二、矢量的加法" class="headerlink" title="二、矢量的加法"></a>二、矢量的加法</h4><p>​    方便的矢量相加运算是GLSL ES提供的特性之一</p>
<table>
<thead>
<tr>
<th>矢量</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>vec4 a_Position</td>
<td>(x1, y1, z1, w1)</td>
</tr>
<tr>
<td>vec4 u_Translation</td>
<td>(x2, y2, z2, w2)</td>
</tr>
<tr>
<td>answer</td>
<td>(x1+x2, y1+y2, z1+z2, w1+w2)</td>
</tr>
</tbody></table>
<p>​    注意：这里的w2必须等于0.0，因为齐次坐标的最后一位为1.0，那么前三个分量才表示一个三维坐标</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>set first triangle<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;main()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;webgl&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span>&gt;</span></span><br><span class="line">     Please use the browser supporting &quot;canvas&quot;.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/webgl-utils.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/webgl-debug.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../lib/cuon-utils.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;TranslatedTriangle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TranslatedTriangle.js</span></span><br><span class="line"><span class="comment">//顶点着色器程序</span></span><br><span class="line"><span class="keyword">var</span> VSHADER_SOURCE =</span><br><span class="line">    <span class="string">&#x27;attribute vec4 a_Position;&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;uniform vec4 u_Translations;\n&#x27;</span> +    <span class="comment">// 接收平移变量 </span></span><br><span class="line">    <span class="string">&#x27;void main()&#123;\n&#x27;</span>+</span><br><span class="line">        <span class="string">&#x27;gl_Position=a_Position + u_Translations;\n&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;&#125;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//片元着色器程序</span></span><br><span class="line"><span class="keyword">var</span> FSHADER_SOURCE=</span><br><span class="line">    <span class="string">&#x27;void main()&#123;&#x27;</span>+</span><br><span class="line">        <span class="string">&#x27;gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Tx = <span class="number">0.5</span>, Ty = <span class="number">0.5</span>, Tz = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取canvas元素</span></span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;webgl&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!canvas)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to retrieve the &lt;canvas&gt; element&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取WebGL绘图上下文</span></span><br><span class="line">    <span class="keyword">var</span> gl = getWebGLContext(canvas);</span><br><span class="line">    <span class="keyword">if</span>(!gl)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to get the rendering context for WebGL&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化着色器</span></span><br><span class="line">    <span class="keyword">if</span>(!initShaders(gl,VSHADER_SOURCE,FSHADER_SOURCE))&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to initialize shaders.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置顶点位置</span></span><br><span class="line">    <span class="keyword">var</span> n = initVertexBuffers(gl);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Failed to set the positions of the vertices&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将平移距离传给顶点着色器</span></span><br><span class="line">    <span class="keyword">var</span> u_Translation = gl.getUniformLocation(gl.program, <span class="string">&#x27;u_Translations&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    gl.uniform4f(u_Translation, Tx, Ty, Tz, <span class="number">0.0</span>);   <span class="comment">// 第4分量必须是0.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定清空&lt;canvas&gt;颜色</span></span><br><span class="line">    gl.clearColor(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空&lt;canvas&gt;</span></span><br><span class="line">    gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制三个点</span></span><br><span class="line">    gl.drawArrays(gl.TRIANGLES, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initVertexBuffers</span>(<span class="params">gl</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> vertices = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span><br><span class="line">        <span class="number">0.0</span>, <span class="number">0.5</span>, -<span class="number">0.5</span>, -<span class="number">0.5</span>, <span class="number">0.5</span>, -<span class="number">0.5</span></span><br><span class="line">    ]);</span><br><span class="line">    <span class="keyword">var</span> n=<span class="number">3</span>; <span class="comment">//点的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建缓冲区对象</span></span><br><span class="line">    <span class="keyword">var</span> vertexBuffer = gl.createBuffer();</span><br><span class="line">    <span class="keyword">if</span>(!vertexBuffer)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to create thie buffer object&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将缓冲区对象保存到目标上</span></span><br><span class="line">    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向缓存对象写入数据</span></span><br><span class="line">    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a_Position = gl.getAttribLocation(gl.program, <span class="string">&#x27;a_Position&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(a_Position &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Failed to get the storage location of a_Position&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将缓冲区对象分配给a_Postion变量</span></span><br><span class="line">    gl.vertexAttribPointer(a_Position, <span class="number">2</span>, gl.FLOAT, <span class="literal">false</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接a_Postion变量与分配给它的缓冲区对象</span></span><br><span class="line">    gl.enableVertexAttribArray(a_Position);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p><img src="/images/TranslatedTriangle.png" alt="1"></p>
]]></content>
      <categories>
        <category>code</category>
        <category>frontend</category>
        <category>webgl</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>WebGL</tag>
      </tags>
  </entry>
  <entry>
    <title>UA伪装爬取网页【★】</title>
    <url>/2021/07/23/UA%E4%BC%AA%E8%A3%85%E7%88%AC%E5%8F%96%E7%BD%91%E9%A1%B5/</url>
    <content><![CDATA[<p>复习：<strong>UA检测</strong></p>
<blockquote>
<p>UA：User-Agent（请求载体的身份标识）.</p>
<p>门户网站的服务器会检测对应请求的载体身份标识，如果检测到请求的载体身份标识为某一款浏览器，说明该请求是一个正常的请求。但是，如果检测到请求的载体身份标识不是基于某一款浏览器的，则表示该请求为不正常的请求（爬虫），则服务器端就很有可能拒绝该次请求。</p>
</blockquote>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># UA伪装：让爬虫对应的请求载体身份标识伪装成某一款浏览器</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># UA伪装：将对应的User-Agent封装到一个字典中</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="comment"># &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36&#x27;</span></span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    url = <span class="string">&#x27;https://www.sogou.com/web&#x27;</span></span><br><span class="line">    <span class="comment"># 处理url携带的参数：封装到字典中</span></span><br><span class="line">    kw = <span class="built_in">input</span>(<span class="string">&#x27;enter a word:&#x27;</span>)</span><br><span class="line">    param = &#123;</span><br><span class="line">        <span class="string">&#x27;query&#x27;</span>: kw</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 对指定的url发起的请求对应的url是携带参数的，并且请求过程中处理了参数</span></span><br><span class="line">    response = requests.get(url=url, params=param, headers=headers)</span><br><span class="line"></span><br><span class="line">    page_text = response.text</span><br><span class="line">    fileName = kw + <span class="string">&#x27;.html&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(fileName, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(page_text)</span><br><span class="line">    <span class="built_in">print</span>(fileName, <span class="string">&#x27;保存成功！！！&#x27;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>code</category>
        <category>backend</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>bs4解析爬取三国演义所有章节及内容【★★★】</title>
    <url>/2021/07/23/bs4%E8%A7%A3%E6%9E%90%E7%88%AC%E5%8F%96%E4%B8%89%E5%9B%BD%E6%BC%94%E4%B9%89%E6%89%80%E6%9C%89%E7%AB%A0%E8%8A%82%E5%8F%8A%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<p>复习：<a href="https://www.runoob.com/w3cnote/python-spider-intro.html">Python爬虫介绍</a></p>
<p>需求：爬取三国演义小说所有的章节标题和章节内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">http://www.shicimingju.com/book/sanguoyanyi.html</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 对首页的页面数据进行爬取</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    url = <span class="string">&#x27;http://www.shicimingju.com/book/sanguoyanyi.html&#x27;</span></span><br><span class="line">    page_text = requests.get(url=url, headers=headers)</span><br><span class="line">    page_text.encoding = <span class="string">&#x27;utf-8&#x27;</span>    <span class="comment"># 解决乱码问题</span></span><br><span class="line">    page_text = page_text.text</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在首页中解析出章节的标题和详情页的url</span></span><br><span class="line">    <span class="comment"># 1.实例化BeautifulSoup对象，需要将页面源码数据加载到该对象中</span></span><br><span class="line">    soup = BeautifulSoup(page_text, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">    <span class="comment"># 解析章节标题和详情页的url</span></span><br><span class="line">    li_list = soup.select(<span class="string">&#x27;.book-mulu &gt; ul &gt; li&#x27;</span>)</span><br><span class="line">    fp = <span class="built_in">open</span>(<span class="string">&#x27;./sanguo.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> li <span class="keyword">in</span> li_list:</span><br><span class="line">        title = li.a.string</span><br><span class="line">        detail_url = <span class="string">&#x27;http://www.shicimingju.com&#x27;</span>+li.a[<span class="string">&#x27;href&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对详情页发起请求，解析出章节内容</span></span><br><span class="line">        detail_page_text = requests.get(url=detail_url, headers=headers)</span><br><span class="line">        detail_page_text.encoding = <span class="string">&#x27;utf-8&#x27;</span>  <span class="comment"># 解决乱码问题</span></span><br><span class="line">        detail_page_text = detail_page_text.text</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 解析出详情页中相关的章节内容</span></span><br><span class="line">        detail_soup = BeautifulSoup(detail_page_text, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">        div_tag = detail_soup.find(<span class="string">&#x27;div&#x27;</span>, class_=<span class="string">&#x27;chapter_content&#x27;</span>)</span><br><span class="line">        <span class="comment"># 解析到了章节的内容</span></span><br><span class="line">        content = div_tag.text</span><br><span class="line">        fp.write(<span class="string">&#x27;《&#x27;</span>+title+<span class="string">&#x27;》\n&#x27;</span>+content+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(title, <span class="string">&#x27;爬取成功！！！&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
        <category>backend</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>建站随笔</title>
    <url>/2021/07/20/hello-world/</url>
    <content><![CDATA[<p>…</p>
<span id="more"></span>


<h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="新建页面"><a href="#新建页面" class="headerlink" title="新建页面"></a>新建页面</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page ‘title’</span><br></pre></td></tr></table></figure>

<h3 id="提交Git"><a href="#提交Git" class="headerlink" title="提交Git"></a>提交Git</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<h3 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo s --debug</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<iframe src="http://www.staggeringbeauty.com/" style="border: 1px inset #ddd" width="498" height="598"></iframe>

]]></content>
      <categories>
        <category>essay</category>
        <category>建站指南</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript动态显示时间</title>
    <url>/2021/07/21/%5B%20JavaScript%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%98%BE%E7%A4%BA%E6%97%B6%E9%97%B4%E6%95%88%E6%9E%9C%EF%BC%9AsetInterval%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%20%5D/</url>
    <content><![CDATA[<p><strong>知识点</strong></p>
<span id="more"></span>

<blockquote>
<p>Timing事件之 setInterval()方法：<img src="https://img-blog.csdnimg.cn/20200809150657625.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ3NjU0MDEw,size_16,color_FFFFFF,t_70"></p>
</blockquote>
<p><strong>效果</strong><br><img src="https://img-blog.csdnimg.cn/20200809150619988.jpg"></p>
<p><strong>上代码</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;time&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;开始&quot;</span> <span class="attr">id</span>=<span class="string">&quot;start&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;结束&quot;</span> <span class="attr">id</span>=<span class="string">&quot;end&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> start = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;start&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> end = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;end&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> time1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;time&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        start.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            </span></span><br><span class="line"><span class="javascript">            <span class="comment">// clearInterval(timer);</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            timer = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                </span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="javascript">                <span class="comment">//  年月日</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> year = d.getFullYear();</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> month = d.getMonth()+<span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> day = d.getDate();</span></span><br><span class="line"><span class="javascript">                <span class="comment">//  时分秒</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> h = d.getHours();</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> m = d.getMinutes();</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> s = d.getSeconds();</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(s&lt;<span class="number">10</span>)&#123;</span></span><br><span class="line"><span class="javascript">                    s = <span class="string">&quot;0&quot;</span>+s;</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// time1.innerHTML = s;</span></span></span><br><span class="line"><span class="javascript">                time1.innerHTML = <span class="string">&quot;当前时间：&quot;</span>+year+<span class="string">&quot;-&quot;</span>+month+<span class="string">&quot;-&quot;</span>+day+<span class="string">&quot; &quot;</span>+h+<span class="string">&quot;:&quot;</span>+m+<span class="string">&quot;:&quot;</span>+s;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            &#125;,<span class="number">100</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            end.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">clearInterval</span>(timer);</span></span><br><span class="line"><span class="javascript">                <span class="comment">// alert(&#x27;stop&#x27;);</span></span></span><br><span class="line"><span class="javascript">            &#125;;</span></span><br><span class="line"><span class="javascript">        &#125;;</span></span><br><span class="line"><span class="javascript">        </span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
        <category>frontend</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7 零成本搭建web服务器【外网可访问】</title>
    <url>/2021/07/21/centosweb/</url>
    <content><![CDATA[<blockquote>
<p>更新：【Windows+Nginx+Natapp零成本搭建web服务器】教程即将上线 。</p>
</blockquote>
<span id="more"></span>

<p> 一、 <strong>技术栈</strong></p>
<blockquote>
<ul>
<li><em>虚拟机</em>：当然是选择 Linux 系统，本人使用的是 ==centos7== 版本。</li>
<li><em>服务器</em>：轻量级服务器nginx，10分钟搭建静态网站。</li>
<li><em>内网穿透</em>：使用Natapp，访问内网。</li>
</ul>
</blockquote>
<hr>
<p>二、<strong>步骤</strong></p>
<ol>
<li><p><strong>Linux系统安装与配置</strong></p>
<blockquote>
<p><em>安装linux虚拟机就跳过吧，网上一大把，当然最好是Centos系统哦。</em></p>
</blockquote>
</li>
</ol>
<ul>
<li><p>配置<br>由于是自己创建的虚拟机，需要手动打开80端口，重新配置防火墙，以及切换源。下面开始吧。</p>
<p>  <strong>==a.切换阿里源==</strong></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">备份：mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br><span class="line">清理缓存：yum clean all</span><br><span class="line">生成缓存：yum makecache</span><br></pre></td></tr></table></figure>
<p>  <strong>==b.防火墙配置==</strong></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service <span class="comment">#停止firewall</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service <span class="comment">#禁止firewall开机启动</span></span><br><span class="line">yum install iptables-services <span class="comment">#安装iptables防火墙</span></span><br><span class="line">yum install iptables-services <span class="comment">#安装iptables防火墙</span></span><br></pre></td></tr></table></figure>
<p>  <strong>==c.开启80端口==</strong></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/sysconfig/iptables <span class="comment">#编辑防火墙配置文件</span></span><br><span class="line">按i进入文本编辑模式</span><br><span class="line">找到：</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT</span><br><span class="line">在该行下面添加：</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT</span><br><span class="line">保存退出：先按ESC，再输入【:wq!】输入括号里的内容。</span><br></pre></td></tr></table></figure>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart iptables.service <span class="comment">#重启防火墙使配置生效</span></span><br><span class="line">systemctl <span class="built_in">enable</span> iptables.service <span class="comment">#设置防火墙开机启动</span></span><br><span class="line">firewall-cmd --query-port=80/tcp <span class="comment">#查询端口是否开启</span></span><br></pre></td></tr></table></figure>
<hr>
<p>   <strong>2. 配置Nginx服务器</strong></p>
<blockquote>
<p><em>简介</em>：Nginx是一个http服务器。是一个使用c语言开发的高性能的http服务器及反向代理服务器。Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。</p>
</blockquote>
<p>  <strong>==a.安装环境==</strong></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc依赖：yum install gcc-c++</span><br><span class="line">Perl库：yum install -y pcre pcre-devel</span><br><span class="line">zlib库：yum install -y zlib zlib-devel</span><br><span class="line">yum install -y openssl openssl-devel</span><br><span class="line">nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。</span><br></pre></td></tr></table></figure>
<p>  <strong>==b.安装==</strong></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span></span><br><span class="line">mkdir nginx</span><br><span class="line"><span class="built_in">cd</span> nginx	<span class="comment">#进入nginx文件夹</span></span><br><span class="line"></span><br><span class="line">wget http://nginx.org/download/nginx-1.9.7.tar.gz</span><br><span class="line">tar -zxvf nginx-1.9.7.tar.gz	<span class="comment">#解压</span></span><br><span class="line"></span><br><span class="line">./configure		<span class="comment">#安装nginx</span></span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> sbin</span><br><span class="line">sudo ./nginx	<span class="comment">#启动</span></span><br><span class="line"></span><br><span class="line">/usr/<span class="built_in">local</span>/nginx/sbin/nginx -t	<span class="comment">#查询nginx.conf是否正确</span></span><br></pre></td></tr></table></figure>
<p>  <strong>==c.配置网站文件==</strong></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">准备好自己写的网页，以目录形式上传到 /usr/<span class="built_in">local</span>/nginx/xxx/ 路径（xxx为网站跟目录名）</span><br><span class="line"><span class="built_in">cd</span> nginx</span><br><span class="line">vim conf/nginx.conf		<span class="comment">#使用vim编辑器</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       <span class="number">80</span>;</span><br><span class="line">    server_name  _;</span><br><span class="line">    <span class="comment">#root /usr/local/nginx/xxx/;      # 修改1：xxx为静态页面根目录，index.html文件放在xxx下面</span></span><br><span class="line">    <span class="comment">#index index.html;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/local/nginx/xxx/;	<span class="comment"># 修改2</span></span><br><span class="line">        index  index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /<span class="number">50</span>x.html;</span><br><span class="line">    location = /<span class="number">50</span>x.html &#123;</span><br><span class="line">        root   html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./nginx -s reload 	<span class="comment">#重启</span></span><br><span class="line"></span><br><span class="line">ps aux|grep nginx	<span class="comment">#查询nginx进程</span></span><br><span class="line"></span><br><span class="line">./nginx -s stop		<span class="comment">#停止</span></span><br></pre></td></tr></table></figure></li>
</ul>
<pre><code>&gt;   到这里，就可以实现内网之间的访问了，通过ifconfig查询桥接模式下的内网地址，在本机搜索即可进入网站。但是，做好网站只有自己能看还挺不爽的，接下来就是让别人可以访问的操作辽~

---
**3.Natapp实现内网穿透**
&gt; *简介*：内网穿透简单来说就是将内网外网通过natapp隧道打通,让内网的数据让外网可以获取。比如常用的办公室软件等，一般在办公室或家里，通过拨号上网，这样办公软件只有在本地的局域网之内才能访问，那么问题来了，如果是手机上，或者公司外地的办公人员，如何访问到办公软件呢？这就需要natapp内网穿透工具了。运行natapp隧道之后，natapp会分配一个专属域名/端口,办公软件就已经在公网上了,在外地的办公人员可以在任何地方愉快的访问办公软件了~

&gt; emmm一句话：别人可以访问你的192.168.xxx.xxx
Natapp网址：[点这里](https://natapp.cn/)

**==a.购买隧道==**

- 注册账号
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201207104539729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ3NjU0MDEw,size_16,color_FFFFFF,t_70)
- 登录，购买隧道（免费版）
- 选择web隧道协议![在这里插入图片描述](https://img-blog.csdnimg.cn/20201207104746667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ3NjU0MDEw,size_16,color_FFFFFF,t_70)
- 获取authtoken，启动时需要用
![在这里插入图片描述](https://img-blog.csdnimg.cn/2020120710531049.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ3NjU0MDEw,size_16,color_FFFFFF,t_70)

**==b.下载客户端==**
&gt; Linux可直接wget
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20201207105027387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ3NjU0MDEw,size_14,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<pre><code>**==c.运行Natapp==**
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">chmod a+x natapp	<span class="comment">#给执行权限</span></span><br><span class="line">./natapp			<span class="comment">#运行</span></span><br><span class="line"></span><br><span class="line">./natapp <span class="literal">-authtoken</span>=<span class="number">9</span>ab6b9040a624f40	<span class="comment">#参数方式运行，authtoken购买隧道后即可在控制台查看</span></span><br><span class="line">注意参数输入正确性,不要有多余的空格等!</span><br></pre></td></tr></table></figure>


&gt; 运行成功结果：![在这里插入图片描述](https://img-blog.csdnimg.cn/2020120711005848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ3NjU0MDEw,size_16,color_FFFFFF,t_70)
</code></pre>
<p>红框内的网址就是你的内网地址了，接下来就可以访问了，可以发给您的小伙伴试试~</p>
<pre><code>&gt;更多内容，欢迎访问 [宋木头](http://aoau.top/) ~
</code></pre>
<hr>
<p>原创不易，转载请注明出处：)</p>
]]></content>
      <categories>
        <category>essay</category>
        <category>建站指南</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫</title>
    <url>/2021/07/21/spider/</url>
    <content><![CDATA[<h2 id="一、爬虫基础简介"><a href="#一、爬虫基础简介" class="headerlink" title="一、爬虫基础简介"></a>一、爬虫基础简介</h2><span id="more"></span>

<h3 id="前戏"><a href="#前戏" class="headerlink" title="前戏"></a><strong>前戏</strong></h3><p>​    1.你是否在夜深人静的时候，想看一些会让你更睡不着的图片却苦于没有资源…<br>​    2.你是否在节假日出行高峰的时候，想快速抢购火车票成功…<br>​    3.你是否在网上购物的时候，想快速且精准的定位到口碑质量最好的商品…</p>
<p><strong>什么是爬虫</strong>：</p>
<pre><code>- 通过编写程序，模拟浏览器上网，然后让其去互联网上抓取数据的过程。
</code></pre>
<p><strong>爬虫的价值</strong>：<br>    - 实际应用<br>        - 就业</p>
<p><strong>爬虫究竟是合法还是违法的</strong>？</p>
<ul>
<li>在法律中是不被禁止</li>
<li>具有违法风险</li>
<li>善意爬虫  恶意爬虫</li>
</ul>
<p><strong>爬虫带来的风险可以体现在如下</strong>2方面：<br>    - 爬虫干扰了被访问网站的正常运营<br>        - 爬虫抓取了收到法律保护的特定类型的数据或信息</p>
<p><strong>如何在使用编写爬虫的过程中避免进入局子的厄运呢</strong>？<br>    - 时常的优化自己的程序，避免干扰被访问网站的正常运行<br>        - 在使用，传播爬取到的数据时，审查抓取到的内容，如果发现了涉及到用户隐私<br>        商业机密等敏感内容需要及时停止爬取或传播</p>
<p><strong>爬虫在使用场景中的分类</strong></p>
<ul>
<li><p>通用爬虫：<br>抓取系统重要组成部分。抓取的是一整张页面数据。</p>
</li>
<li><p> 聚焦爬虫：</p>
</li>
</ul>
<p>  是建立在通用爬虫的基础之上。抓取的是页面中特定的局部内容。</p>
<ul>
<li>增量式爬虫：<br>检测网站中数据更新的情况。只会抓取网站中最新更新出来的数据。</li>
</ul>
<p><strong>爬虫的矛与盾</strong></p>
<p><strong>反爬机制</strong><br>    门户网站，可以通过制定相应的策略或者技术手段，防止爬虫程序进行网站数据的爬取。</p>
<p><strong>反反爬策略</strong><br>    爬虫程序可以通过制定相关的策略或者技术手段，破解门户网站中具备的反爬机制，从而可以获取门户网站中相关的数据。</p>
<p><strong>robots.txt</strong>协议：<br>    君子协议。规定了网站中哪些数据可以被爬虫爬取哪些数据不可以被爬取。</p>
<h3 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a><strong>http</strong>协议</h3><ul>
<li><p>概念：就是<code>服务器</code>和<code>客户端</code>进行数据交互的一种形式。</p>
</li>
<li><p><strong>常用请求头信息</strong></p>
<ul>
<li>User-Agent：请求载体的身份标识</li>
<li>Connection：请求完毕后，是断开连接还是保持连接</li>
</ul>
</li>
<li><p><strong>常用响应头信息</strong></p>
<ul>
<li>Content-Type：服务器响应回客户端的数据类型</li>
</ul>
</li>
</ul>
<p><strong>https</strong>协议：</p>
<pre><code>- 安全的超文本传输协议
</code></pre>
<p><strong>加密方式</strong></p>
<ul>
<li>对称秘钥加密<pre><code>  - 可能被第三方拦截
</code></pre>
</li>
<li>非对称秘钥加密<pre><code>  - 速度慢
  - 公钥可能被篡改
</code></pre>
</li>
<li>证书秘钥加密<pre><code>  - 给公钥数字签名
</code></pre>
</li>
</ul>
<h2 id="二、requests模块"><a href="#二、requests模块" class="headerlink" title="二、requests模块"></a>二、requests模块</h2><ul>
<li>网络请求模块<ul>
<li>urllib模块</li>
<li><strong>requests模块</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>requests模块：python中原生的一款基于网络请求的模块，功能非常强大，简单便捷，效率极高。</p>
<p>作用：<strong>模拟浏览器发请求</strong>。</p>
</blockquote>
<h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><blockquote>
<p>requests模块的编码流程</p>
</blockquote>
<ul>
<li>指定url<ul>
<li>UA伪装</li>
<li>请求参数的处理</li>
</ul>
</li>
<li>发起请求<ul>
<li>获取响应数据</li>
</ul>
</li>
<li>持久化存储</li>
</ul>
<h4 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h4><p> <code>pip install requests</code></p>
<h4 id="实战编码"><a href="#实战编码" class="headerlink" title="实战编码"></a>实战编码</h4><ul>
<li>需求：爬取搜狗首页的页面数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># - 需求：爬取搜狗首页的页面数据</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># step_1:指定url</span></span><br><span class="line">    url = <span class="string">&#x27;https://www.sogou.com/&#x27;</span></span><br><span class="line">    <span class="comment"># step_2:发起请求</span></span><br><span class="line">    <span class="comment"># get方法会返回一个响应对象</span></span><br><span class="line">    response = requests.get(url=url)</span><br><span class="line">    <span class="comment"># step_3:获取响应数据.text返回的是字符串形式的响应数据</span></span><br><span class="line">    page_text = response.text</span><br><span class="line">    <span class="built_in">print</span>(page_text)</span><br><span class="line">    <span class="comment"># step_4:持久化存储</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./sogou.html&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(page_text)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;爬取数据结束！！！&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="实战巩固"><a href="#实战巩固" class="headerlink" title="实战巩固"></a>实战巩固</h4><ul>
<li><p>需求：爬取搜狗指定词条对应的搜索结果页面（简易网页采集器）</p>
<ul>
<li><p><strong>UA检测</strong></p>
<blockquote>
<p>UA：User-Agent（请求载体的身份标识）.</p>
<p>门户网站的服务器会检测对应请求的载体身份标识，如果检测到请求的载体身份标识为某一款浏览器，说明该请求是一个正常的请求。但是，如果检测到请求的载体身份标识不是基于某一款浏览器的，则表示该请求为不正常的请求（爬虫），则服务器端就很有可能拒绝该次请求。</p>
</blockquote>
</li>
<li><p><strong>UA伪装</strong>: 将对应的User-Agent封装到一个字典中</p>
<blockquote>
<p>让爬虫对应的请求载体身份标识伪装成某一款浏览器</p>
</blockquote>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>需求：破解百度翻译(获取翻译结果)</p>
<ul>
<li>post请求（携带了参数）</li>
<li>响应数据是一组json数据</li>
</ul>
</li>
<li><p>需求：爬取豆瓣电影分类排行榜 <a href="https://movie.douban.com/%E4%B8%AD%E7%9A%84%E7%94%B5%E5%BD%B1%E8%AF%A6%E6%83%85%E6%95%B0%E6%8D%AE">https://movie.douban.com/中的电影详情数据</a></p>
</li>
<li><p>作业：爬取肯德基餐厅查询<a href="http://www.kfc.com.cn/kfccda/index.aspx%E4%B8%AD%E6%8C%87%E5%AE%9A%E5%9C%B0%E7%82%B9%E7%9A%84%E9%A4%90%E5%8E%85%E6%95%B0%E6%8D%AE">http://www.kfc.com.cn/kfccda/index.aspx中指定地点的餐厅数据</a></p>
</li>
<li><p>需求：爬取国家药品监督管理总局中基于中华人民共和国化妆品生产许可证相关数据</p>
<pre><code>      http://scxk.nmpa.gov.cn:81/xk/
  
</code></pre>
<ul>
<li>动态加载数据</li>
</ul>
</li>
<li><p>首页中对应的企业信息数据是通过ajax动态请求到的。</p>
<pre><code>http://125.35.6.84:81/xk/itownet/portal/dzpz.jsp?id=e6c1aa332b274282b04659a6ea30430a
http://125.35.6.84:81/xk/itownet/portal/dzpz.jsp?id=f63f61fe04684c46a016a45eac8754fe
</code></pre>
<ul>
<li>通过对详情页url的观察发现：<ul>
<li>url的域名都是一样的，只有携带的参数（id）不一样</li>
<li>id值可以从首页对应的ajax请求到的json串中获取</li>
<li>域名和id值拼接处一个完整的企业对应的详情页的url</li>
</ul>
</li>
<li>详情页的企业详情数据也是动态加载出来的<ul>
<li><a href="http://125.35.6.84:81/xk/itownet/portalAction.do?method=getXkzsById">http://125.35.6.84:81/xk/itownet/portalAction.do?method=getXkzsById</a></li>
<li><a href="http://125.35.6.84:81/xk/itownet/portalAction.do?method=getXkzsById">http://125.35.6.84:81/xk/itownet/portalAction.do?method=getXkzsById</a></li>
<li>观察后发现：<ul>
<li>所有的post请求的url都是一样的，只有参数id值是不同。</li>
<li>如果我们可以批量获取多家企业的id后，就可以将id和url形成一个完整的详情页对应详情数据的ajax请求的url</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="三、数据解析"><a href="#三、数据解析" class="headerlink" title="三、数据解析"></a>三、数据解析</h2><blockquote>
<p>聚焦爬虫、正则、bs4、xpath</p>
</blockquote>
<h4 id="聚焦爬虫"><a href="#聚焦爬虫" class="headerlink" title="聚焦爬虫"></a>聚焦爬虫</h4><p>定义：爬取页面中指定的页面内容。</p>
<p>编码流程：</p>
<ul>
<li>指定url</li>
<li>发起请求</li>
<li>获取响应数据</li>
<li>数据解析</li>
<li>持久化存储</li>
</ul>
<h4 id="数据解析分类"><a href="#数据解析分类" class="headerlink" title="数据解析分类"></a>数据解析分类</h4><ul>
<li>正则</li>
<li>bs4</li>
<li>xpath（***）</li>
</ul>
<p><strong>数据解析原理概述</strong></p>
<ul>
<li>解析的局部的文本内容都会在<strong>标签之间或者标签对应的属性中进行存储</strong></li>
<li>1.<strong>进行指定标签的定位</strong></li>
<li>2.标签或者标签对应的<strong>属性</strong>中存储的<strong>数据</strong>值进行<strong>提取（解析）</strong></li>
</ul>
<h5 id="正则解析"><a href="#正则解析" class="headerlink" title="正则解析"></a><strong>正则解析</strong></h5><p>回顾</p>
<p><img src="C:\Users\86136\Pictures\学习\rep.png" alt="正则表达式"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#提取出python</span></span><br><span class="line">key=<span class="string">&quot;javapythonc++php&quot;</span></span><br><span class="line">re.findall(<span class="string">&#x27;python&#x27;</span>,key)[<span class="number">0</span>]</span><br><span class="line"><span class="comment">########################################################</span></span><br><span class="line"><span class="comment">#提取出hello world</span></span><br><span class="line">key=<span class="string">&quot;</span></span><br><span class="line"><span class="string">hello world</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line">re.findall(<span class="string">&#x27;</span></span><br><span class="line"><span class="string">(.*)</span></span><br><span class="line"><span class="string">&#x27;</span>,key)[<span class="number">0</span>]</span><br><span class="line"><span class="comment">########################################################</span></span><br><span class="line"><span class="comment">#提取170</span></span><br><span class="line">string = <span class="string">&#x27;我喜欢身高为170的女孩&#x27;</span></span><br><span class="line">re.findall(<span class="string">&#x27;\d+&#x27;</span>,string)</span><br><span class="line"><span class="comment">########################################################</span></span><br><span class="line"><span class="comment">#提取出http://和https://</span></span><br><span class="line">key=<span class="string">&#x27;http://www.baidu.com and https://boob.com&#x27;</span></span><br><span class="line">re.findall(<span class="string">&#x27;https?://&#x27;</span>,key)</span><br><span class="line"><span class="comment">########################################################</span></span><br><span class="line"><span class="comment">#提取出hello</span></span><br><span class="line">key=<span class="string">&#x27;lalalahellohahah&#x27;</span> <span class="comment">#输出hello</span></span><br><span class="line">re.findall(<span class="string">&#x27;&lt;[Hh][Tt][mM][lL]&gt;(.*)&#x27;</span>,key)</span><br><span class="line"><span class="comment">########################################################</span></span><br><span class="line"><span class="comment">#提取出hit. </span></span><br><span class="line">key=<span class="string">&#x27;bobo@hit.edu.com&#x27;</span><span class="comment">#想要匹配到hit.</span></span><br><span class="line">re.findall(<span class="string">&#x27;h.*?\.&#x27;</span>,key)</span><br><span class="line"><span class="comment">########################################################</span></span><br><span class="line"><span class="comment">#匹配sas和saas</span></span><br><span class="line">key=<span class="string">&#x27;saas and sas and saaas&#x27;</span></span><br><span class="line">re.findall(<span class="string">&#x27;sa&#123;1,2&#125;s&#x27;</span>,key)</span><br></pre></td></tr></table></figure>



<h5 id="bs4进行数据解析"><a href="#bs4进行数据解析" class="headerlink" title="bs4进行数据解析"></a><strong>bs4进行数据解析</strong></h5><pre><code>- 数据解析的原理：
    - 1.标签定位
    - 2.提取标签、标签属性中存储的数据值
</code></pre>
<ul>
<li>bs4数据解析的原理：<ul>
<li>1.实例化一个BeautifulSoup对象，并且将页面源码数据加载到该对象中</li>
<li>2.通过调用BeautifulSoup对象中相关的属性或者方法进行标签定位和数据提取</li>
</ul>
</li>
<li>环境安装：<ul>
<li><code>pip install bs4</code></li>
<li><code>pip install lxml</code></li>
</ul>
</li>
<li>如何实例化BeautifulSoup对象：<ul>
<li><code>from bs4 import BeautifulSoup</code></li>
<li>对象的实例化：<ul>
<li>1.将本地的html文档中的数据加载到该对象中<pre><code>  `fp = open(&#39;./test.html&#39;,&#39;r&#39;,encoding=&#39;utf-8&#39;)`
 ` soup = BeautifulSoup(fp,&#39;lxml&#39;)`
</code></pre>
</li>
<li>2.将互联网上获取的页面源码加载到该对象中<pre><code>  `page_text = response.text`
</code></pre>
  <code> soup = BeatifulSoup(page_text,&#39;lxml&#39;)</code></li>
</ul>
</li>
<li>提供的用于数据解析的方法和属性：<ul>
<li><code>soup.tagName</code>:返回的是文档中第一次出现的tagName对应的标签</li>
<li><code>soup.find()</code>:<ul>
<li><code>find(&#39;tagName&#39;)</code>:等同于<code>soup.div</code></li>
<li>属性定位：<br>  <code>soup.find(&#39;div&#39;,class_/id/attr=&#39;song&#39;)</code></li>
</ul>
</li>
<li><code>soup.find_all(&#39;tagName&#39;)</code>:返回符合要求的所有标签（列表）</li>
</ul>
</li>
<li><code>select</code>：<ul>
<li>select(‘某种选择器（id，class，标签…选择器）’),返回的是一个列表。</li>
<li>层级选择器：<ul>
<li><code>soup.select(&#39;.tang &gt; ul &gt; li &gt; a&#39;)</code>：&gt;表示的是一个层级</li>
<li><code>oup.select(&#39;.tang &gt; ul a&#39;)</code>：空格表示的多个层级</li>
</ul>
</li>
</ul>
</li>
<li>获取标签之间的文本数据：<ul>
<li>soup.a.text/string/get_text()</li>
<li>text/get_text():可以获取某一个标签中所有的文本内容</li>
<li>string：只可以获取该标签下面直系的文本内容</li>
</ul>
</li>
<li>获取标签中属性值：<ul>
<li>soup.a[‘href’]</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="xpath解析"><a href="#xpath解析" class="headerlink" title="xpath解析"></a>xpath解析</h5><blockquote>
<p>最常用且最便捷高效的一种解析方式。通用性。</p>
</blockquote>
<ul>
<li>xpath解析原理：<ul>
<li>1.实例化一个etree的对象，且需要将被解析的页面源码数据加载到该对象中。</li>
<li>2.调用etree对象中的xpath方法结合着xpath表达式实现标签的定位和内容的捕获。</li>
</ul>
</li>
<li>环境的安装：<ul>
<li>pip install lxml</li>
</ul>
</li>
<li>如何实例化一个etree对象:from lxml import etree<ul>
<li>1.将<strong>本地</strong>的html文档中的源码数据加载到etree对象中：<br>  etree.parse(filePath)</li>
<li>2.可以将从<strong>互联网</strong>上获取的源码数据加载到该对象中<br>  etree.HTML(‘page_text’)</li>
<li>xpath(‘xpath表达式’)</li>
</ul>
</li>
<li>xpath表达式:<ul>
<li><strong>/</strong>: 表示的是从根节点开始定位。表示的是一个层级。</li>
<li><strong>//</strong>: 表示的是多个层级。可以表示从任意位置开始定位。</li>
<li><strong>属性定位</strong>：//div[@class=’song’] tag[@attrName=”attrValue”]</li>
<li><strong>索引定位</strong>：//div[@class=”song”]/p[3] 索引是从1开始的。</li>
<li><strong>取文本</strong>：<ul>
<li>/text() 获取的是标签中直系的文本内容</li>
<li>//text() 标签中非直系的文本内容（所有的文本内容）</li>
</ul>
</li>
<li><strong>取属性</strong>：<br>  /@attrName     ==&gt;img/src</li>
</ul>
</li>
</ul>
<p>作业：<br>    爬取站长素材中免费简历模板</p>
<h2 id="四、验证码识别"><a href="#四、验证码识别" class="headerlink" title="四、验证码识别"></a>四、验证码识别</h2><h5 id="验证码和爬虫之间的关系"><a href="#验证码和爬虫之间的关系" class="headerlink" title="验证码和爬虫之间的关系"></a>验证码和爬虫之间的关系</h5><ul>
<li>反爬机制：验证码.识别验证码图片中的数据，用于模拟登陆操作。</li>
</ul>
<h5 id="识别验证码的操作"><a href="#识别验证码的操作" class="headerlink" title="识别验证码的操作"></a>识别验证码的操作</h5><pre><code>- 人工肉眼识别。（不推荐）
    - 第三方自动识别（推荐）
    - 云打码：http://www.yundama.com/demo.html
</code></pre>
<ul>
<li>云打码的使用流程：<ul>
<li>注册：普通和开发者用户</li>
<li>登录：<ul>
<li>普通用户的登录：查询该用户是否还有剩余的题分</li>
<li>开发者用户的登录：<ul>
<li>创建一个软件：我的软件-》添加新软件-》录入软件名称-》提交（软件id和秘钥）</li>
<li>下载示例代码：开发文档-》点此下载：云打码接口DLL-》PythonHTTP示例下载</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="实战：识别古诗文网登录页面中的验证码"><a href="#实战：识别古诗文网登录页面中的验证码" class="headerlink" title="实战：识别古诗文网登录页面中的验证码"></a>实战：识别古诗文网登录页面中的验证码</h5><p>使用打码平台识别验证码的编码流程：</p>
<ul>
<li>将验证码图片进行本地下载</li>
<li>调用平台提供的示例代码进行图片数据识别</li>
</ul>
<h2 id="五、request高级"><a href="#五、request高级" class="headerlink" title="五、request高级"></a>五、request高级</h2><h4 id="模拟登录"><a href="#模拟登录" class="headerlink" title="模拟登录"></a>模拟登录</h4><ul>
<li>爬取基于某些用户的用户信息。</li>
</ul>
<h4 id="需求1"><a href="#需求1" class="headerlink" title="需求1"></a>需求1</h4><blockquote>
<p>对人人网进行模拟登录。</p>
</blockquote>
<ul>
<li>点击登录按钮之后会发起一个post请求</li>
<li>post请求中会携带登录之前录入的相关的登录信息（用户名，密码，验证码……）</li>
<li>验证码：每次请求都会变化</li>
</ul>
<h4 id="需求2"><a href="#需求2" class="headerlink" title="需求2"></a>需求2</h4><blockquote>
<p>爬取当前用户的相关的用户信息（个人主页中显示的用户信息）</p>
</blockquote>
<h4 id="cookie与session"><a href="#cookie与session" class="headerlink" title="cookie与session"></a>cookie与session</h4><p>http/https协议特性：无状态。<br>没有请求到对应页面数据的原因：<br>    发起的第二次基于个人主页页面请求的时候，服务器端并不知道该此请求是基于登录状态下的请求。<br>cookie：用来让服务器端记录客户端的相关状态。</p>
<ul>
<li>手动处理：通过抓包工具获取cookie值，将该值封装到headers中。（不建议）</li>
<li>自动处理：<ul>
<li>cookie值的来源是哪里？<ul>
<li>模拟登录post请求后，由服务器端创建。</li>
</ul>
</li>
<li><strong>session会话对象</strong>：<ul>
<li>作用：<br>  1.可以进行请求的发送。<br>  2.如果请求过程中产生了cookie，则该cookie会被自动存储/携带在该session对象中。</li>
</ul>
</li>
<li>创建一个session对象：session = requests.Session()</li>
<li>使用session对象进行模拟登录post请求的发送（cookie就会被存储在session中）</li>
<li>session对象对个人主页对应的get请求进行发送（携带了cookie）</li>
</ul>
</li>
</ul>
<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><blockquote>
<p>破解封IP这种反爬机制。</p>
</blockquote>
<p>什么是代理：</p>
<ul>
<li>代理服务器。</li>
</ul>
<p>代理的作用：</p>
<ul>
<li>突破自身IP访问的限制。</li>
<li>隐藏自身真实IP</li>
</ul>
<p>代理相关的网站：</p>
<ul>
<li>快代理</li>
<li>西祠代理</li>
<li><a href="http://www.goubanjia.com/">www.goubanjia.com</a></li>
</ul>
<p>代理ip的类型：</p>
<ul>
<li>http：应用到http协议对应的url中</li>
<li>https：应用到https协议对应的url中</li>
</ul>
<p>代理ip的匿名度：</p>
<ul>
<li>透明：服务器知道该次请求使用了代理，也知道请求对应的真实ip</li>
<li>匿名：知道使用了代理，不知道真实ip</li>
<li>高匿：不知道使用了代理，更不知道真实的ip</li>
</ul>
<h2 id="六、异步爬虫"><a href="#六、异步爬虫" class="headerlink" title="六、异步爬虫"></a>六、异步爬虫</h2><p>目的：在爬虫中使用异步实现高性能的数据爬取操作。</p>
<p>异步爬虫的方式：<br>    - 1.多线程，多进程（不建议）：<br>            好处：可以为相关阻塞的操作单独开启线程或者进程，阻塞操作就可以异步执行。<br>            弊端：无法无限制的开启多线程或者多进程。<br>    - 2.线程池、进程池（适当的使用）：<br>    好处：我们可以降低系统对进程或者线程创建和销毁的一个频率，从而很好的降低系统的开销。<br>    弊端：池中线程或进程的数量是有上限。</p>
<ul>
<li><p>3.单线程+异步协程（推荐）：<br>  <strong>event_loop</strong>：事件循环，相当于一个无限循环，我们可以把一些函数注册到这个事件循环上，<br>  当满足某些条件的时候，函数就会被循环执行。</p>
<p>  <strong>coroutine</strong>：协程对象，我们可以将协程对象注册到事件循环中，它会被事件循环调用。<br>  我们可以使用 async 关键字来定义一个方法，这个方法在调用时不会立即被执行，而是返回<br>  一个协程对象。</p>
<p>  <strong>task</strong>：任务，它是对协程对象的进一步封装，包含了任务的各个状态。</p>
<p>  <strong>future</strong>：代表将来执行或还没有执行的任务，实际上和 task 没有本质区别。</p>
<p>  <strong>async</strong> 定义一个协程.</p>
<p>  await 用来挂起阻塞方法的执行。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>code</category>
        <category>backend</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>小舍免费图片Api</title>
    <url>/2021/07/21/xiaoshesapi/</url>
    <content><![CDATA[<blockquote>
<p>项目名称：小舍图片Api接口</p>
</blockquote>
<!--<div style="display:flex;overflow:hidden;">
    <img width="100px" src="http://api.aoau.top:9999/photos/3/%20%2834%29.png"/>
    <img width="100px" src="http://api.aoau.top:9999/photos/3/%20%2855%29.png"/>
    <img width="100px" src="http://api.aoau.top:9999/photos/6/%20%2855%29.jpg"/>
    <img width="100px" src="http://api.aoau.top:9999/photos/6/%20%2859%29.jpg"/>
    <img width="100px" src="http://api.aoau.top:9999/photos/6/%20%2865%29.jpg"/>
    <img width="100px" src="http://api.aoau.top:9999/photos/3/%20%2812%29.png"/>
    <img width="100px" src="http://api.aoau.top:9999/photos/1/%20%2845%29.png"/>
</div>-->








<span id="more"></span>

<blockquote>
<p>开发人员：熙子黒</p>
<p>开源协议：MIT</p>
<p>感谢你的使用，如果喜欢请给仓库点个star：<a href="https://github.com/bai-23/photosapi">https://github.com/bai-23/photosapi</a></p>
<p>此接口已接入本人项目(小舍社交app)，请放心食用：<a href="https://github.com/bai-23/italk-uniapp">https://github.com/bai-23/italk-uniapp</a></p>
<p>注意：<strong>个人接口，请勿商用。图片收集不易，请珍惜食用。部分图片较大加载缓慢，请耐心等待。</strong></p>
</blockquote>
<h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><p>地址：<code>http://api.aoau.top</code></p>
<p>方法：<code>GET</code></p>
<table>
<thead>
<tr>
<th>url</th>
<th>参数</th>
<th>值</th>
<th>必须</th>
</tr>
</thead>
<tbody><tr>
<td>/photos/api</td>
<td>page</td>
<td>number</td>
<td>是</td>
</tr>
</tbody></table>
<h3 id="ajax请求示例"><a href="#ajax请求示例" class="headerlink" title="ajax请求示例"></a>ajax请求示例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">fetchPhotos</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="built_in">this</span>.$http.get(<span class="string">&#x27;http://api.aoau.top/photos/api?page=9&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>示例url：<code>http://api.aoau.top/photos/api?page=9</code></p>
<p>返回值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res:&#123;</span><br><span class="line">    <span class="string">&quot;status&quot;</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="string">&quot;msg&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;photoNum&quot;</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="string">&quot;category&quot;</span>: <span class="string">&quot;写真4&quot;</span>,</span><br><span class="line">        <span class="string">&quot;author&quot;</span>: <span class="string">&quot;收集不易，请珍惜接口，更多资源请访问Github:https://github.com/bai-23/photosapi&quot;</span>,</span><br><span class="line">        <span class="string">&quot;photoList&quot;</span>: [</span><br><span class="line">            xxx.jpg</span><br><span class="line">            ...</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;tips&quot;</span>: <span class="string">&quot;部分图片较大，加载速度较慢，请谅解。图片来源于互联网，仅供个人使用，请勿商用！&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：参数page范围为：1~14，请填写正确。</p>
<p>（建议线路5~14，每条线路有100张图片）</p>
</blockquote>
<hr>
<p>下面是测试，其他线路请自行尝试<br><a href="http://api.aoau.top:9999/photos/1/%20%2816%29.png">线路1</a><br><a href="http://api.aoau.top:9999/photos/2/%20%2819%29.png">线路2</a><br><a href="http://api.aoau.top:9999/photos/3/%20%2834%29.png">线路3</a><br><a href="http://api.aoau.top:9999/photos/4/%20%2883%29.png">线路4</a><br><a href="http://api.aoau.top:9999/photos/8/%20%2830%29.jpg">线路8</a><br><a href="http://api.aoau.top:9999/photos/14/%20%2860%29.jpg">线路14</a></p>
<p>成品：<a href="http://aoau.top:3004/courses/ps">http://aoau.top:3004/courses/ps</a></p>
]]></content>
      <categories>
        <category>apis</category>
        <category>图片api</category>
      </categories>
      <tags>
        <tag>图片Api</tag>
        <tag>NodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title>xpath解析58二手房的房源信息【★★】</title>
    <url>/2021/07/23/xpath%E8%A7%A3%E6%9E%9058%E4%BA%8C%E6%89%8B%E6%88%BF%E7%9A%84%E6%88%BF%E6%BA%90%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p>复习：<a href="https://www.runoob.com/xpath/xpath-syntax.html">XPath语法</a></p>
<p>需求：爬取58二手房中的房源信息</p>
<span id="more"></span>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="comment"># 需求：爬取58二手房中的房源信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 爬取到页面源码数据</span></span><br><span class="line">    url = <span class="string">&#x27;https://bj.58.com/ershoufang/&#x27;</span></span><br><span class="line">    page_text = requests.get(url=url, headers=headers).text</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 数据解析</span></span><br><span class="line">    tree = etree.HTML(page_text)</span><br><span class="line">    <span class="comment"># 存储的就是li标签对象</span></span><br><span class="line">    div_list = tree.xpath(<span class="string">&#x27;//section[@class=&quot;list&quot;]//h3/text()&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(div_list)</span><br><span class="line">    fp = <span class="built_in">open</span>(<span class="string">&#x27;58.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> div_list:</span><br><span class="line">        fp.write(item + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>code</category>
        <category>backend</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>xpath解析爬取全国城市名称【★★】</title>
    <url>/2021/07/23/xpath%E8%A7%A3%E6%9E%90%E7%88%AC%E5%8F%96%E5%85%A8%E5%9B%BD%E5%9F%8E%E5%B8%82%E5%90%8D%E7%A7%B0/</url>
    <content><![CDATA[<p>复习：<a href="https://www.runoob.com/xpath/xpath-syntax.html">XPath语法</a></p>
<p>需求：解析出所有城市名称</p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目需求：解析出所有城市名称https://www.aqistudy.cn/historydata/</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    url = <span class="string">&#x27;https://www.aqistudy.cn/historydata/&#x27;</span></span><br><span class="line">    page_text = requests.get(url=url, headers=headers).text</span><br><span class="line"></span><br><span class="line">    tree = etree.HTML(page_text)</span><br><span class="line">    <span class="comment"># 解析到热门城市和所有城市对应的a标签</span></span><br><span class="line">    <span class="comment"># //div[@class=&quot;bottom&quot;]/ul/li/          热门城市a标签的层级关系</span></span><br><span class="line">    <span class="comment"># //div[@class=&quot;bottom&quot;]/ul/div[2]/li/a  全部城市a标签的层级关系</span></span><br><span class="line">    a_list = tree.xpath(<span class="string">&#x27;//div[@class=&quot;bottom&quot;]/ul/li/a | //div[@class=&quot;bottom&quot;]/ul/div[2]/li/a&#x27;</span>)</span><br><span class="line">    all_city_names = []</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> a_list:</span><br><span class="line">        city_name = a.xpath(<span class="string">&#x27;./text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        all_city_names.append(city_name)</span><br><span class="line">    <span class="built_in">print</span>(all_city_names, <span class="built_in">len</span>(all_city_names))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
        <category>backend</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>xpath解析爬取美女图片【★★】</title>
    <url>/2021/07/23/xpath%E8%A7%A3%E6%9E%90%E7%88%AC%E5%8F%96%E7%BE%8E%E5%A5%B3%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<p>复习：<a href="https://www.runoob.com/xpath/xpath-syntax.html">XPath语法</a></p>
<p>需求：解析下载图片数据</p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># 需求：解析下载图片数据 http://pic.netbian.com/4kmeinv/</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    url = <span class="string">&#x27;http://pic.netbian.com/4kmeinv/&#x27;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.get(url=url, headers=headers)</span><br><span class="line">    <span class="comment"># 手动设定响应数据的编码格式</span></span><br><span class="line">    <span class="comment"># response.encoding = &#x27;utf-8&#x27;</span></span><br><span class="line">    page_text = response.text</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 数据解析：src的属性值  alt属性</span></span><br><span class="line">    tree = etree.HTML(page_text)</span><br><span class="line">    li_list = tree.xpath(<span class="string">&#x27;//div[@class=&quot;slist&quot;]/ul/li&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个文件夹</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;./picLibs&#x27;</span>):</span><br><span class="line">        os.mkdir(<span class="string">&#x27;./picLibs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> li <span class="keyword">in</span> li_list:</span><br><span class="line">        img_src = <span class="string">&#x27;http://pic.netbian.com&#x27;</span>+li.xpath(<span class="string">&#x27;./a/img/@src&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        img_name = li.xpath(<span class="string">&#x27;./a/img/@alt&#x27;</span>)[<span class="number">0</span>]+<span class="string">&#x27;.jpg&#x27;</span></span><br><span class="line">        <span class="comment"># 通用处理中文乱码的解决方案</span></span><br><span class="line">        img_name = img_name.encode(<span class="string">&#x27;iso-8859-1&#x27;</span>).decode(<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(img_name,img_src)</span></span><br><span class="line">        <span class="comment"># 请求图片进行持久化存储</span></span><br><span class="line">        img_data = requests.get(url=img_src, headers=headers).content</span><br><span class="line">        img_path = <span class="string">&#x27;picLibs/&#x27;</span>+img_name</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(img_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            fp.write(img_data)</span><br><span class="line">            <span class="built_in">print</span>(img_name, <span class="string">&#x27;下载成功！！！&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
        <category>backend</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>【JavaScript 随笔】DOM事件之——拖拽的实现与简单优化</title>
    <url>/2021/07/21/%E3%80%90JavaScript%20%E9%9A%8F%E7%AC%94%E3%80%91DOM%E4%BA%8B%E4%BB%B6%E4%B9%8B%E2%80%94%E2%80%94%E6%8B%96%E6%8B%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h5 id="效果"><a href="#效果" class="headerlink" title="效果"></a><em>效果</em></h5><span id="more"></span>

<p><code>鼠标点击文档中任意元素拖拽至任意位置。</code></p>
<h5 id="思路与流程"><a href="#思路与流程" class="headerlink" title="思路与流程"></a><em>思路与流程</em></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">鼠标按下时，开始拖拽：onmousedown</span><br><span class="line">鼠标移动，元素被拖动：onmousemove</span><br><span class="line">鼠标松开，被拖拽元素固定：onmouseup</span><br></pre></td></tr></table></figure>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a><em>代码</em></h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-id">#box1</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: bisque;</span></span><br><span class="line"><span class="css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#box2</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">184</span>, <span class="number">127</span>, <span class="number">59</span>);</span></span><br><span class="line"><span class="css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">            <span class="attribute">left</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">top</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#img1</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">250px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//拖拽box1元素</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">/*流程</span></span></span><br><span class="line"><span class="comment"><span class="javascript">             *  1.当鼠标按下时，开始拖拽：onmousedown</span></span></span><br><span class="line"><span class="comment"><span class="javascript">             *  2.鼠标移动，元素被拖动：onmousemove</span></span></span><br><span class="line"><span class="comment"><span class="javascript">             *  3.鼠标松开，被拖拽元素固定：onmouseup</span></span></span><br><span class="line"><span class="comment"><span class="javascript">            */</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> box1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;box1&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> box2 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;box2&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> img = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;img1&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="comment">//开启box1</span></span></span><br><span class="line"><span class="javascript">            drag(box1);</span></span><br><span class="line"><span class="javascript">            drag(box2);</span></span><br><span class="line"><span class="javascript">            drag(img);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">//优化：3提前一个专门用来设置拖拽的函数</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//参数：obj</span></span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">drag</span>(<span class="params">obj</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//第一步</span></span></span><br><span class="line"><span class="javascript">                obj.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//设置box1捕获所有鼠标按下的事件</span></span></span><br><span class="line"><span class="javascript">                obj.setPointerCapture;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//优化 1</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">//div的偏移量 鼠标.clientX - 元素.offsetLeft</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">//div的偏移量 鼠标.clientY - 元素.offsetTop</span></span></span><br><span class="line"><span class="javascript">                event = event || <span class="built_in">window</span>.event;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> ol = event.clientX - obj.offsetLeft;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> ot = event.clientY - obj.offsetTop;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">                <span class="comment">//第二部</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    event = event || <span class="built_in">window</span>.event;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">//第三部</span></span></span><br><span class="line"><span class="javascript">                    <span class="comment">//获取鼠标坐标</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> left = event.clientX - ol;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> top = event.clientY - ot;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">//修改box1的位置</span></span></span><br><span class="line"><span class="javascript">                    obj.style.left = left+<span class="string">&#x27;px&#x27;</span>;</span></span><br><span class="line"><span class="javascript">                    obj.style.top = top+<span class="string">&#x27;px&#x27;</span>;</span></span><br><span class="line"><span class="javascript">                    obj.innerHTML = <span class="string">&#x27;x=&#x27;</span>+left+<span class="string">&#x27; y=&#x27;</span>+top;</span></span><br><span class="line"><span class="javascript">                &#125;;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.onmouseup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">//鼠标松开时，固定在当前位置</span></span></span><br><span class="line"><span class="javascript">                    <span class="comment">//取消onmousemove</span></span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.onmousemove = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">//取消onmouseup(一次性事件)</span></span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.onmouseup = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">//事件松开时，取消对事件的捕获</span></span></span><br><span class="line"><span class="javascript">                    obj.releasePointerCapture;</span></span><br><span class="line"><span class="javascript">                &#125;;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//优化 2</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./img/1.jpg&quot;</span> <span class="attr">id</span>=<span class="string">&quot;img1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a><em>优化</em></h5><ol>
<li><p>鼠标的偏移量</p>
<blockquote>
<p>初始代码的拖拽效果，会出现明显的偏移，即鼠标在移动时，偏离最初点击的位置，用户体验差。</p>
</blockquote>
<p><strong>解决方法</strong></p>
<blockquote>
<p>元素的偏移量 鼠标.clientX - 元素.offsetLeft<br>元素的偏移量 鼠标.clientY - 元素.offsetTop</p>
</blockquote>
</li>
<li><p>拖拽内容时，浏览器会默认去搜索引擎中搜索内容</p>
<p> <strong>解决方法1</strong></p>
<blockquote>
<p>return false (不兼容ie8及以下)</p>
</blockquote>
<p> <strong>解决方法2</strong></p>
<blockquote>
<p>setCapture()方法 (不支持Chrome)</p>
</blockquote>
<blockquote>
<p>setPointerCapture属性：鼠标单击时，捕获所有鼠标按下的事件。<br> releasePointerCapture属性：事件松开时，取消对事件的捕获</p>
</blockquote>
</li>
<li><p>提取该拖拽函数</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化：3提前一个专门用来设置拖拽的函数</span></span><br><span class="line"><span class="comment">//参数：obj</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drag</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//第一步</span></span><br><span class="line">    obj.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//设置box1捕获所有鼠标按下的事件</span></span><br><span class="line">    obj.setPointerCapture;</span><br><span class="line">    <span class="comment">//优化 1</span></span><br><span class="line">    <span class="comment">//div的偏移量 鼠标.clientX - 元素.offsetLeft</span></span><br><span class="line">    <span class="comment">//div的偏移量 鼠标.clientY - 元素.offsetTop</span></span><br><span class="line">    event = event || <span class="built_in">window</span>.event;</span><br><span class="line">    <span class="keyword">var</span> ol = event.clientX - obj.offsetLeft;</span><br><span class="line">    <span class="keyword">var</span> ot = event.clientY - obj.offsetTop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二部</span></span><br><span class="line">    <span class="built_in">document</span>.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        event = event || <span class="built_in">window</span>.event;</span><br><span class="line">        <span class="comment">//第三部</span></span><br><span class="line">        <span class="comment">//获取鼠标坐标</span></span><br><span class="line">        <span class="keyword">var</span> left = event.clientX - ol;</span><br><span class="line">        <span class="keyword">var</span> top = event.clientY - ot;</span><br><span class="line">        <span class="comment">//修改box1的位置</span></span><br><span class="line">        obj.style.left = left+<span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">        obj.style.top = top+<span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">        obj.innerHTML = <span class="string">&#x27;x=&#x27;</span>+left+<span class="string">&#x27; y=&#x27;</span>+top;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">document</span>.onmouseup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//鼠标松开时，固定在当前位置</span></span><br><span class="line">        <span class="comment">//取消onmousemove</span></span><br><span class="line">        <span class="built_in">document</span>.onmousemove = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//取消onmouseup(一次性事件)</span></span><br><span class="line">        <span class="built_in">document</span>.onmouseup = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//事件松开时，取消对事件的捕获</span></span><br><span class="line">        obj.releasePointerCapture;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//优化 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>code</category>
        <category>frontend</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>使用爬虫破解百度翻译【★★】</title>
    <url>/2021/07/23/%E4%BD%BF%E7%94%A8%E7%88%AC%E8%99%AB%E7%A0%B4%E8%A7%A3%E7%99%BE%E5%BA%A6%E7%BF%BB%E8%AF%91/</url>
    <content><![CDATA[<blockquote>
<p>携带post参数的爬虫</p>
</blockquote>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 1.指定url</span></span><br><span class="line">    post_url = <span class="string">&#x27;https://fanyi.baidu.com/sug&#x27;</span></span><br><span class="line">    <span class="comment"># 2.进行UA伪装</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 3.post请求参数处理（同get请求一致）</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;******************************************************&#x27;</span>)</span><br><span class="line">    word = <span class="built_in">input</span>(<span class="string">&#x27;请输入您要翻译的文本: &#x27;</span>)</span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&#x27;kw&#x27;</span>: word  <span class="comment"># 待翻译数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 4.请求发送</span></span><br><span class="line">    response = requests.post(url=post_url, data=data, headers=headers)</span><br><span class="line">    <span class="comment"># 5.获取响应数据:json()方法返回的是obj（如果确认响应数据是json类型的，才可以使用json（））</span></span><br><span class="line">    dic_obj = response.json()</span><br><span class="line">    <span class="built_in">print</span>(dic_obj)</span><br><span class="line">    <span class="comment"># 持久化存储</span></span><br><span class="line">    fileName = word + <span class="string">&#x27;.json&#x27;</span></span><br><span class="line">    fp = <span class="built_in">open</span>(fileName, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    json.dump(dic_obj, fp=fp, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;******************************************************&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
        <category>backend</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax跨域解决方案</title>
    <url>/2021/07/21/%E5%8A%A0%E8%BD%BD%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%87%BA%E7%8E%B0%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h5 id="本地-Ajax-跨域报错-Cross-origin-requests-are-only-supported-for-protocol-schemes-http-data-chrome-chrome-extension-chrome-untrusted-https"><a href="#本地-Ajax-跨域报错-Cross-origin-requests-are-only-supported-for-protocol-schemes-http-data-chrome-chrome-extension-chrome-untrusted-https" class="headerlink" title="本地 Ajax 跨域报错 Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, chrome-untrusted, https."></a>本地 Ajax 跨域报错 Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, chrome-untrusted, https.</h5><span id="more"></span>

<hr>
<p>当我们在做练习或者写 Demo 的时候，有访问本地文件的需求，当我们在加载的时候发现不能加载，会报如下错误： </p>
<p><img src="https://images.cnblogs.com/cnblogs_com/xzsj/1888303/o_210325085243filecross.png"></p>
<p>根据错误信息大概知道原因在于使用了 File 协议，应该使用它提示的 http, data, chrome, chrome-extension, chrome-untrusted, https 这些协议，可是只是做个练习，写些小 Demo，不至于自己去创建一个服务器，开个端口。那么应该如何解决这个问题呢？各位看官，往下看。</p>
<h2 id="1-换编辑器"><a href="#1-换编辑器" class="headerlink" title="1.换编辑器"></a>1.换编辑器</h2><hr>
<p>使用 webstorm 或是 visual studio 这种重量级 IDE 的同学，应该不会遇到这种问题，这类 IDE 都内置了 HTTP 服务器。<br>但是对于一些喜欢使用 VSCode，Sublime Text 这类轻量级编辑器的同学，我们继续往下看。</p>
<h2 id="2-安装Server插件"><a href="#2-安装Server插件" class="headerlink" title="2.安装Server插件"></a>2.安装Server插件</h2><hr>
<p>这里针对 VSCode 和 Sublime 分别安利一款插件。</p>
<h3 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h3><hr>
<p>Live Server 插件，这个插件功能十分强大，不止可以解决 ajax 不支持 file 协议的问题，还可以实现在编辑器里保存修改后，页面自动刷新的功能。具体使用方法在插件安装的地方有说明，用起来也十分简单。<br>安装完成之后，打开 html 文件后，点击右下角的 GoLive 即可。</p>
<h3 id="Sublime"><a href="#Sublime" class="headerlink" title="Sublime"></a>Sublime</h3><hr>
<p>SublimeServer 插件，安装完成之后，点击 Tools-&gt;SublimeServer-&gt;Start SublimeServer，启动服务器，然后在 html 文件中，注意是文件中点击右键，选择 View in SublimeServer 即可。<br>（注意一定要以文件夹的方式打开 html 文件所在目录，否则可能失效。）</p>
<h2 id="3-换浏览器"><a href="#3-换浏览器" class="headerlink" title="3.换浏览器"></a>3.换浏览器</h2><hr>
<p>火狐支持 file 协议，对 Chorme 没有什么执念的童鞋，可以换成火狐。</p>
<h2 id="4-配置Chrome浏览器支持file协议"><a href="#4-配置Chrome浏览器支持file协议" class="headerlink" title="4.配置Chrome浏览器支持file协议"></a>4.配置Chrome浏览器支持file协议</h2><hr>
<p>如果你是那种非常喜欢 Chrome 开发者工具的人，也可以尝试如下方式。</p>
<p>Windows：<br>设置 Chrome 的快捷方式属性，在“目标”后面加上–allow-file-access-from-files，注意前面有个空格，重新打开 Chrome 即可。</p>
<p>Mac：<br>打开终端，输入下面命令：open -a “Google Chrome” –args –disable-web-security 然后就可以屏蔽安全访问了[ –args：此参数可有可无]</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><hr>
<p>只是更改浏览器配置使之支持 file 协议，还是有很大的局限性的，建议最好采用前两种方式，配置 http 服务器才是长久之计。</p>
<p>如需前端指导、前端资料、Java 指导和 Java 资料的请联系本人，感谢您的支持。</p>
<blockquote>
<p>WECHAT：xzsj07<br>备注：加好友请注明来源。</p>
</blockquote>
]]></content>
      <categories>
        <category>code</category>
        <category>frontend</category>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>正则解析爬取分页多张图片【★★★】</title>
    <url>/2021/07/23/%E6%AD%A3%E5%88%99%E8%A7%A3%E6%9E%90%E7%88%AC%E5%8F%96%E5%88%86%E9%A1%B5%E5%A4%9A%E5%BC%A0%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<p>复习：<a href="https://www.runoob.com/python/python-reg-expressions.html">Python正则解析语法</a></p>
<p>需求：分页爬取糗事百科中糗图板块下所有的糗图图片</p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 需求：爬取糗事百科中糗图板块下所有的糗图图片</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36&#x27;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 创建一个文件夹，保存所有的图片</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;./img&#x27;</span>):</span><br><span class="line">        os.mkdir(<span class="string">&#x27;./img&#x27;</span>)</span><br><span class="line">    <span class="comment"># 设置一个通用的url模板</span></span><br><span class="line">    base_url = <span class="string">&#x27;https://www.qiushibaike.com/imgrank/page/%d/&#x27;</span></span><br><span class="line">    <span class="comment"># pageNum = 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> pageNum <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line">        <span class="comment"># 对应页码的url</span></span><br><span class="line">        new_url = <span class="built_in">format</span>(base_url % pageNum)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用通用爬虫对url对应的一整张页面进行爬取</span></span><br><span class="line">        page_text = requests.get(url=new_url, headers=headers).text</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用聚焦爬虫将页面中所有的糗图进行解析/提取</span></span><br><span class="line">        ex = <span class="string">&#x27;&lt;div class=&quot;thumb&quot;&gt;.*?&lt;img src=&quot;(.*?)&quot; alt.*?&lt;/div&gt;&#x27;</span></span><br><span class="line">        img_src_list = re.findall(ex, page_text, re.S)</span><br><span class="line">        <span class="comment"># print(img_src_list)</span></span><br><span class="line">        <span class="keyword">for</span> src <span class="keyword">in</span> img_src_list:</span><br><span class="line">            <span class="comment"># 拼接出一个完整的图片url</span></span><br><span class="line">            src = <span class="string">&#x27;https:&#x27;</span>+src</span><br><span class="line">            <span class="comment"># 请求到了图片的二进制数据</span></span><br><span class="line">            img_data = requests.get(url=src, headers=headers).content</span><br><span class="line">            <span class="comment"># 生成图片名称</span></span><br><span class="line">            img_name = src.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 图片存储的路径</span></span><br><span class="line">            imgPath = <span class="string">&#x27;./img/&#x27;</span>+img_name</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(imgPath, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">                fp.write(img_data)</span><br><span class="line">                <span class="built_in">print</span>(img_name, <span class="string">&#x27;下载成功！！！&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
        <category>backend</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>单张图片爬取【★】</title>
    <url>/2021/07/23/%E5%8D%95%E5%BC%A0%E5%9B%BE%E7%89%87%E7%88%AC%E5%8F%96/</url>
    <content><![CDATA[<blockquote>
<p>request请求返回类型区别：</p>
<ul>
<li>content返回的是二进制形式的图片数据</li>
<li>text（字符串） content（二进制）json() (对象)</li>
</ul>
</blockquote>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 爬取图片数据</span></span><br><span class="line">    url = <span class="string">&#x27;http://api.aoau.top:9999/photos/3/%20%2834%29.png&#x27;</span></span><br><span class="line">    <span class="comment"># content返回的是二进制形式的图片数据</span></span><br><span class="line">    <span class="comment"># text（字符串） content（二进制）json() (对象)</span></span><br><span class="line">    img_data = requests.get(url=url).content</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./tp.jpg&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(img_data)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
        <category>backend</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>正则解析爬取单页多张图片【★★】</title>
    <url>/2021/07/23/%E6%AD%A3%E5%88%99%E8%A7%A3%E6%9E%90%E7%88%AC%E5%8F%96%E5%8D%95%E9%A1%B5%E5%A4%9A%E5%BC%A0%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<p>复习：<a href="https://www.runoob.com/python/python-reg-expressions.html">Python正则解析语法</a></p>
<p>需求：爬取糗事百科中糗图板块下所有的糗图图片</p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re   <span class="comment"># 正则表达式模块</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需求：爬取糗事百科中糗图板块下所有的糗图图片</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 创建一个文件夹，保存所有的图片</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;./img&#x27;</span>):</span><br><span class="line">        os.mkdir(<span class="string">&#x27;./img&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># url = &#x27;https://www.qiushibaike.com/imgrank/&#x27;</span></span><br><span class="line">    url = <span class="string">&#x27;https://www.sitapix.com/search/%E5%B1%B1&#x27;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 使用通用爬虫对url对应的一整张页面进行爬取</span></span><br><span class="line">    page_text = requests.get(url=url, headers=headers).text</span><br><span class="line">    <span class="comment"># print(page_text)</span></span><br><span class="line">    <span class="comment"># 使用聚焦爬虫将页面中所有的糗图进行解析/提取</span></span><br><span class="line">    ex = <span class="string">&#x27;&lt;div class=&quot;thumb&quot;&gt;.*?&lt;img src=&quot;(.*?)&quot; alt.*?&lt;/div&gt;&#x27;</span></span><br><span class="line">    <span class="comment"># ex = &#x27;&lt;img src=&quot;(.*?)&quot; class.*?&gt;&#x27;</span></span><br><span class="line">    img_src_list = re.findall(ex, page_text, re.S)</span><br><span class="line">    <span class="comment"># print(img_src_list)</span></span><br><span class="line">    <span class="keyword">for</span> src <span class="keyword">in</span> img_src_list:</span><br><span class="line">        <span class="comment"># 拼接出一个完整的图片url</span></span><br><span class="line">        src = <span class="string">&#x27;https:&#x27;</span> + src</span><br><span class="line">        <span class="comment"># 请求到了图片的二进制数据</span></span><br><span class="line">        img_data = requests.get(url=src, headers=headers).content</span><br><span class="line">        <span class="comment"># 生成图片名称</span></span><br><span class="line">        img_name = src.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 图片存储的路径</span></span><br><span class="line">        imgPath = <span class="string">&#x27;./img/&#x27;</span> + img_name</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(imgPath, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            fp.write(img_data)</span><br><span class="line">            <span class="built_in">print</span>(img_name, <span class="string">&#x27;下载成功！！！&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
        <category>backend</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>爬取药监局相关数据【★★】</title>
    <url>/2021/07/23/%E7%88%AC%E5%8F%96%E8%8D%AF%E7%9B%91%E5%B1%80%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>携带post参数的爬虫</li>
<li>子链爬取</li>
</ul>
</blockquote>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id_list = []  <span class="comment"># 存储企业的id</span></span><br><span class="line">    all_data_list = []  <span class="comment"># 存储所有的企业详情数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1.批量获取不同企业的id值</span></span><br><span class="line">    url = <span class="string">&#x27;http://scxk.nmpa.gov.cn:81/xk/itownet/portalAction.do?method=getXkzsList&#x27;</span></span><br><span class="line">    <span class="comment"># 参数的封装</span></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">        <span class="comment"># 获取前5页所有企业数据</span></span><br><span class="line">        page = <span class="built_in">str</span>(page)</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">&#x27;on&#x27;</span>: <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;page&#x27;</span>: page,</span><br><span class="line">            <span class="string">&#x27;pageSize&#x27;</span>: <span class="string">&#x27;15&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;productName&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;conditionType&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;applyname&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;applysn&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        json_ids = requests.post(url=url, headers=headers, data=data).json()</span><br><span class="line">        <span class="keyword">for</span> dic <span class="keyword">in</span> json_ids[<span class="string">&#x27;list&#x27;</span>]:</span><br><span class="line">            <span class="comment"># 批量获取id保存到数组</span></span><br><span class="line">            id_list.append(dic[<span class="string">&#x27;ID&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2.获取企业详情数据</span></span><br><span class="line">    post_url = <span class="string">&#x27;http://scxk.nmpa.gov.cn:81/xk/itownet/portalAction.do?method=getXkzsById&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">id</span> <span class="keyword">in</span> id_list:</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">&#x27;id&#x27;</span>: <span class="built_in">id</span></span><br><span class="line">        &#125;</span><br><span class="line">        detail_json = requests.post(url=post_url, headers=headers, data=data).json()</span><br><span class="line">        <span class="built_in">print</span>(detail_json, <span class="string">&#x27;\n-------------ending-----------&#x27;</span>)</span><br><span class="line">        all_data_list.append(detail_json)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3.持久化存储all_data_list</span></span><br><span class="line">    fp = <span class="built_in">open</span>(<span class="string">&#x27;./allData.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    json.dump(all_data_list, fp=fp, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n\n****************************完毕***************************&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
        <category>backend</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>爬取搜狗页面【★】</title>
    <url>/2021/07/23/%E7%88%AC%E5%8F%96%E6%90%9C%E7%8B%97%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<p>复习：<a href="https://freepiao.cn/2021/07/21/spider/#%E4%BA%8C%E3%80%81requests%E6%A8%A1%E5%9D%97">request模块讲解</a></p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># - 需求：爬取搜狗首页的页面数据</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># step_1:指定url</span></span><br><span class="line">    url = <span class="string">&#x27;https://www.sogou.com/&#x27;</span></span><br><span class="line">    <span class="comment"># step_2:发起请求</span></span><br><span class="line">    <span class="comment"># get方法会返回一个响应对象</span></span><br><span class="line">    response = requests.get(url=url)</span><br><span class="line">    <span class="comment"># step_3:获取响应数据.text返回的是字符串形式的响应数据</span></span><br><span class="line">    page_text = response.text</span><br><span class="line">    <span class="built_in">print</span>(page_text)</span><br><span class="line">    <span class="comment"># step_4:持久化存储</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./sogou.html&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(page_text)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;#########CRAWLING END#########&#x27;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>code</category>
        <category>backend</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>爬取豆瓣电影详情【★★】</title>
    <url>/2021/07/23/%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1%E8%AF%A6%E6%83%85/</url>
    <content><![CDATA[<blockquote>
<p>携带post参数的爬虫</p>
</blockquote>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    url = <span class="string">&#x27;https://movie.douban.com/j/chart/top_list&#x27;</span></span><br><span class="line">    <span class="comment"># 参数：参考网页XHR请求中的Request URL字符串</span></span><br><span class="line">    param = &#123;</span><br><span class="line">        <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;24&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;interval_id&#x27;</span>: <span class="string">&#x27;100:90&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;action&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;start&#x27;</span>: <span class="string">&#x27;0&#x27;</span>,  <span class="comment"># 从库中的第几部电影去取</span></span><br><span class="line">        <span class="string">&#x27;limit&#x27;</span>: <span class="string">&#x27;20&#x27;</span>,  <span class="comment"># 一次取出的个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.get(url=url, params=param, headers=headers)</span><br><span class="line"></span><br><span class="line">    list_data = response.json()</span><br><span class="line"></span><br><span class="line">    fp = <span class="built_in">open</span>(<span class="string">&#x27;./douban.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    json.dump(list_data, fp=fp, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;********************************************************************&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
        <category>backend</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript学习笔记</title>
    <url>/2021/07/21/TypeScript/</url>
    <content><![CDATA[<blockquote>
<p>ts学习笔记</p>
</blockquote>
<span id="more"></span>

<h1 id="第一章-快速入门"><a href="#第一章-快速入门" class="headerlink" title="第一章 快速入门"></a>第一章 快速入门</h1><h2 id="0、TypeScript简介"><a href="#0、TypeScript简介" class="headerlink" title="0、TypeScript简介"></a>0、TypeScript简介</h2><ol>
<li><p>TypeScript是<strong>JavaScript的超集</strong>。</p>
</li>
<li><p>它对JS进行了扩展，向JS中引入了类型的概念，并添加了许多新的特性。</p>
</li>
<li><p>TS代码需要通过编译器编译为JS，然后再交由JS解析器执行。</p>
</li>
<li><p>TS完全兼容JS，换言之，任何的JS代码都可以直接当成JS使用。</p>
</li>
</ol>
<ul>
<li>相较于JS而言，TS拥有了静态类型，更加严格的语法，更强大的功能；</li>
<li>TS可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；</li>
<li>TS代码可以编译为任意版本的JS代码，可有效解决不同JS运行环境的兼容问题；</li>
<li>同样的功能，TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS。</li>
</ul>
<h2 id="1、TypeScript-开发环境搭建"><a href="#1、TypeScript-开发环境搭建" class="headerlink" title="1、TypeScript 开发环境搭建"></a>1、TypeScript 开发环境搭建</h2><ol>
<li><p>下载Node.js</p>
<ul>
<li>64位：<a href="https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi">https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi</a></li>
<li>32位：<a href="https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi">https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi</a></li>
</ul>
</li>
<li><p>安装Node.js</p>
</li>
<li><p>使用npm全局安装typescript</p>
<ul>
<li>进入命令行</li>
<li>输入：npm i -g typescript</li>
</ul>
</li>
<li><p>创建一个ts文件</p>
</li>
<li><p>使用tsc对ts文件进行<strong>编译</strong></p>
<ul>
<li><p>进入命令行</p>
</li>
<li><p>进入ts文件所在目录</p>
</li>
<li><p>执行命令：tsc xxx.ts</p>
</li>
</ul>
</li>
</ol>
<h2 id="2、基本类型"><a href="#2、基本类型" class="headerlink" title="2、基本类型"></a>2、基本类型</h2><ul>
<li><h4 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h4><ul>
<li><p>类型声明是TS非常重要的一个特点</p>
</li>
<li><p>通过类型声明可以指定TS中变量（参数、形参）的类型</p>
</li>
<li><p>指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错</p>
</li>
<li><p><strong>简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值</strong></p>
</li>
<li><p>语法：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> 变量: 类型;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> 变量: 类型 = 值;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">参数: 类型, 参数: 类型</span>): 类型</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h4 id="自动类型判断"><a href="#自动类型判断" class="headerlink" title="自动类型判断"></a>自动类型判断</h4><ul>
<li>TS拥有自动的类型判断机制</li>
<li><strong>当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型</strong></li>
<li>所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明</li>
</ul>
</li>
<li><h4 id="类型："><a href="#类型：" class="headerlink" title="类型："></a>类型：</h4><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">例子</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">number</td>
<td align="center">1, -33, 2.5</td>
<td align="center">任意数字</td>
</tr>
<tr>
<td align="center">string</td>
<td align="center">‘hi’, “hi”, <code>hi</code></td>
<td align="center">任意字符串</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">true、false</td>
<td align="center">布尔值true或false</td>
</tr>
<tr>
<td align="center">字面量</td>
<td align="center">其本身</td>
<td align="center">限制变量的值就是该字面量的值</td>
</tr>
<tr>
<td align="center">any</td>
<td align="center">*</td>
<td align="center">任意类型</td>
</tr>
<tr>
<td align="center">unknown</td>
<td align="center">*</td>
<td align="center">类型安全的any</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">空值（undefined）</td>
<td align="center">没有值（或undefined）</td>
</tr>
<tr>
<td align="center">never</td>
<td align="center">没有值</td>
<td align="center">不能是任何值</td>
</tr>
<tr>
<td align="center">object</td>
<td align="center">{name:’孙悟空’}</td>
<td align="center">任意的JS对象</td>
</tr>
<tr>
<td align="center">array</td>
<td align="center">[1,2,3]</td>
<td align="center">任意JS数组</td>
</tr>
<tr>
<td align="center">tuple</td>
<td align="center">[4,5]</td>
<td align="center">元素，TS新增类型，固定长度数组</td>
</tr>
<tr>
<td align="center">enum</td>
<td align="center">enum{A, B}</td>
<td align="center">枚举，TS中新增类型</td>
</tr>
</tbody></table>
</li>
<li><p>number</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> decimal: <span class="built_in">number</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> hex: <span class="built_in">number</span> = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="keyword">let</span> binary: <span class="built_in">number</span> = <span class="number">0b1010</span>;</span><br><span class="line"><span class="keyword">let</span> octal: <span class="built_in">number</span> = <span class="number">0o744</span>;</span><br><span class="line"><span class="keyword">let</span> big: bigint = <span class="number">100n</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>boolean</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>string</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> color: <span class="built_in">string</span> = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fullName: <span class="built_in">string</span> = <span class="string">`Bob Bobbington`</span>;</span><br><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="number">37</span>;</span><br><span class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123;fullName&#125;</span>.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I&#x27;ll be <span class="subst">$&#123;age + <span class="number">1</span>&#125;</span> years old next month.`</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>字面量</p>
<ul>
<li><p>也可以使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围</p>
</li>
<li><p>```typescript<br>let color: ‘red’ | ‘blue’ | ‘black’;<br>let num: 1 | 2 | 3 | 4 | 5;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- any</span><br><span class="line"></span><br><span class="line">  - 相当于关闭该变量的ts语法，开发时不建议使用</span><br><span class="line"></span><br><span class="line">  - ```typescript</span><br><span class="line">    let d: any = 4;</span><br><span class="line">    d = &#x27;hello&#x27;;</span><br><span class="line">    d = true;</span><br><span class="line">    </span><br><span class="line">    // 声明变量如果不指定类型，则TS解析器会自动判断变量的类型为any （隐式的any）</span><br><span class="line">    let d;</span><br><span class="line">    d = 10;</span><br><span class="line">    d = &#x27;hello&#x27;;</span><br><span class="line">    d = true;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>unknown</p>
<ul>
<li><p>区别any</p>
<ul>
<li>any，可以赋值给任意变量</li>
<li>unknown类型的变量，不能直接赋值给其他变量</li>
</ul>
</li>
<li><p>```typescript<br>let notSure: unknown = 4;<br>notSure = ‘hello’;<br>// unknown 实际上就是一个类型安全的any</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- void</span><br><span class="line"></span><br><span class="line">  ```typescript</span><br><span class="line">  let unusable: void = undefined;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>never</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>object（没啥用）</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj: <span class="built_in">object</span> = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.&#123;&#125; 用来指定对象中可以包含哪些属性// 语法：&#123;属性名:属性值,属性名:属性值&#125;// 在属性名后边加上?，表示属性是可选的let b: &#123;name: string, age?: number&#125;;b = &#123;name: &#x27;孙悟空&#x27;, age: 18&#125;;// 2.[propName: string]: any 表示任意类型的属性let c: &#123;name: string, [propName: string]: any&#125;;c = &#123;name: &#x27;猪八戒&#x27;, age: 18, gender: &#x27;男&#x27;&#125;;/**  3.设置函数结构的类型声明：*       语法：(形参:类型, 形参:类型 ...) =&gt; 返回值* */let d: (a: number ,b: number)=&gt;number;let d = function (n1: string, n2: string): number&#123;   return 10;&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>array</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**   数组的类型声明：*       类型[]*       Array&lt;类型&gt;* */</span><span class="keyword">let</span> list: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];<span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];<span class="comment">// string[] 表示字符串数组let e: string[];// number[] 表示数值数值let f: number[];let g: Array&lt;number&gt;;</span></span><br></pre></td></tr></table></figure></li>
<li><p>tuple</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**   元组，元组就是固定长度的数组*       语法：[类型, 类型, 类型]* */</span><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>];x = [<span class="string">&quot;hello&quot;</span>, <span class="number">10</span>]; </span><br></pre></td></tr></table></figure></li>
<li><p>enum</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//enum 枚举enum Color &#123;  Red,  Green,  Blue,&#125;let c: Color = Color.Green;enum Color &#123;  Red = 1,  Green,  Blue,&#125;let c: Color = Color.Green;enum Color &#123;  Red = 1,  Green = 2,  Blue = 4,&#125;let c: Color = Color.Green;// 补充let j: &#123; name: string &#125; &amp; &#123; age: number &#125;;// j = &#123;name: &#x27;孙悟空&#x27;, age: 18&#125;;</span></span><br></pre></td></tr></table></figure></li>
<li><p>类型别名</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> myType = <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span>;<span class="keyword">let</span> k: myType;<span class="keyword">let</span> l: myType;<span class="keyword">let</span> m: myType;k = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>类型断言</p>
<ul>
<li><p>有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，<strong>可以通过类型断言来告诉编译器变量的类型</strong>，类比强制转换。</p>
</li>
<li><p>断言有两种形式：</p>
<ul>
<li><p>第一种</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: unknown = <span class="string">&quot;this is a string&quot;</span>;<span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br></pre></td></tr></table></figure></li>
<li><p>第二种</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: unknown = <span class="string">&quot;this is a string&quot;</span>;<span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3、编译选项"><a href="#3、编译选项" class="headerlink" title="3、编译选项"></a>3、编译选项</h2><h3 id="自动编译文件"><a href="#自动编译文件" class="headerlink" title="自动编译文件"></a>自动编译文件</h3><ul>
<li><p>编译文件时，使用 <code>-w</code> 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。</p>
</li>
<li><p>示例：</p>
<ul>
<li><p>```powershell<br>tsc xxx.ts -w</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 自动编译整个项目</span><br><span class="line"></span><br><span class="line">- 如果直接使用**tsc**指令，则可以自动将当前项目下的所有ts文件编译为js文件。</span><br><span class="line">- 但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 **tsconfig.json**</span><br><span class="line">- tsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc 命令即可完成对整个项目的编译</span><br><span class="line"></span><br><span class="line">#### 配置选项</span><br><span class="line"></span><br><span class="line">##### **include**</span><br><span class="line"></span><br><span class="line">- 定义希望被编译文件所在的目录</span><br><span class="line"></span><br><span class="line">- 默认值：[&quot;\*\*/\*&quot;]</span><br><span class="line"></span><br><span class="line">- 示例：</span><br><span class="line"></span><br><span class="line">  ```json</span><br><span class="line">  &quot;include&quot;:[    &quot;src/**/*&quot;,     &quot;tests/**/*&quot;]// &quot;**&quot;表示任意目录，“*”表示任意文件</span><br></pre></td></tr></table></figure></li>
<li><p>上述示例中，所有src目录和tests目录下的文件都会被编译</p>
</li>
</ul>
</li>
</ul>
<h5 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a><strong>exclude</strong></h5><ul>
<li><p>定义需要排除在外的目录</p>
</li>
<li><p>默认值：[“node_modules”, “bower_components”, “jspm_packages”]</p>
</li>
<li><p>示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;exclude&quot;</span>: [<span class="string">&quot;./src/hello/**/*&quot;</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>上述示例中，src下hello目录下的文件都不会被编译</li>
</ul>
</li>
</ul>
<h5 id="extends"><a href="#extends" class="headerlink" title="extends"></a><strong>extends</strong></h5><ul>
<li><p>定义被继承的配置文件</p>
</li>
<li><p>示例：</p>
<ul>
<li><p>```json<br>“extends”: “./configs/base”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 上述示例中，当前配置文件中会自动包含config目录下**base.json**中的所有配置信息</span><br><span class="line"></span><br><span class="line">##### **files**</span><br><span class="line"></span><br><span class="line">- 指定被编译文件的列表，只有需要编译的文件少时才会用到</span><br><span class="line"></span><br><span class="line">- 示例：</span><br><span class="line"></span><br><span class="line">  - ```json</span><br><span class="line">    &quot;files&quot;: [    &quot;core.ts&quot;,    &quot;sys.ts&quot;,    &quot;types.ts&quot;,    &quot;scanner.ts&quot;,    &quot;parser.ts&quot;,    &quot;utilities.ts&quot;,    &quot;binder.ts&quot;,    &quot;checker.ts&quot;,    &quot;tsc.ts&quot;  ]</span><br></pre></td></tr></table></figure></li>
<li><p>列表中的文件都会被TS编译器所编译</p>
</li>
</ul>
</li>
</ul>
<h5 id="compilerOptions"><a href="#compilerOptions" class="headerlink" title="compilerOptions"></a><strong>compilerOptions</strong></h5><ul>
<li><p><strong>编译选项</strong>是配置文件中非常重要也比较复杂的配置选项</p>
</li>
<li><p>在compilerOptions中包含多个子选项，用来完成对编译的配置</p>
</li>
</ul>
<h6 id="项目选项"><a href="#项目选项" class="headerlink" title="项目选项"></a>项目选项</h6><ul>
<li><p><strong>target</strong></p>
<ul>
<li><p>设置ts代码编译的目标版本</p>
</li>
<li><p>可选值：</p>
<ul>
<li>ES3（默认）、ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;ES6&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>lib</strong></p>
<ul>
<li><p>指定代码运行时所包含的库（宿主环境）</p>
</li>
<li><p>可选值：</p>
<ul>
<li>ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ……</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;ES6&quot;</span>,    <span class="attr">&quot;lib&quot;</span>: [<span class="string">&quot;ES6&quot;</span>, <span class="string">&quot;DOM&quot;</span>],    <span class="attr">&quot;outDir&quot;</span>: <span class="string">&quot;dist&quot;</span>,    <span class="attr">&quot;outFile&quot;</span>: <span class="string">&quot;dist/aa.js&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>module</strong></p>
<ul>
<li><p>设置编译后代码使用的模块化系统</p>
</li>
<li><p>可选值：</p>
<ul>
<li>CommonJS、UMD、AMD、System、ES2020、ESNext、None</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;    <span class="string">&quot;module&quot;</span>: <span class="string">&quot;CommonJS&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>outDir</strong></p>
<ul>
<li><p>编译后文件的所在目录</p>
</li>
<li><p>默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置</p>
</li>
<li><p>示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;    <span class="attr">&quot;outDir&quot;</span>: <span class="string">&quot;dist&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置后编译后的js文件将会生成到dist目录</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>outFile</strong></p>
<ul>
<li><p>将所有的文件编译为一个js文件</p>
</li>
<li><p>默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中</p>
</li>
<li><p>示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;    <span class="attr">&quot;outFile&quot;</span>: <span class="string">&quot;dist/app.js&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>rootDir</strong></p>
<ul>
<li><p>指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录</p>
</li>
<li><p>示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;    <span class="attr">&quot;rootDir&quot;</span>: <span class="string">&quot;./src&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>allowJs</strong></p>
<ul>
<li>是否对js文件编译，默认是false</li>
</ul>
</li>
<li><p><strong>checkJs</strong></p>
<ul>
<li><p>是否检查js代码是否符合语法规范，默认是false</p>
</li>
<li><p>示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;    <span class="attr">&quot;allowJs&quot;</span>: <span class="literal">true</span>,    <span class="attr">&quot;checkJs&quot;</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>removeComments</strong></p>
<ul>
<li>是否删除注释</li>
<li>默认值：false</li>
</ul>
</li>
<li><p><strong>noEmit</strong></p>
<ul>
<li>不生成编译后的文件</li>
<li>默认值：false</li>
</ul>
</li>
<li><p><strong>sourceMap</strong></p>
<ul>
<li>是否生成sourceMap</li>
<li>默认值：false</li>
</ul>
</li>
<li><p><strong>noEmitOnError</strong></p>
<ul>
<li>当有错误时不生成编译后的文件</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>严格检查</strong></p>
</li>
<li><p>strict</p>
<ul>
<li>启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查</li>
<li>alwaysStrict<ul>
<li>总是以严格模式对代码进行编译</li>
</ul>
</li>
<li>noImplicitAny<ul>
<li>禁止隐式的any类型</li>
</ul>
</li>
<li>noImplicitThis<ul>
<li>禁止类型不明确的this</li>
</ul>
</li>
<li>strictBindCallApply<ul>
<li>严格检查bind、call和apply的参数列表</li>
</ul>
</li>
<li>strictFunctionTypes<ul>
<li>严格检查函数的类型</li>
</ul>
</li>
<li>strictNullChecks<ul>
<li>严格的空值检查</li>
</ul>
</li>
<li>strictPropertyInitialization<ul>
<li>严格检查属性是否初始化</li>
</ul>
</li>
</ul>
</li>
<li><p>额外检查</p>
<ul>
<li>noFallthroughCasesInSwitch<ul>
<li>检查switch语句包含正确的break</li>
</ul>
</li>
<li>noImplicitReturns<ul>
<li>检查函数没有隐式的返回值</li>
</ul>
</li>
<li>noUnusedLocals<ul>
<li>检查未使用的局部变量</li>
</ul>
</li>
<li>noUnusedParameters<ul>
<li>检查未使用的参数</li>
</ul>
</li>
</ul>
</li>
<li><p>高级</p>
<ul>
<li>allowUnreachableCode<ul>
<li>检查不可达代码</li>
<li>可选值：<ul>
<li>true，忽略不可达代码</li>
<li>false，不可达代码将引起错误</li>
</ul>
</li>
</ul>
</li>
<li>noEmitOnError<ul>
<li>有错误的情况下不进行编译</li>
<li>默认值：false</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4、webpack"><a href="#4、webpack" class="headerlink" title="4、webpack"></a>4、webpack</h2><ul>
<li><p>通常情况下，实际开发中我们都需要使用构建工具对代码进行打包，TS同样也可以结合构建工具一起使用，下边以webpack为例介绍一下如何结合构建工具使用TS。</p>
</li>
<li><p>步骤：</p>
<ol>
<li><p>初始化项目</p>
<ul>
<li>进入项目根目录，执行命令 <code> npm init -y</code><ul>
<li>主要作用：创建package.json文件</li>
</ul>
</li>
</ul>
</li>
<li><p>下载构建工具</p>
<ul>
<li><code>npm i -D webpack webpack-cli webpack-dev-server typescript ts-loader clean-webpack-plugin</code><ul>
<li>共安装了7个包<ul>
<li><strong>webpack</strong><ul>
<li>构建工具webpack</li>
</ul>
</li>
<li><strong>webpack-cli</strong><ul>
<li>webpack的命令行工具</li>
</ul>
</li>
<li><strong>webpack-dev-server</strong><ul>
<li>webpack的开发服务器</li>
</ul>
</li>
<li><strong>typescript</strong><ul>
<li>ts编译器</li>
</ul>
</li>
<li><strong>ts-loader</strong><ul>
<li>ts加载器，用于在webpack中编译ts文件</li>
</ul>
</li>
<li><strong>html-webpack-plugin</strong><ul>
<li>webpack中html插件，用来自动创建html文件</li>
</ul>
</li>
<li><strong>clean-webpack-plugin</strong><ul>
<li>webpack中的清除插件，每次构建都会先清除目录</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>根目录下创建webpack的配置文件webpack.config.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);<span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);<span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&quot;clean-webpack-plugin&quot;</span>);<span class="built_in">module</span>.exports = &#123;    <span class="attr">optimization</span>:&#123;        <span class="attr">minimize</span>: <span class="literal">false</span> <span class="comment">// 关闭代码压缩，可选    &#125;,    entry: &quot;./src/index.ts&quot;,        devtool: &quot;inline-source-map&quot;,        devServer: &#123;        contentBase: &#x27;./dist&#x27;    &#125;,    output: &#123;        path: path.resolve(__dirname, &quot;dist&quot;),        filename: &quot;bundle.js&quot;,        environment: &#123;            arrowFunction: false // 关闭webpack的箭头函数，可选        &#125;    &#125;,	// 用来设置引用模块    resolve: &#123;        extensions: [&quot;.ts&quot;, &quot;.js&quot;]    &#125;,        module: &#123;        // 指定要加载的规则        rules: [            &#123;                // test指定的是规则生效的文件                test: /\.ts$/,                // 配置babel                use: &#123;                   loader: &quot;ts-loader&quot;                     &#125;,                // 要排除的文件                exclude: /node_modules/            &#125;        ]    &#125;,    plugins: [        new CleanWebpackPlugin(),        new HtmlWebpackPlugin(&#123;            title:&#x27;TS测试&#x27;        &#125;),    ]&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>根目录下创建tsconfig.json，配置可以根据自己需要</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;    <span class="attr">&quot;compilerOptions&quot;</span>: &#123;        <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;ES2015&quot;</span>,        <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;ES2015&quot;</span>,        <span class="attr">&quot;strict&quot;</span>: <span class="literal">true</span>    &#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改package.json添加如下配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;  ...略...  <span class="attr">&quot;scripts&quot;</span>: &#123;    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span>,    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;webpack serve --open chrome.exe&quot;</span>  &#125;,  ...略...&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在src下创建ts文件，并在并命令行执行<code>npm run build</code>对代码进行编译，或者执行<code>npm start</code>来启动开发服务器</p>
</li>
</ol>
</li>
</ul>
<h2 id="5、Babel"><a href="#5、Babel" class="headerlink" title="5、Babel"></a>5、Babel</h2><ul>
<li><p>经过一系列的配置，使得TS和webpack已经结合到了一起，除了webpack，开发中还经常需要结合babel来<strong>对代码进行转换</strong>以使其可以<strong>兼容到更多的浏览器</strong>，在上述步骤的基础上，通过以下步骤再将babel引入到项目中。</p>
<ol>
<li><p>安装依赖包：</p>
<ul>
<li><code>npm i -D @babel/core @babel/preset-env babel-loader core-js</code></li>
<li>共安装了4个包，分别是：<ul>
<li>@babel/core<ul>
<li>babel的核心工具</li>
</ul>
</li>
<li>@babel/preset-env<ul>
<li>babel的预定义环境</li>
</ul>
</li>
<li>@babel-loader<ul>
<li>babel在webpack中的加载器</li>
</ul>
</li>
<li>core-js<ul>
<li>core-js用来使老版本的浏览器支持新版ES语法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>修改webpack.config.js配置文件</p>
<ul>
<li>```javascript<br>…略…module: {  rules: [    {      test: /.ts$/,      use: [        {           loader: “babel-loader”,// 指定加载器            // 设置babel           options:{               // 设置预定义环境             presets: [                   [                  “@babel/preset-env”,// 指定环境的插件                    // 配置信息                     {                        “targets”:{                            // 要兼容的目标浏览器                           “chrome”: “58”,                              “ie”: “11”                          },                          “corejs”:”3”,// 指定corejs版本                          “useBuiltIns”: “usage” // 按需加载                       }                ]             ]            }          },          {             loader: “ts-loader”,           }          ],            exclude: /node_modules/        }    ]}…略…<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">     - 如此一来，使用ts编译后的文件将会再次被babel处理，使得代码可以在大部分浏览器中直接使用，可以在配置选项的targets中指定要兼容的浏览器版本。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第二章：面向对象</span><br><span class="line"></span><br><span class="line">面向对象是程序中一个非常重要的思想，它被很多同学理解成了一个比较难，比较深奥的问题，其实不然。面向对象很简单，简而言之就是**程序之中所有的操作都需要通过对象来完成**。</span><br><span class="line"></span><br><span class="line">- 举例来说：</span><br><span class="line">  - 操作浏览器要使用window对象</span><br><span class="line">  - 操作网页要使用document对象</span><br><span class="line">  - 操作控制台要使用console对象</span><br><span class="line"></span><br><span class="line">一切操作都要通过对象，也就是所谓的面向对象，那么对象到底是什么呢？这就要先说到程序是什么，计算机程序的本质就是**对现实事物的抽象**，**抽象**的反义词是**具体**，比如：照片是对一个具体的人的抽象，汽车模型是对具体汽车的抽象等等。程序也是对事物的抽象，在程序中我们可以表示一个人、一条狗、一把枪、一颗子弹等等所有的事物。一个事物到了程序中就变成了一个对象。</span><br><span class="line"></span><br><span class="line">在程序中所有的对象都被分成了两个部分：**数据**和**功能**，以人为例，人的姓名、性别、年龄、身高、体重等属于数据，人可以说话、走路、吃饭、睡觉这些属于人的功能。数据在对象中被成为属性，而功能就被称为方法。所以简而言之，**在程序中一切皆是对象。**</span><br><span class="line"></span><br><span class="line">## 1、类（class）</span><br><span class="line"></span><br><span class="line">要想面向对象，操作对象，首先便要拥有对象，那么下一个问题就是如何**创建对象**。要创建对象，必须要**先定义类**，所谓的类可以理解为**对象的模型**，程序中可以根据类创建指定类型的对象，举例来说：可以通过Person类来创建人的对象，通过Dog类创建狗的对象，通过Car类来创建汽车的对象，不同的类可以用来创建不同的对象。</span><br><span class="line"></span><br><span class="line">- 定义类：</span><br><span class="line"></span><br><span class="line">  ```typescript</span><br><span class="line">  class 类名 &#123;	属性名: 类型;		constructor(参数: 类型)&#123;		this.属性名 = 参数;	&#125;		方法名()&#123;		....	&#125;&#125;/*    *   1.直接定义的属性是实例属性，需要通过对象的实例去访问：    *       const per = new Person();    *       per.name    *    *   2.使用static开头的属性是静态属性（类属性），可以直接通过类去访问    *       Person.age    *    *   readonly开头的属性表示一个只读的属性无法修改    * */</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>两种属性：</p>
<ul>
<li><strong>实例属性</strong><ul>
<li>直接定义的属性是实例属性，需要通过对象的实例去访问</li>
</ul>
</li>
<li><strong>静态属性</strong><ul>
<li>使用static开头的属性是静态属性（类属性），可以直接通过类去访问</li>
</ul>
</li>
</ul>
</li>
<li><p>构造函数constructor：</p>
<ul>
<li>```typescript<br>constructor(name: string, age: number) {    // 在实例方法中，this就表示当前当前的实例    // 在构造函数中当前对象就是当前新建的那个对象    // 可以通过this向新建的对象中添加属性    this.name = name;    this.age = age;}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 示例：</span><br><span class="line"></span><br><span class="line">  ```typescript</span><br><span class="line">  class Person&#123;    name: string;    age: number;    constructor(name: string, age: number)&#123;        this.name = name;        this.age = age;    &#125;    sayHello()&#123;        console.log(`大家好，我是$&#123;this.name&#125;`);    &#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用类：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;孙悟空&#x27;</span>, <span class="number">18</span>);p.sayHello();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2、面向对象的特点"><a href="#2、面向对象的特点" class="headerlink" title="2、面向对象的特点"></a>2、面向对象的特点</h2><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ul>
<li><p>对象实质上就是属性和方法的容器，它的主要作用就是<strong>存储属性和方法</strong>，这就是所谓的封装</p>
</li>
<li><p>默认情况下，对象的属性是可以任意的修改的，为了<strong>确保数据的安全性</strong>，在TS中可以对属性的权限进行设置</p>
</li>
<li><p>只读属性（readonly）：</p>
<ul>
<li>如果在声明属性时添加一个readonly，则属性便成了只读属性无法修改</li>
</ul>
</li>
<li><p>TS中<strong>属性</strong>具有三种<strong>修饰符</strong>：</p>
<ul>
<li><strong>public</strong>（默认值），可以在类、子类和对象中修改</li>
<li><strong>protected</strong> ，可以在类、子类中修改</li>
<li><strong>private</strong> ，可以在类中修改</li>
</ul>
</li>
<li><p>示例：</p>
<ul>
<li><p>public</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;    <span class="keyword">public</span> name: <span class="built_in">string</span>; <span class="comment">// 写或什么都不写都是public    public age: number;    constructor(name: string, age: number)&#123;        this.name = name; // 可以在类中修改        this.age = age;    &#125;    sayHello()&#123;        console.log(`大家好，我是$&#123;this.name&#125;`);    &#125;&#125;class Employee extends Person&#123;    constructor(name: string, age: number)&#123;        super(name, age);        this.name = name; //子类中可以修改    &#125;&#125;const p = new Person(&#x27;孙悟空&#x27;, 18);p.name = &#x27;猪八戒&#x27;;// 可以通过对象修改</span></span><br></pre></td></tr></table></figure></li>
<li><p>protected</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;    <span class="keyword">protected</span> name: <span class="built_in">string</span>;    <span class="keyword">protected</span> age: <span class="built_in">number</span>;    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span>&#123;        <span class="built_in">this</span>.name = name; <span class="comment">// 可以修改        this.age = age;    &#125;    sayHello()&#123;        console.log(`大家好，我是$&#123;this.name&#125;`);    &#125;&#125;class Employee extends Person&#123;    constructor(name: string, age: number)&#123;        super(name, age);        this.name = name; //子类中可以修改    &#125;&#125;const p = new Person(&#x27;孙悟空&#x27;, 18);p.name = &#x27;猪八戒&#x27;;// 不能修改</span></span><br></pre></td></tr></table></figure></li>
<li><p>private</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;    <span class="keyword">private</span> name: <span class="built_in">string</span>;    <span class="keyword">private</span> age: <span class="built_in">number</span>;    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span>&#123;        <span class="built_in">this</span>.name = name; <span class="comment">// 可以修改        this.age = age;    &#125;    sayHello()&#123;        console.log(`大家好，我是$&#123;this.name&#125;`);    &#125;&#125;class Employee extends Person&#123;    constructor(name: string, age: number)&#123;        super(name, age);        this.name = name; //子类中不能修改    &#125;&#125;const p = new Person(&#x27;孙悟空&#x27;, 18);p.name = &#x27;猪八戒&#x27;;// 不能修改</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>属性存取器</p>
<ul>
<li><p>对于一些不希望被任意修改的属性，可以将其设置为private</p>
</li>
<li><p>直接将其设置为private将导致无法再通过对象修改其中的属性</p>
</li>
<li><p>我们可以在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的存取器</p>
</li>
<li><p>读取属性的方法叫做setter方法，设置属性的方法叫做getter方法</p>
</li>
<li><p>示例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;    <span class="keyword">private</span> _name: <span class="built_in">string</span>;    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span>&#123;        <span class="built_in">this</span>._name = name;    &#125;    <span class="keyword">get</span> <span class="title">name</span>()&#123;        <span class="keyword">return</span> <span class="built_in">this</span>._name;    &#125;    <span class="keyword">set</span> <span class="title">name</span>(<span class="params">name: <span class="built_in">string</span></span>)&#123;        <span class="built_in">this</span>._name = name;    &#125;&#125;<span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;孙悟空&#x27;</span>);<span class="built_in">console</span>.log(p1.name); <span class="comment">// 通过getter读取name属性p1.name = &#x27;猪八戒&#x27;; // 通过setter修改name属性</span></span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;    <span class="comment">// 定义一个表示人的类    class Person&#123;        // TS可以在属性前添加属性的修饰符        /*        *   public 修饰的属性可以在任意位置访问（修改） 默认值        *   private 私有属性，私有属性只能在类内部进行访问（修改）        *       - 通过在类中添加方法使得私有属性可以被外部访问        *   protected 受包含的属性，只能在当前类和当前类的子类中访问（修改）        *        * */        private _name: string;        private _age: number;        constructor(name: string, age: number) &#123;            this._name = name;            this._age = age;        &#125;        /*        *   getter方法用来读取属性        *   setter方法用来设置属性        *       - 它们被称为属性的存取器        * */        // 定义方法，用来获取name属性        // getName()&#123;        //     return this._name;        // &#125;        //        // // 定义方法，用来设置name属性        // setName(value: string)&#123;        //     this._name = value;        // &#125;        //        // getAge()&#123;        //     return this._age;        // &#125;        //        // setAge(value: number)&#123;        //     // 判断年龄是否合法        //     if(value &gt;= 0)&#123;        //         this._age = value;        //     &#125;        // &#125;        // TS中设置getter方法的方式        get name()&#123;            // console.log(&#x27;get name()执行了！！&#x27;);            return this._name;        &#125;        set name(value)&#123;            this._name = value;        &#125;        get age()&#123;            return this._age;        &#125;        set age(value)&#123;            if(value &gt;= 0)&#123;                this._age = value            &#125;        &#125;    &#125;    const per = new Person(&#x27;孙悟空&#x27;, 18);    /*    * 现在属性是在对象中设置的，属性可以任意的被修改,    *   属性可以任意被修改将会导致对象中的数据变得非常不安全    * */    // per.setName(&#x27;猪八戒&#x27;);    // per.setAge(-33);    per.name = &#x27;猪八戒&#x27;;    per.age = -33;    // console.log(per);    class A&#123;        protected num: number;        constructor(num: number) &#123;            this.num = num;        &#125;    &#125;    class B extends A&#123;        test()&#123;            console.log(this.num);        &#125;    &#125;    const b = new B(123);    // b.num = 33;   /* class C&#123;        name: string;        age: number        // 可以直接将属性定义在构造函数中        constructor(name: string, age: number) &#123;            this.name = name;             this.age = age;        &#125;    &#125;*/    class C&#123;        // 可以直接将属性定义在构造函数中        constructor(public name: string, public age: number) &#123;        &#125;    &#125;    const c = new C(&#x27;xxx&#x27;, 111);    console.log(c);&#125;)();</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>静态属性</p>
<ul>
<li><p>静态属性（方法），也称为类属性。使用静态属性无需创建实例，通过类即可直接使用</p>
</li>
<li><p>静态属性（方法）使用static开头</p>
</li>
<li><p>示例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tools</span></span>&#123;    <span class="keyword">static</span> PI = <span class="number">3.1415926</span>;        <span class="keyword">static</span> <span class="function"><span class="title">sum</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>)</span>&#123;        <span class="keyword">return</span> num1 + num2    &#125;&#125;<span class="built_in">console</span>.log(Tools.PI);<span class="built_in">console</span>.log(Tools.sum(<span class="number">123</span>, <span class="number">456</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>this</p>
<ul>
<li>在类中，使用this表示当前对象</li>
</ul>
</li>
</ul>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul>
<li><p>继承时面向对象中的又一个特性</p>
</li>
<li><p>通过继承可以将其他类中的属性和方法引入到当前类中</p>
<ul>
<li><p>示例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;    name: <span class="built_in">string</span>;    age: <span class="built_in">number</span>;    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span>&#123;        <span class="built_in">this</span>.name = name;        <span class="built_in">this</span>.age = age;    &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;    <span class="function"><span class="title">bark</span>(<span class="params"></span>)</span>&#123;        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>在汪汪叫！`</span>);    &#125;&#125;<span class="keyword">const</span> dog = <span class="keyword">new</span> Dog(<span class="string">&#x27;旺财&#x27;</span>, <span class="number">4</span>);dog.bark();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>通过继承可以在不修改类的情况下完成对类的扩展</p>
</li>
</ul>
<h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><ul>
<li><p>发生继承时，如果子类中的方法会<strong>替换</strong>掉父类中的同名方法，这就称为方法的重写</p>
</li>
<li><p>示例：</p>
<ul>
<li>```typescript<br>class Animal{    name: string;    age: number;    constructor(name: string, age: number){        this.name = name;        this.age = age;    }    run(){        console.log(<code>父类中的run方法！</code>);    }}class Dog extends Animal{    bark(){        console.log(<code>$&#123;this.name&#125;在汪汪叫！</code>);    }    run(){        console.log(<code>子类中的run方法，会重写父类中的run方法！</code>);    }}const dog = new Dog(‘旺财’, 4);dog.bark();<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **super**</span><br><span class="line"></span><br><span class="line">  - 在类的方法中 **super就表示当前类的父类**</span><br><span class="line">  - 如果在子类中写了构造函数，在子类构造函数中必须对父类的构造函数进行调用</span><br><span class="line"></span><br><span class="line">  ```typescript</span><br><span class="line">  (function () &#123;    class Animal &#123;        name: string;        constructor(name: string) &#123;            this.name = name;        &#125;        sayHello() &#123;            console.log(&#x27;动物在叫~&#x27;);        &#125;    &#125;    class Dog extends Animal&#123;        age: number;        // 相当于重写了        constructor(name: string, age: number) &#123;            // 如果在子类中写了构造函数，在子类构造函数中必须对父类的构造函数进行调用            super(name); // 调用父类的构造函数            this.age = age;        &#125;        sayHello() &#123;            // 在类的方法中 super就表示当前类的父类            //super.sayHello();            console.log(&#x27;汪汪汪汪！&#x27;);        &#125;    &#125;    const dog = new Dog(&#x27;旺财&#x27;, 3);    dog.sayHello();&#125;)();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>抽象类</strong>（abstract class）</p>
<ul>
<li><p>抽象类是专门用来被其他类所继承的类，它<strong>只能被其他类所继承不能用来创建实例</strong></p>
</li>
<li><p>```typescript<br>abstract class Animal{    abstract run(): void;    bark(){        console.log(‘动物在叫<del>‘);    }}class Dog extends Animals{    run(){        console.log(‘狗在跑</del>‘);    }}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 使用**abstract**开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，继承抽象类时抽象方法必须要实现（必须重写）</span><br><span class="line"></span><br><span class="line">  ```typescript</span><br><span class="line">  abstract sayHello():void;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="3、接口（Interface）"><a href="#3、接口（Interface）" class="headerlink" title="3、接口（Interface）"></a>3、接口（Interface）</h2><ul>
<li><p>接口的作用<strong>类似于抽象类</strong>，不同点在于接口中的所有方法和属性都是<strong>没有实值</strong>的，换句话说接口中的所有方法<strong>都是抽象方法</strong>。</p>
</li>
<li><p>接口主要负责定义一个类的结构，接口可以去限制一个对象的接口，对象只有包含接口中定义的所有属性和方法时才能匹配接口。</p>
</li>
<li><p>示例（检查对象类型）：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person&#123;    name: <span class="built_in">string</span>;    sayHello():<span class="built_in">void</span>;&#125;<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">per: Person</span>)</span>&#123;    per.sayHello();&#125;fn(&#123;<span class="attr">name</span>:<span class="string">&#x27;孙悟空&#x27;</span>, <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;<span class="built_in">console</span>.log(<span class="string">`Hello, 我是 <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>)&#125;&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性。</p>
</li>
<li><p>实现接口就是使类满足接口的要求</p>
</li>
<li><p>示例（实现）</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person&#123;    name: <span class="built_in">string</span>;    sayHello():<span class="built_in">void</span>;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="title">implements</span> <span class="title">Person</span></span>&#123;    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>)</span> &#123;    &#125;    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;        <span class="built_in">console</span>.log(<span class="string">&#x27;大家好，我是&#x27;</span>+<span class="built_in">this</span>.name);    &#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4、泛型（Generic）"><a href="#4、泛型（Generic）" class="headerlink" title="4、泛型（Generic）"></a>4、泛型（Generic）</h2><ul>
<li><p>概念</p>
<ul>
<li>不确定某个类型</li>
<li><strong>自定义表示某个类型。</strong></li>
</ul>
</li>
<li><p>使用条件</p>
<ul>
<li>在定义函数或是类时，如果遇到类型不明确就可以使用泛型</li>
<li>定义一个函数或类时，有些情况下<strong>无法确定其中要使用的具体类型</strong>（返回值、参数、属性的类型不能确定），此时泛型便能够发挥作用。</li>
</ul>
</li>
<li><p>举个例子：</p>
<ul>
<li><p>```typescript<br>function test(arg: any): any{    return arg;}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的，由于类型不确定所以参数和返回值**均使用了any**，但是很明显这样做是不合适的，首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型</span><br><span class="line"></span><br><span class="line">- 使用泛型：</span><br><span class="line"></span><br><span class="line">- ```typescript</span><br><span class="line">  function test&lt;T&gt;(arg: T): T&#123;	return arg;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>这里的<code>&lt;T&gt;</code>就是泛型，T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型。所以泛型其实很好理解，就<strong>表示某个类型。</strong></p>
</li>
<li><p>那么如何使用上边的函数呢？</p>
<ul>
<li><p>方式一（直接使用）：</p>
<ul>
<li><p>```typescript<br>test(10)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式</span><br><span class="line"></span><br><span class="line">- 方式二（指定类型）：</span><br><span class="line"></span><br><span class="line">  - ```typescript</span><br><span class="line">    test&lt;number&gt;(10)</span><br></pre></td></tr></table></figure></li>
<li><p>也可以在函数后手动指定泛型</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>可以同时指定多个泛型，泛型间使用逗号隔开：</p>
<ul>
<li>```typescript<br>function test&lt;T, K&gt;(a: T, b: K): K{    return b;}test&lt;number, string&gt;(10, “hello”);<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 使用泛型时，完全可以将泛型当成是一个普通的类去使用</span><br><span class="line"></span><br><span class="line">- 类中同样可以使用泛型：</span><br><span class="line"></span><br><span class="line">  - ```typescript</span><br><span class="line">    class MyClass&lt;T&gt;&#123;    prop: T;    constructor(prop: T)&#123;        this.prop = prop;    &#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>除此之外，也可以对泛型的范围进行约束</p>
<ul>
<li><pre><code class="typescript">interface MyInter&#123;    length: number;&#125;function test&lt;T extends MyInter&gt;(arg: T): number&#123;    return arg.length;&#125;
</code></pre>
</li>
<li><p>使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口类和抽象类同样适用。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>code</category>
        <category>frontend</category>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs</title>
    <url>/2021/07/22/nodejs/</url>
    <content><![CDATA[<blockquote>
<p>nodejs基础知识笔记</p>
</blockquote>
<span id="more"></span>

<h1 id="Node介绍"><a href="#Node介绍" class="headerlink" title="Node介绍"></a>Node介绍</h1><h2 id="为什么要学习Node-js"><a href="#为什么要学习Node-js" class="headerlink" title="为什么要学习Node.js"></a>为什么要学习Node.js</h2><ul>
<li>企业需求<ul>
<li>具有服务端开发经验更改</li>
<li>front-end</li>
<li>back-end</li>
<li>全栈开发工程师</li>
<li>基本的网站开发能力<ul>
<li>服务端</li>
<li>前端</li>
<li>运维部署</li>
</ul>
</li>
<li>多人社区</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20200317114503403.png" alt="image-20200317114503403"></p>
<h2 id="Node-js是什么"><a href="#Node-js是什么" class="headerlink" title="Node.js是什么"></a>Node.js是什么</h2><ul>
<li>Node.js是JavaScript 运行时</li>
<li>通俗易懂的讲，Node.js是JavaScript的运行平台</li>
<li>Node.js既不是语言，也不是框架，它是一个平台</li>
<li>浏览器中的JavaScript<ul>
<li>EcmaScript<ul>
<li>基本语法</li>
<li>if</li>
<li>var</li>
<li>function</li>
<li>Object</li>
<li>Array</li>
</ul>
</li>
<li>Bom</li>
<li>Dom</li>
</ul>
</li>
<li>Node.js中的JavaScript<ul>
<li>没有Bom，Dom</li>
<li>EcmaScript</li>
<li>在Node中这个JavaScript执行环境为JavaScript提供了一些服务器级别的API<ul>
<li>例如文件的读写</li>
<li>网络服务的构建</li>
<li>网络通信</li>
<li>http服务器</li>
</ul>
</li>
</ul>
</li>
<li>构建与Chrome的V8引擎之上<ul>
<li>代码只是具有特定格式的字符串</li>
<li>引擎可以认识它，帮你解析和执行</li>
<li>Google Chrome的V8引擎是目前公认的解析执行JavaScript代码最快的</li>
<li>Node.js的作者把Google Chrome中的V8引擎移植出来，开发了一个独立的JavaScript运行时环境</li>
</ul>
</li>
<li>Node.js uses an envent-driven,non-blocking I/O mode that makes it lightweight and efficent.<ul>
<li> envent-driven    事件驱动</li>
<li> non-blocking I/O mode   非阻塞I/O模型（异步）</li>
<li> ightweight and efficent.   轻量和高效</li>
</ul>
</li>
<li>Node.js package ecosystem,npm,is the larget scosystem of open sourcr libraries in the world<ul>
<li>npm 是世界上最大的开源生态系统</li>
<li>绝大多数JavaScript相关的包都存放在npm上，这样做的目的是为了让开发人员更方便的去下载使用</li>
<li>npm install jquery</li>
</ul>
</li>
</ul>
<h2 id="Node能做什么"><a href="#Node能做什么" class="headerlink" title="Node能做什么"></a>Node能做什么</h2><ul>
<li>web服务器后台</li>
<li>命令行工具<ul>
<li>npm(node)</li>
<li>git(c语言)</li>
<li>hexo（node）</li>
<li>…</li>
</ul>
</li>
<li>对于前端工程师来讲，接触最多的是它的命令行工具<ul>
<li>自己写的很少，主要是用别人第三方的</li>
<li>webpack</li>
<li>gulp</li>
<li>npm</li>
</ul>
</li>
</ul>
<h1 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h1><h2 id="安装Node环境"><a href="#安装Node环境" class="headerlink" title="安装Node环境"></a>安装Node环境</h2><ul>
<li>查看Node环境的版本号</li>
<li>下载：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></li>
<li>安装：<ul>
<li>傻瓜式安装，一路<code>next</code></li>
<li>安装过再次安装会升级</li>
</ul>
</li>
<li>确认Node环境是否安装成功<ul>
<li>查看node的版本号：<code>node --version</code></li>
<li>或者<code>node -v</code></li>
</ul>
</li>
<li>配置环境变量</li>
</ul>
<h2 id="解析执行JavaScript"><a href="#解析执行JavaScript" class="headerlink" title="解析执行JavaScript"></a>解析执行JavaScript</h2><ol>
<li>创建编写JavaScript脚本文件</li>
<li>打开终端，定位脚本文件的所属目录</li>
<li>输入<code>node  文件名</code>执行对应的文件</li>
</ol>
<p>注意：文件名不要用<code>node.js</code>来命名，也就是说除了<code>node</code>这个名字随便起，最好不要使用中文。</p>
<h2 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h2><p>文件读取:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//浏览器中的JavaScript是没有文件操作能力的</span></span><br><span class="line"><span class="comment">//但是Node中的JavaScript具有文件操作能力</span></span><br><span class="line"><span class="comment">//fs是file-system的简写，就是文件系统的意思</span></span><br><span class="line"><span class="comment">//在Node中如果想要进行文件的操作就必须引用fs这个核心模块</span></span><br><span class="line"><span class="comment">//在fs这个和兴模块中，就提供了人所有文件操作相关的API</span></span><br><span class="line"><span class="comment">//例如 fs.readFile就是用来读取文件的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  1.使用fs核心模块</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.读取文件</span></span><br><span class="line">fs.readFile(<span class="string">&#x27;./data/a.txt&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;文件读取失败&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>文件写入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  1.使用fs核心模块</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.将数据写入文件</span></span><br><span class="line">fs.writeFile(<span class="string">&#x27;./data/a.txt&#x27;</span>,<span class="string">&#x27;我是文件写入的信息&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;文件写入失败&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>服务器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.加载http核心模块</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.使用http.createServer()创建一个web服务器</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.服务器要做的事儿</span></span><br><span class="line"><span class="comment">// 提供服务：对数据服务</span></span><br><span class="line"><span class="comment">// 发请求</span></span><br><span class="line"><span class="comment">//	接收请求</span></span><br><span class="line"><span class="comment">//	处理请求</span></span><br><span class="line"><span class="comment">//	反馈（发送响应）</span></span><br><span class="line"><span class="comment">//	当客户端请求过来，就会自动触发服务器的request请求事件，然后执行第二个参数：回调处理函数</span></span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;收到客户的请求了&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.绑定端口号，启动服务</span></span><br><span class="line">server.listen(<span class="number">3000</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;runing...&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Node中的模块系统"><a href="#Node中的模块系统" class="headerlink" title="Node中的模块系统"></a>Node中的模块系统</h1><p>使用Node编写应用程序主要就是在使用：</p>
<ul>
<li><p>EcmaScript语言</p>
<ul>
<li>和浏览器一样，在Node中没有Bom和Dom</li>
</ul>
</li>
<li><p>核心模块</p>
<ul>
<li>文件操作的fs</li>
<li>http服务操作的http</li>
<li>url路径操作模块</li>
<li>path路径处理模块</li>
<li>os操作系统信息</li>
</ul>
</li>
<li><p>第三方模块</p>
<ul>
<li>art-template</li>
<li>必须通过npm来下载才可以使用</li>
</ul>
</li>
<li><p>自己写的模块</p>
<ul>
<li>自己创建的文件</li>
</ul>
</li>
</ul>
<h2 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h2><ul>
<li>文件作用域(模块是独立的，在不同的文件使用必须要重新引用)【在node中没有全局作用域，它是文件模块作用域】</li>
<li>通信规则<ul>
<li>加载require</li>
<li>导出exports</li>
</ul>
</li>
</ul>
<h2 id="CommonJS模块规范"><a href="#CommonJS模块规范" class="headerlink" title="CommonJS模块规范"></a>CommonJS模块规范</h2><p>在Node中的JavaScript还有一个重要的概念，模块系统。</p>
<ul>
<li><p>模块作用域</p>
</li>
<li><p>使用require方法来加载模块</p>
</li>
<li><p>使用exports接口对象来导出模板中的成员</p>
<h3 id="加载require"><a href="#加载require" class="headerlink" title="加载require"></a>加载<code>require</code></h3><p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 自定义变量名 = require(<span class="string">&#x27;模块&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>作用：</p>
<ul>
<li>执行被加载模块中的代码</li>
<li>得到被加载模块中的<code>exports</code>导出接口对象</li>
</ul>
<h3 id="导出exports"><a href="#导出exports" class="headerlink" title="导出exports"></a>导出<code>exports</code></h3><ul>
<li><p>Node中是模块作用域，默认文件中所有的成员只在当前模块有效</p>
</li>
<li><p>对于希望可以被其他模块访问到的成员，我们需要把这些公开的成员都挂载到<code>exports</code>接口对象中就可以了</p>
<p>导出多个成员（必须在对象中）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.a = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">exports</span>.b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;bbb&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">exports</span>.c = &#123;</span><br><span class="line">    <span class="attr">foo</span>:<span class="string">&quot;bar&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">exports</span>.d = <span class="string">&#x27;hello&#x27;</span>;</span><br></pre></td></tr></table></figure>



<p>导出单个成员（拿到的就是函数，字符串）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="string">&#x27;hello&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>以下情况会覆盖：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="comment">//后者会覆盖前者</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以通过以下方法来导出多个成员：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    foo = <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">    <span class="attr">add</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="模块原理"><a href="#模块原理" class="headerlink" title="模块原理"></a>模块原理</h2><p>exports和<code>module.exports</code>的一个引用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">exports</span> === <span class="built_in">module</span>.exports);	<span class="comment">//trueexports.foo = &#x27;bar&#x27;;//等价于module.exports.foo = &#x27;bar&#x27;;</span></span><br></pre></td></tr></table></figure>

<p><code>当给exports重新赋值后，exports！= module.exports.</code></p>
<p><code>最终return的是module.exports,无论exports中的成员是什么都没用。</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">真正去使用的时候：	导出单个成员：<span class="built_in">exports</span>.xxx = xxx 或者 modeule.exports = xxx;	导出多个成员：<span class="built_in">module</span>.exports = &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引用服务var http = require(&#x27;http&#x27;);var fs = require(&#x27;fs&#x27;);// 引用模板var template = require(&#x27;art-template&#x27;);// 创建服务var server = http.createServer();// 公共路径var wwwDir = &#x27;D:/app/www&#x27;;server.on(&#x27;request&#x27;, function (req, res) &#123;    var url = req.url;    // 读取文件    fs.readFile(&#x27;./template-apche.html&#x27;, function (err, data) &#123;        if (err) &#123;            return res.end(&#x27;404 Not Found&#x27;);        &#125;        fs.readdir(wwwDir, function (err, files) &#123;            if (err) &#123;                return res.end(&#x27;Can not find www Dir.&#x27;)            &#125;            // 使用模板引擎解析替换data中的模板字符串            // 去xmpTempleteList.html中编写模板语法            var htmlStr = template.render(data.toString(), &#123;                 title: &#x27;D:/app/www/ 的索引&#x27;,                files:files             &#125;);            // 发送响应数据            res.end(htmlStr);        &#125;)    &#125;)&#125;);server.listen(3000, function () &#123;    console.log(&#x27;running....&#x27;);&#125;)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>jQuery中的each 和 原生JavaScript方法forEach的区别：	提供源头：    	原生js是es5提供的（不兼容IE8）,        jQuery的each是jQuery第三方库提供的（如果要使用需要用<span class="number">2</span>以下的版本也就是<span class="number">1.</span>版本）,它的each方法主要用来遍历jQuery实例对象（伪数组）,同时也可以做低版本forEach的替代品,jQuery的实例对象不能使用forEach方法，如果想要使用必须转为数组（[].slice.call(jQuery实例对象)）才能使用<span class="number">2.</span>模块中导出多个成员和导出单个成员<span class="number">3.301</span>和<span class="number">302</span>的区别：	<span class="number">301</span>永久重定向,浏览器会记住    <span class="number">302</span>临时重定向<span class="number">4.</span><span class="built_in">exports</span>和<span class="built_in">module</span>.exports的区别:	每个模块中都有一个<span class="built_in">module</span>对象    <span class="built_in">module</span>对象中有一个<span class="built_in">exports</span>对象    我们可以把需要导出的成员都挂载到<span class="built_in">module</span>.exports接口对象中	也就是<span class="string">`module.exports.xxx = xxx`</span>的方式    但是每次写太多了就很麻烦，所以Node为了简化代码，就在每一个模块中都提供了一个成员叫<span class="string">`exports`</span>    <span class="string">`exports === module.exports`</span>结果为<span class="literal">true</span>,所以完全可以<span class="string">`exports.xxx = xxx`</span>    当一个模块需要导出单个成员的时候必须使用<span class="string">`module.exports = xxx`</span>的方式，=,使用<span class="string">`exports = xxx`</span>不管用,因为每个模块最终<span class="keyword">return</span>的是<span class="built_in">module</span>.exports,而<span class="built_in">exports</span>只是<span class="built_in">module</span>.exports的一个引用,所以<span class="string">`exports`</span>即使重新赋值,也不会影响<span class="string">`module.exports`</span>。    有一种赋值方式比较特殊：<span class="string">`exports = module.exports`</span>这个用来新建立引用关系的。    </span><br></pre></td></tr></table></figure>

<h1 id="require的加载规则"><a href="#require的加载规则" class="headerlink" title="require的加载规则"></a>require的加载规则</h1><ul>
<li><p>核心模块</p>
<ul>
<li>模块名</li>
</ul>
</li>
<li><p>第三方模块</p>
<ul>
<li>模块名</li>
</ul>
</li>
<li><p>用户自己写的</p>
<ul>
<li>路径</li>
</ul>
</li>
</ul>
<h2 id="require的加载规则："><a href="#require的加载规则：" class="headerlink" title="require的加载规则："></a>require的加载规则：</h2><ul>
<li><p>优先从缓存加载</p>
</li>
<li><p>判断模块标识符</p>
<ul>
<li>核心模块</li>
<li>自己写的模块（路径形式的模块）</li>
<li>第三方模块（node_modules）<ul>
<li>第三方模块的标识就是第三方模块的名称（不可能有第三方模块和核心模块的名字一致）</li>
<li>npm<ul>
<li>开发人员可以把写好的框架库发布到npm上</li>
<li>使用者通过npm命令来下载</li>
</ul>
</li>
<li>使用方式：<code>var 名称 = require(&#39;npm install【下载包】 的包名&#39;)</code><ul>
<li>node_modules/express/package.json main</li>
<li>如果package.json或者main不成立，则查找被选择项：index.js</li>
<li>如果以上条件都不满足，则继续进入上一级目录中的node_modules按照上面的规则依次查找，直到当前文件所属此盘根目录都找不到最后报错</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果非路径形式的标识// 路径形式的标识：    // ./  当前目录 不可省略    // ../  上一级目录  不可省略    //  /xxx也就是D:/xxx    // 带有绝对路径几乎不用（D:/a/foo.js）// 首位表示的是当前文件模块所属磁盘根目录// require(&#x27;./a&#x27;); // 核心模块// 核心模块本质也是文件，核心模块文件已经被编译到了二进制文件中了，我们只需要按照名字来加载就可以了require(&#x27;fs&#x27;); // 第三方模块// 凡是第三方模块都必须通过npm下载（npm i node_modules），使用的时候就可以通过require(&#x27;包名&#x27;)来加载才可以使用// 第三方包的名字不可能和核心模块的名字是一样的// 既不是核心模块，也不是路径形式的模块//      先找到当前文所述目录的node_modules//      然后找node_modules/art-template目录//      node_modules/art-template/package.json//      node_modules/art-template/package.json中的main属性//      main属性记录了art-template的入口模块//      然后加载使用这个第三方包//      实际上最终加载的还是文件//      如果package.json不存在或者mian指定的入口模块不存在//      则node会自动找该目录下的index.js//      也就是说index.js是一个备选项，如果main没有指定，则加载index.js文件//              // 如果条件都不满足则会进入上一级目录进行查找// 注意：一个项目只有一个node_modules，放在项目根目录中，子目录可以直接调用根目录的文件var template = require(&#x27;art-template&#x27;);</span></span><br></pre></td></tr></table></figure>

<h2 id="模块标识符中的-和文件操作路径中的"><a href="#模块标识符中的-和文件操作路径中的" class="headerlink" title="模块标识符中的/和文件操作路径中的/"></a>模块标识符中的<code>/</code>和文件操作路径中的<code>/</code></h2><p>文件操作路径：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 咱们所使用的所有文件操作的API都是异步的// 就像ajax请求一样// 读取文件// 文件操作中 ./ 相当于当前模块所处磁盘根目录// ./index.txt    相对于当前目录// /index.txt    相对于当前目录// /index.txt   绝对路径,当前文件模块所处根目录// d:express/index.txt   绝对路径fs.readFile(&#x27;./index.txt&#x27;,function(err,data)&#123;    if(err)&#123;       return  console.log(&#x27;读取失败&#x27;);    &#125;    console.log(data.toString());&#125;)</span></span><br></pre></td></tr></table></figure>

<p>模块操作路径：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在模块加载中，相对路径中的./不能省略// 这里省略了.也是磁盘根目录require(&#x27;./index&#x27;)(&#x27;hello&#x27;)</span></span><br></pre></td></tr></table></figure>



<h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><ul>
<li>node package manage(node包管理器)</li>
<li>通过npm命令安装jQuery包（npm install –save jquery），在安装时加上–save会主动生成说明书文件信息（将安装文件的信息添加到package.json里面）</li>
</ul>
<h3 id="npm网站"><a href="#npm网站" class="headerlink" title="npm网站"></a>npm网站</h3><blockquote>
<p>​    npmjs.com    网站   是用来搜索npm包的</p>
</blockquote>
<h3 id="npm命令行工具"><a href="#npm命令行工具" class="headerlink" title="npm命令行工具"></a>npm命令行工具</h3><p>npm是一个命令行工具，只要安装了node就已经安装了npm。</p>
<p>npm也有版本概念，可以通过<code>npm --version</code>来查看npm的版本</p>
<p>升级npm(自己升级自己)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --<span class="built_in">global</span> npm</span><br></pre></td></tr></table></figure>

<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li>npm init(生成package.json说明书文件)<ul>
<li>npm init -y(可以跳过向导，快速生成)</li>
</ul>
</li>
<li>npm install<ul>
<li>一次性把dependencies选项中的依赖项全部安装</li>
<li>简写（npm i）</li>
</ul>
</li>
<li>npm install 包名<ul>
<li>只下载</li>
<li>简写（npm i 包名）</li>
</ul>
</li>
<li>npm install –save 包名<ul>
<li>下载并且保存依赖项（package.json文件中的dependencies选项）</li>
<li>简写（npm i  包名）</li>
</ul>
</li>
<li>npm uninstall 包名<ul>
<li>只删除，如果有依赖项会依然保存</li>
<li>简写（npm un 包名）</li>
</ul>
</li>
<li>npm uninstall –save 包名<ul>
<li>删除的同时也会把依赖信息全部删除</li>
<li>简写（npm un 包名）</li>
</ul>
</li>
<li>npm help<ul>
<li>查看使用帮助</li>
</ul>
</li>
<li>npm 命令 –help<ul>
<li>查看具体命令的使用帮助（npm uninstall –help）</li>
</ul>
</li>
</ul>
<h3 id="解决npm被墙问题"><a href="#解决npm被墙问题" class="headerlink" title="解决npm被墙问题"></a>解决npm被墙问题</h3><p>npm存储包文件的服务器在国外，有时候会被墙，速度很慢，所以需要解决这个问题。</p>
<blockquote>
<p><a href="https://developer.aliyun.com/mirror/NPM?from=tnpm%E6%B7%98%E5%AE%9D%E7%9A%84%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F%E6%8A%8Anpm%E5%9C%A8%E5%9B%BD%E5%86%85%E5%81%9A%E4%BA%86%E4%B8%80%E4%B8%AA%E9%95%9C%E5%83%8F%EF%BC%88%E4%B9%9F%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E5%A4%87%E4%BB%BD%EF%BC%89%E3%80%82">https://developer.aliyun.com/mirror/NPM?from=tnpm淘宝的开发团队把npm在国内做了一个镜像（也就是一个备份）。</a></p>
</blockquote>
<p>安装淘宝的cnpm：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https:<span class="comment">//registry.npm.taobao.org;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在任意目录执行都可以<span class="comment">#--global表示安装到全局，而非当前目录#--global不能省略，否则不管用npm install --global cnpm</span></span></span><br></pre></td></tr></table></figure>

<p>安装包的时候把以前的<code>npm</code>替换成<code>cnpm</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">走国外的npm服务器下载jQuery包，速度比较慢npm install jQuery;<span class="comment">#使用cnpm就会通过淘宝的服务器来下载jQuerycnpm install jQuery;</span></span></span><br></pre></td></tr></table></figure>

<p>如果不想安装<code>cnpm</code>又想使用淘宝的服务器来下载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install jquery --registry=https://npm.taobao.org;</span><br></pre></td></tr></table></figure>

<p>但是每次手动加参数就很麻烦，所以我们可以把这个选项加入到配置文件中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry https://npm.taobao.org;#查看npm配置信息npm config list;</span><br></pre></td></tr></table></figure>

<p>只要经过上面的配置命令，则以后所有的<code>npm install</code>都会通过淘宝的服务器来下载</p>
<h1 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h1><p>每一个项目都要有一个<code>package.json</code>文件（包描述文件，就像产品的说明书一样）</p>
<p>这个文件可以通过<code>npm init</code>自动初始化出来</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">D:\code\node中的模块系统&gt;npm initThis utility will walk you through creating a package.json file.It only covers the most common items, and tries to guess sensible defaults.See <span class="string">`npm help json`</span> <span class="keyword">for</span> definitive documentation on these fieldsand exactly what they <span class="keyword">do</span>.Use <span class="string">`npm install &lt;pkg&gt;`</span> afterwards to install a package andsave it <span class="keyword">as</span> a dependency <span class="keyword">in</span> the package.json file.Press ^C at any time to quit.package name: (node中的模块系统)Sorry, name can only contain URL-friendly characters.package name: (node中的模块系统) clsversion: (<span class="number">1.0</span><span class="number">.0</span>)description: 这是一个测试项目entry point: (main.js)test command:git repository:keywords:author: xiaochenlicense: (ISC)About to write to D:\code\node中的模块系统\package.json:&#123;  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;cls&quot;</span>,  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;这是一个测试项目&quot;</span>,  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;main.js&quot;</span>,  <span class="string">&quot;scripts&quot;</span>: &#123;    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>  &#125;,  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;xiaochen&quot;</span>,  <span class="string">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span>&#125;Is <span class="built_in">this</span> OK? (yes) yes</span><br></pre></td></tr></table></figure>

<p>对于目前来讲，最有用的是<code>dependencies</code>选项，可以用来帮助我们保存第三方包的依赖信息。</p>
<p>如果<code>node_modules</code>删除了也不用担心，只需要在控制面板中<code>npm install</code>就会自动把<code>package.json</code>中的<code>dependencies</code>中所有的依赖项全部都下载回来。</p>
<ul>
<li>建议每个项目的根目录下都有一个<code>package.json</code>文件</li>
<li>建议执行<code>npm install 包名</code>的时候都加上<code>--save</code>选项，目的是用来保存依赖信息</li>
</ul>
<h2 id="package-json和package-lock-json"><a href="#package-json和package-lock-json" class="headerlink" title="package.json和package-lock.json"></a>package.json和package-lock.json</h2><p>npm 5以前是不会有<code>package-lock.json</code>这个文件</p>
<p>npm5以后才加入这个文件</p>
<p>当你安装包的时候，npm都会生成或者更新<code>package-lock.json</code>这个文件</p>
<ul>
<li>npm5以后的版本安装都不要加<code>--save</code>参数，它会自动保存依赖信息</li>
<li>当你安装包的时候，会自动创建或者更新<code>package-lock.json</code>文件</li>
<li><code>package-lock.json</code>这个文件会包含<code>node_modules</code>中所有包的信息（版本，下载地址。。。）<ul>
<li>这样的话重新<code>npm install</code>的时候速度就可以提升</li>
</ul>
</li>
<li>从文件来看，有一个<code>lock</code>称之为锁<ul>
<li>这个<code>lock</code>使用来锁版本的</li>
<li>如果项目依赖了<code>1.1.1</code>版本</li>
<li>如果你重新install其实会下载最细版本，而不是<code>1.1.1</code></li>
<li><code>package-lock.json</code>的另外一个作用就是锁定版本号，防止自动升级</li>
</ul>
</li>
</ul>
<h2 id="path路径操作模块"><a href="#path路径操作模块" class="headerlink" title="path路径操作模块"></a>path路径操作模块</h2><blockquote>
<p>参考文档：<a href="https://nodejs.org/docs/latest-v13.x/api/path.html">https://nodejs.org/docs/latest-v13.x/api/path.html</a></p>
</blockquote>
<ul>
<li>path.basename：获取路径的文件名，默认包含扩展名</li>
<li>path.dirname：获取路径中的目录部分</li>
<li>path.extname：获取一个路径中的扩展名部分</li>
<li>path.parse：把路径转换为对象<ul>
<li>root：根路径</li>
<li>dir：目录</li>
<li>base：包含后缀名的文件名</li>
<li>ext：后缀名</li>
<li>name：不包含后缀名的文件名</li>
</ul>
</li>
<li>path.join：拼接路径</li>
<li>path.isAbsolute：判断一个路径是否为绝对路径<img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20200315150610001.png" alt="image-20200315150610001"></li>
</ul>
<h1 id="Node中的其它成员-dirname-filename"><a href="#Node中的其它成员-dirname-filename" class="headerlink" title="Node中的其它成员(__dirname,__filename)"></a>Node中的其它成员(__dirname,__filename)</h1><p>在每个模块中，除了<code>require</code>,<code>exports</code>等模块相关的API之外，还有两个特殊的成员：</p>
<ul>
<li><p><code>__dirname</code>，是一个成员，可以用来<strong>动态</strong>获取当前文件模块所属目录的绝对路径</p>
</li>
<li><p><code>__filename</code>，可以用来<strong>动态</strong>获取当前文件的绝对路径（包含文件名）</p>
</li>
<li><p><code>__dirname</code>和<code>filename</code>是不受执行node命令所属路径影响的</p>
</li>
</ul>
<p>==在文件操作中，使用相对路径是不可靠的，因为node中文件操作的路径被设计为相对于执行node命令所处的路径。==（node  xxx.js）</p>
<p>所以为了解决这个问题，只需要把相对路径变为==绝对路径==（绝对路径不受任何影响）就可以了。</p>
<p>就可以使用==<code>__dirname</code>==或者==<code>__filename</code>==来帮助我们解决这个问题</p>
<p>在拼接路径的过程中，为了避免手动拼接带来的一些低级错误，推荐使用<code>path.join()</code>来辅助拼接</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);<span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);<span class="comment">// console.log(__dirname + &#x27;a.txt&#x27;);// path.join方法会将文件操作中的相对路径都统一的转为动态的绝对路径fs.readFile(path.join(__dirname + &#x27;/a.txt&#x27;),&#x27;utf8&#x27;,function(err,data)&#123;	if(err)&#123;		throw err	&#125;	console.log(data);&#125;);</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>补充：模块中的路径标识和这里的路径没关系，不受影响（就是相对于文件模块）</p>
</blockquote>
<blockquote>
<p><strong>注意：</strong></p>
<p><strong>模块中的路径标识和文件操作中的相对路径标识不一致</strong></p>
<p><strong>模块中的路径标识就是相对于当前文件模块，不受node命令所处路径影响</strong></p>
</blockquote>
<h1 id="Express（快速的）"><a href="#Express（快速的）" class="headerlink" title="Express（快速的）"></a>Express（快速的）</h1><p>作者：Tj</p>
<p>原生的http在某些方面表现不足以应对我们的开发需求，所以就需要使用框架来加快我们的开发效率，框架的目的就是提高效率，让我们的代码高度统一。</p>
<p>在node中有很多web开发框架。主要学习express</p>
<ul>
<li><p><code>http://expressjs.com/</code>,其中主要封装的是http。</p>
</li>
<li><p>```javascript<br>// 1 安装// 2 引包var express = require(‘express’);// 3 创建服务器应用程序//      也就是原来的http.createServer();var app = express();// 公开指定目录// 只要通过这样做了，就可以通过/public/xx的方式来访问public目录中的所有资源// 在Express中开放资源就是一个API的事app.use(‘/public/‘,express.static(‘/public/‘));//模板引擎在Express中开放模板也是一个API的事// 当服务器收到get请求 / 的时候，执行回调处理函数app.get(‘/‘,function(req,res){    res.send(‘hello express’);})// 相当于server.listenapp.listen(3000,function(){    console.log(‘app is runing at port 3000’);})</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### 学习Express</span><br><span class="line"></span><br><span class="line">#### 起步</span><br><span class="line"></span><br><span class="line">##### 安装：![image-20200310123723079](C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20200310123723079.png)</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">cnpm install express</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world:"></a>hello world:<img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20200310124850557.png" alt="image-20200310124850557"></h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入expressvar express = require(&#x27;express&#x27;);// 1. 创建appvar app = express();//  2. app.get(&#x27;/&#x27;,function(req,res)&#123;    // 1    // res.write(&#x27;Hello&#x27;);    // res.write(&#x27;World&#x27;);    // res.end()    // 2    // res.end(&#x27;hello world&#x27;);    // 3    res.send(&#x27;hello world&#x27;);&#125;)app.listen(3000,function()&#123;    console.log(&#x27;express app is runing...&#x27;);&#125;)</span></span><br></pre></td></tr></table></figure>

<h5 id="基本路由"><a href="#基本路由" class="headerlink" title="基本路由"></a>基本路由</h5><p>路由：</p>
<ul>
<li><p>请求方法</p>
</li>
<li><p>请求路径</p>
</li>
<li><p>请求处理函数</p>
</li>
</ul>
<p>get:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当你以get方法请求/的时候，执行对应的处理函数app.get(&#x27;/&#x27;,function(req,res)&#123;    res.send(&#x27;hello world&#x27;);&#125;)</span></span><br></pre></td></tr></table></figure>

<p>post:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当你以post方法请求/的时候，执行对应的处理函数app.post(&#x27;/&#x27;,function(req,res)&#123;    res.send(&#x27;hello world&#x27;);&#125;)</span></span><br></pre></td></tr></table></figure>

<h5 id="Express静态服务API"><a href="#Express静态服务API" class="headerlink" title="Express静态服务API"></a>Express静态服务API</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.use不仅仅是用来处理静态资源的，还可以做很多工作(body-parser的配置)app.use(express.static(&#x27;public&#x27;));app.use(express.static(&#x27;files&#x27;));app.use(&#x27;/stataic&#x27;,express.static(&#x27;public&#x27;));</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入expressvar express = require(&#x27;express&#x27;);// 创建appvar app = express();// 开放静态资源// 1.当以/public/开头的时候，去./public/目录中找对应资源// 访问：http://127.0.0.1:3000/public/login.htmlapp.use(&#x27;/public/&#x27;,express.static(&#x27;./public/&#x27;)); // 2.当省略第一个参数的时候，可以通过省略/public的方式来访问// 访问：http://127.0.0.1:3000/login.html// app.use(express.static(&#x27;./public/&#x27;));   // 3.访问：http://127.0.0.1:3000/a/login.html// a相当于public的别名// app.use(&#x27;/a/&#x27;,express.static(&#x27;./public/&#x27;)); //  app.get(&#x27;/&#x27;,function(req,res)&#123;    res.end(&#x27;hello world&#x27;);&#125;);app.listen(3000,function()&#123;    console.log(&#x27;express app is runing...&#x27;);&#125;);</span></span><br></pre></td></tr></table></figure>

<h5 id="在Express中配置使用art-templete模板引擎"><a href="#在Express中配置使用art-templete模板引擎" class="headerlink" title="在Express中配置使用art-templete模板引擎"></a>在Express中配置使用<code>art-templete</code>模板引擎</h5><ul>
<li><a href="https://aui.github.io/art-template/">art-template官方文档</a></li>
<li>在node中，有很多第三方模板引擎都可以使用，不是只有<code>art-template</code><ul>
<li>还有ejs，jade（pug），handlebars，nunjucks</li>
</ul>
</li>
</ul>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save art-templatenpm install --save express-art-template//两个一起安装npm i --save art-template express-art-template</span><br></pre></td></tr></table></figure>

<p>配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.engine(<span class="string">&#x27;html&#x27;</span>, <span class="built_in">require</span>(<span class="string">&#x27;express-art-template&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;    <span class="comment">// express默认会去views目录找index.html    res.render(&#x27;index.html&#x27;,&#123;           title:&#x27;hello world&#x27;         &#125;);&#125;)</span></span><br></pre></td></tr></table></figure>

<p>如果希望修改默认的<code>views</code>视图渲染存储目录，可以：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数views千万不要写错app.set(&#x27;views&#x27;,目录路径);</span></span><br></pre></td></tr></table></figure>

<h5 id="在Express中获取表单请求数据"><a href="#在Express中获取表单请求数据" class="headerlink" title="在Express中获取表单请求数据"></a>在Express中获取表单请求数据</h5><h6 id="获取get请求数据："><a href="#获取get请求数据：" class="headerlink" title="获取get请求数据："></a>获取get请求数据：</h6><p>Express内置了一个api，可以直接通过<code>req.query</code>来获取数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过requery方法获取用户输入的数据// req.query只能拿到get请求的数据 var comment = req.query;</span></span><br></pre></td></tr></table></figure>

<h6 id="获取post请求数据："><a href="#获取post请求数据：" class="headerlink" title="获取post请求数据："></a>获取post请求数据：</h6><p>在Express中没有内置获取表单post请求体的api，这里我们需要使用一个第三方包<code>body-parser</code>来获取数据。</p>
<p>安装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save body-parser;</span><br></pre></td></tr></table></figure>

<p>配置：</p>
<p>// 配置解析表单 POST 请求体插件（注意：一定要在 app.use(router) 之前 ）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)<span class="comment">// 引包var bodyParser = require(&#x27;body-parser&#x27;)var app = express()// 配置body-parser// 只要加入这个配置，则在req请求对象上会多出来一个属性：body// 也就是说可以直接通过req.body来获取表单post请求数据// parse application/x-www-form-urlencodedapp.use(bodyParser.urlencoded(&#123; extended: false &#125;))// parse application/jsonapp.use(bodyParser.json())</span></span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;  res.setHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/plain&#x27;</span>)  res.write(<span class="string">&#x27;you posted:\n&#x27;</span>)  <span class="comment">// 可以通过req.body来获取表单请求数据  res.end(JSON.stringify(req.body, null, 2))&#125;)</span></span><br></pre></td></tr></table></figure>

<h3 id="在Express中配置使用express-session插件操作"><a href="#在Express中配置使用express-session插件操作" class="headerlink" title="在Express中配置使用express-session插件操作"></a>在Express中配置使用<code>express-session</code>插件操作</h3><blockquote>
<p>参考文档：<a href="https://github.com/expressjs/session">https://github.com/expressjs/session</a></p>
</blockquote>
<p>安装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install express-session</span><br></pre></td></tr></table></figure>

<p>配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该插件会为req请求对象添加一个成员:req.session默认是一个对象//这是最简单的配置方式//Session是基于Cookie实现的app.use(session(&#123;  //配置加密字符串，他会在原有的基础上和字符串拼接起来去加密  //目的是为了增加安全性，防止客户端恶意伪造  secret: &#x27;keyboard cat&#x27;,  resave: false,  saveUninitialized: true,//无论是否适用Session，都默认直接分配一把钥匙  cookie: &#123; secure: true &#125;&#125;))</span></span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读//添加Session数据//session就是一个对象req.session.foo = &#x27;bar&#x27;;//写//获取session数据req.session.foo//删req.session.foo = null;delete req.session.foo</span></span><br></pre></td></tr></table></figure>

<p>提示：</p>
<p>默认Session数据时内存储数据，服务器一旦重启，真正的生产环境会把Session进行持久化存储。</p>
<h3 id="利用Express实现ADUS项目"><a href="#利用Express实现ADUS项目" class="headerlink" title="利用Express实现ADUS项目"></a>利用Express实现ADUS项目</h3><h4 id="模块化思想"><a href="#模块化思想" class="headerlink" title="模块化思想"></a>模块化思想</h4><p>模块如何划分:</p>
<ul>
<li>模块职责要单一</li>
</ul>
<p>javascript模块化：</p>
<ul>
<li>Node 中的 CommonJS</li>
<li>浏览器中的：<ul>
<li>AMD    require.js</li>
<li>CMD     sea.js</li>
</ul>
</li>
<li>es6中增加了官方支持</li>
</ul>
<h4 id="起步-1"><a href="#起步-1" class="headerlink" title="起步"></a>起步</h4><ul>
<li>初始化</li>
<li>模板处理</li>
</ul>
<h4 id="路由设计"><a href="#路由设计" class="headerlink" title="路由设计"></a>路由设计</h4><table>
<thead>
<tr>
<th>请求方法</th>
<th align="left">请求路径</th>
<th align="left">get参数</th>
<th>post参数</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td align="left">/students</td>
<td align="left"></td>
<td></td>
<td align="left">渲染首页</td>
</tr>
<tr>
<td>GET</td>
<td align="left">/students/new</td>
<td align="left"></td>
<td></td>
<td align="left">渲染添加学生页面</td>
</tr>
<tr>
<td>POST</td>
<td align="left">/students/new</td>
<td align="left"></td>
<td>name,age,gender,hobbies</td>
<td align="left">处理添加学生请求</td>
</tr>
<tr>
<td>GET</td>
<td align="left">/students/edit</td>
<td align="left">id</td>
<td></td>
<td align="left">渲染编辑页面</td>
</tr>
<tr>
<td>POST</td>
<td align="left">/students/edit</td>
<td align="left"></td>
<td>id,name,age,gender,hobbies</td>
<td align="left">处理编辑请求</td>
</tr>
<tr>
<td>GET</td>
<td align="left">/students/delete</td>
<td align="left">id</td>
<td></td>
<td align="left">处理删除请求</td>
</tr>
</tbody></table>
<h4 id="提取路由模块"><a href="#提取路由模块" class="headerlink" title="提取路由模块"></a>提取路由模块</h4><p>router.js:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** * router.js路由模块 * 职责： *      处理路由 *      根据不同的请求方法+请求路径设置具体的请求函数 * 模块职责要单一，我们划分模块的目的就是增强代码的可维护性，提升开发效率 */</span><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);<span class="comment">// Express专门提供了一种更好的方式// 专门用来提供路由的var express = require(&#x27;express&#x27;);// 1 创建一个路由容器var router = express.Router();// 2 把路由都挂载到路由容器中router.get(&#x27;/students&#x27;, function(req, res) &#123;    // res.send(&#x27;hello world&#x27;);    // readFile的第二个参数是可选的，传入utf8就是告诉他把读取到的文件直接按照utf8编码，直接转成我们认识的字符    // 除了这样来转换，也可以通过data.toString（）来转换    fs.readFile(&#x27;./db.json&#x27;, &#x27;utf8&#x27;, function(err, data) &#123;        if (err) &#123;            return res.status(500).send(&#x27;Server error.&#x27;)        &#125;        // 读取到的文件数据是string类型的数据        // console.log(data);        // 从文件中读取到的数据一定是字符串，所以一定要手动转换成对象        var students = JSON.parse(data).students;        res.render(&#x27;index.html&#x27;, &#123;            // 读取文件数据            students:students        &#125;)    &#125;)&#125;);router.get(&#x27;/students/new&#x27;,function(req,res)&#123;    res.render(&#x27;new.html&#x27;)&#125;);router.get(&#x27;/students/edit&#x27;,function(req,res)&#123;    &#125;);router.post(&#x27;/students/edit&#x27;,function(req,res)&#123;    &#125;);router.get(&#x27;/students/delete&#x27;,function(req,res)&#123;    &#125;);// 3 把router导出module.exports = router;</span></span><br></pre></td></tr></table></figure>

<p>app.js:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> router = <span class="built_in">require</span>(<span class="string">&#x27;./router&#x27;</span>);<span class="comment">// router(app);// 把路由容器挂载到app服务中// 挂载路由app.use(router);</span></span><br></pre></td></tr></table></figure>



<h4 id="设计操作数据的API文件模块"><a href="#设计操作数据的API文件模块" class="headerlink" title="设计操作数据的API文件模块"></a>设计操作数据的API文件模块</h4><p>es6中的find和findIndex：</p>
<p>find接受一个方法作为参数，方法内部返回一个条件</p>
<p>find会便利所有的元素，执行你给定的带有条件返回值的函数</p>
<p>符合该条件的元素会作为find方法的返回值</p>
<p>如果遍历结束还没有符合该条件的元素，则返回undefined<img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20200313103810731.png" alt="image-20200313103810731"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** * student.js * 数据操作文件模块 * 职责：操作文件中的数据，只处理数据，不关心业务 */</span><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>); <span class="comment">/**  * 获取所有学生列表  * return []  */</span><span class="built_in">exports</span>.find = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    &#125; <span class="comment">/**  * 获取添加保存学生  */</span><span class="built_in">exports</span>.save = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;        &#125;<span class="comment">/** * 更新学生 */</span><span class="built_in">exports</span>.update = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;        &#125; <span class="comment">/** * 删除学生 */</span><span class="built_in">exports</span>.delete = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul>
<li><p>处理模板</p>
</li>
<li><p>配置静态开放资源</p>
</li>
<li><p>配置模板引擎</p>
</li>
<li><p>简单的路由，/studens渲染静态页出来</p>
</li>
<li><p>路由设计</p>
</li>
<li><p>提取路由模块</p>
</li>
<li><p>由于接下来的一系列业务操作都需要处理文件数据，所以我们需要封装Student.js’</p>
</li>
<li><p>先写好student.js文件结构</p>
<ul>
<li>查询所有学生列别哦的API</li>
<li>findById</li>
<li>save</li>
<li>updateById</li>
<li>deleteById</li>
</ul>
</li>
<li><p>实现具体功能</p>
<ul>
<li>通过路由收到请求</li>
<li>接受请求中的参数（get，post）<ul>
<li>req.query</li>
<li>req.body</li>
</ul>
</li>
<li>调用数据操作API处理数据</li>
<li>根据操作结果给客户端发送请求</li>
</ul>
</li>
<li><p>业务功能顺序</p>
<ul>
<li>列表</li>
<li>添加</li>
<li>编辑</li>
<li>删除</li>
</ul>
</li>
</ul>
<h4 id="子模板和模板的继承（模板引擎高级语法）【include，extend，block】"><a href="#子模板和模板的继承（模板引擎高级语法）【include，extend，block】" class="headerlink" title="子模板和模板的继承（模板引擎高级语法）【include，extend，block】"></a>子模板和模板的继承（模板引擎高级语法）【include，extend，block】</h4><p>注意:</p>
<p>模板页：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt;	&lt;meta charset=&quot;UTF-8&quot;&gt;	&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;	&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;	&lt;title&gt;模板页&lt;/title&gt;	&lt;link rel=&quot;stylesheet&quot; href=&quot;/node_modules/bootstrap/dist/css/bootstrap.css&quot;/&gt;	&#123;&#123; block &#x27;head&#x27; &#125;&#125;&#123;&#123; /block &#125;&#125;&lt;/head&gt;&lt;body&gt;	&lt;!-- 通过include导入公共部分 --&gt;	&#123;&#123;include &#x27;./header.html&#x27;&#125;&#125;		&lt;!-- 留一个位置 让别的内容去填充 --&gt;	&#123;&#123; block  &#x27;content&#x27; &#125;&#125;		&lt;h1&gt;默认内容&lt;/h1&gt;	&#123;&#123; /block &#125;&#125;		&lt;!-- 通过include导入公共部分 --&gt;	&#123;&#123;include &#x27;./footer.html&#x27;&#125;&#125;		&lt;!-- 公共样式 --&gt;	&lt;script src=&quot;/node_modules/jquery/dist/jquery.js&quot; &gt;&lt;/script&gt;	&lt;script src=&quot;/node_modules/bootstrap/dist/js/bootstrap.js&quot; &gt;&lt;/script&gt;	&#123;&#123; block &#x27;script&#x27; &#125;&#125;&#123;&#123; /block &#125;&#125;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>模板的继承：</p>
<p>​    header页面：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;&quot;</span>&gt;	<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>公共的头部<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>​    footer页面：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;&quot;</span>&gt;	<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>公共的底部<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>模板页的使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 继承(extend:延伸，扩展)模板也layout.html --&gt;&lt;!-- 把layout.html页面的内容都拿进来作为index.html页面的内容 --&gt;&#123;&#123;extend <span class="string">&#x27;./layout.html&#x27;</span>&#125;&#125;&lt;!-- 向模板页面填充新的数据 --&gt;&lt;!-- 填充后就会替换掉layout页面content中的数据 --&gt;&lt;!-- style样式方面的内容 --&gt;&#123;&#123; block <span class="string">&#x27;head&#x27;</span> &#125;&#125;	&lt;style type=<span class="string">&quot;text/css&quot;</span>&gt;		body&#123;			background-color: skyblue;		&#125;	&lt;<span class="regexp">/style&gt;&#123;&#123; /</span>block &#125;&#125;&#123;&#123; block <span class="string">&#x27;content&#x27;</span> &#125;&#125;	&lt;div id=<span class="string">&quot;&quot;</span>&gt;		<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Index页面的内容<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>	&lt;<span class="regexp">/div&gt;&#123;&#123; /</span>block &#125;&#125;&lt;!-- js部分的内容 --&gt;&#123;&#123; block <span class="string">&#x27;script&#x27;</span> &#125;&#125;	&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;			&lt;<span class="regexp">/script&gt;&#123;&#123; /</span>block &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>最终的显示效果：</p>
<p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20200316134759517.png" alt="image-20200316134759517"></p>
<h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><h2 id="关系型和非关系型数据库"><a href="#关系型和非关系型数据库" class="headerlink" title="关系型和非关系型数据库"></a>关系型和非关系型数据库</h2><h3 id="关系型数据库（表就是关系，或者说表与表之间存在关系）。"><a href="#关系型数据库（表就是关系，或者说表与表之间存在关系）。" class="headerlink" title="关系型数据库（表就是关系，或者说表与表之间存在关系）。"></a>关系型数据库（表就是关系，或者说表与表之间存在关系）。</h3><ul>
<li>所有的关系型数据库都需要通过<code>sql</code>语言来操作</li>
<li>所有的关系型数据库在操作之前都需要设计表结构</li>
<li>而且数据表还支持约束<ul>
<li>唯一的</li>
<li>主键</li>
<li>默认值</li>
<li>非空</li>
</ul>
</li>
</ul>
<h3 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h3><ul>
<li>非关系型数据库非常的灵活</li>
<li>有的关系型数据库就是key-value对儿</li>
<li>但MongDB是长得最像关系型数据库的非关系型数据库<ul>
<li>数据库 -》 数据库</li>
<li>数据表 -》 集合（数组）</li>
<li>表记录 -》文档对象</li>
</ul>
</li>
</ul>
<p>一个数据库中可以有多个数据库，一个数据库中可以有多个集合（数组），一个集合中可以有多个文档（表记录）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;    <span class="attr">qq</span>:&#123;       <span class="attr">user</span>:[           &#123;&#125;,&#123;&#125;,&#123;&#125;...       ]    &#125;&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>也就是说你可以任意的往里面存数据，没有结构性这么一说</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li><p>下载</p>
<ul>
<li>下载地址：<a href="https://www.mongodb.com/download-center/community">https://www.mongodb.com/download-center/community</a></li>
</ul>
</li>
<li><p>安装</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm i mongoose</span><br></pre></td></tr></table></figure></li>
<li><p>配置环境变量</p>
</li>
<li><p>最后输入<code>mongod --version</code>测试是否安装成功</p>
</li>
</ul>
<h2 id="启动和关闭数据库"><a href="#启动和关闭数据库" class="headerlink" title="启动和关闭数据库"></a>启动和关闭数据库</h2><p>启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mongodb 默认使用执行mongod 命令所处盘符根目录下的/data/db作为自己的数据存储目录<span class="comment"># 所以在第一次执行该命令之前先自己手动新建一个 /data/dbmongod# 开启服务net start mongodb</span></span></span><br></pre></td></tr></table></figure>

<p>如果想要修改默认的数据存储目录，可以：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mongod --dbpath = 数据存储目录路径</span><br></pre></td></tr></table></figure>

<p>停止：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">在开启服务的控制台，直接Ctrl+C;或者直接关闭开启服务的控制台。</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20200314101047100.png" alt="image-20200314101047100"></p>
<h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>连接：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 该命令默认连接本机的 MongoDB 服务mongo</span><br></pre></td></tr></table></figure>

<p>退出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 在连接状态输入 exit 退出连接exit</span><br></pre></td></tr></table></figure>



<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ul>
<li><code>show dbs</code><ul>
<li>查看数据库列表(数据库中的所有数据库)</li>
</ul>
</li>
<li><code>db</code><ul>
<li>查看当前连接的数据库</li>
</ul>
</li>
<li><code>use 数据库名称</code><ul>
<li>切换到指定的数据库，（如果没有会新建）</li>
</ul>
</li>
<li><code>show collections</code><ul>
<li>查看当前目录下的所有数据表</li>
</ul>
</li>
<li><code>db.表名.find()</code><ul>
<li>查看表中的详细信息</li>
</ul>
</li>
</ul>
<h2 id="在Node中如何操作MongoDB数据库"><a href="#在Node中如何操作MongoDB数据库" class="headerlink" title="在Node中如何操作MongoDB数据库"></a>在Node中如何操作MongoDB数据库</h2><h3 id="使用官方的MongoDB包来操作"><a href="#使用官方的MongoDB包来操作" class="headerlink" title="使用官方的MongoDB包来操作"></a>使用官方的<code>MongoDB</code>包来操作</h3><blockquote>
<p>​    <a href="http://mongodb.github.io/node-mongodb-native/">http://mongodb.github.io/node-mongodb-native/</a></p>
</blockquote>
<h3 id="使用第三方包mongoose来操作MongoDB数据库"><a href="#使用第三方包mongoose来操作MongoDB数据库" class="headerlink" title="使用第三方包mongoose来操作MongoDB数据库"></a>使用第三方包<code>mongoose</code>来操作MongoDB数据库</h3><p>​    第三方包：<code>mongoose</code>基于MongoDB官方的<code>mongodb</code>包再一次做了封装，名字叫<code>mongoose</code>，是WordPress项目团队开发的。</p>
<h2 id="学习指南（步骤）"><a href="#学习指南（步骤）" class="headerlink" title="学习指南（步骤）"></a>学习指南（步骤）</h2><p>官方学习文档：<a href="https://mongoosejs.com/docs/index.html">https://mongoosejs.com/docs/index.html</a></p>
<h3 id="设计Scheme-发布Model-创建表"><a href="#设计Scheme-发布Model-创建表" class="headerlink" title="设计Scheme 发布Model (创建表)"></a>设计Scheme 发布Model (创建表)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.引包// 注意：按照后才能require使用var mongoose = require(&#x27;mongoose&#x27;);// 拿到schema图表var Schema = mongoose.Schema;// 2.连接数据库// 指定连接数据库后不需要存在，当你插入第一条数据库后会自动创建数据库mongoose.connect(&#x27;mongodb://localhost/test&#x27;);// 3.设计集合结构（表结构）// 用户表var userSchema = new Schema(&#123;	username: &#123; //姓名		type: String,		require: true //添加约束，保证数据的完整性，让数据按规矩统一	&#125;,	password: &#123;		type: String,		require: true	&#125;,	email: &#123;		type: String	&#125;&#125;);// 4.将文档结构发布为模型// mongoose.model方法就是用来将一个架构发布为 model// 		第一个参数：传入一个大写名词单数字符串用来表示你的数据库的名称// 					mongoose 会自动将大写名词的字符串生成 小写复数 的集合名称// 					例如 这里会变成users集合名称// 		第二个参数：架构// 	返回值：模型构造函数var User = mongoose.model(&#x27;User&#x27;, userSchema);</span></span><br></pre></td></tr></table></figure>

<h3 id="添加数据（增）"><a href="#添加数据（增）" class="headerlink" title="添加数据（增）"></a>添加数据（增）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5.通过模型构造函数对User中的数据进行操作var user = new User(&#123;	username: &#x27;admin&#x27;,	password: &#x27;123456&#x27;,	email: &#x27;xiaochen@qq.com&#x27;&#125;);user.save(function(err, ret) &#123;	if (err) &#123;		console.log(&#x27;保存失败&#x27;);	&#125; else &#123;		console.log(&#x27;保存成功&#x27;);		console.log(ret);	&#125;&#125;);</span></span><br></pre></td></tr></table></figure>

<h3 id="删除（删）"><a href="#删除（删）" class="headerlink" title="删除（删）"></a>删除（删）</h3><p>根据条件删除所有：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">User.remove(&#123;	<span class="attr">username</span>: <span class="string">&#x27;xiaoxiao&#x27;</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, ret</span>) </span>&#123;	<span class="keyword">if</span> (err) &#123;		<span class="built_in">console</span>.log(<span class="string">&#x27;删除失败&#x27;</span>);	&#125; <span class="keyword">else</span> &#123;		<span class="built_in">console</span>.log(<span class="string">&#x27;删除成功&#x27;</span>);		<span class="built_in">console</span>.log(ret);	&#125;&#125;);</span><br></pre></td></tr></table></figure>

<p>根据条件删除一个：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Model.findOneAndRemove(conditions,[options],[callback]);</span><br></pre></td></tr></table></figure>

<p>根据id删除一个：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">User.findByIdAndRemove(id,[options],[callback]);</span><br></pre></td></tr></table></figure>



<h3 id="更新（改）"><a href="#更新（改）" class="headerlink" title="更新（改）"></a>更新（改）</h3><p>更新所有：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">User.remove(conditions,doc,[options],[callback]);</span><br></pre></td></tr></table></figure>

<p>根据指定条件更新一个：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">User.FindOneAndUpdate([conditions],[update],[options],[callback]);</span><br></pre></td></tr></table></figure>

<p>根据id更新一个：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新	根据id来修改表数据User.findByIdAndUpdate(&#x27;5e6c5264fada77438c45dfcd&#x27;, &#123;	username: &#x27;junjun&#x27;&#125;, function(err, ret) &#123;	if (err) &#123;		console.log(&#x27;更新失败&#x27;);	&#125; else &#123;		console.log(&#x27;更新成功&#x27;);	&#125;&#125;);</span></span><br></pre></td></tr></table></figure>



<h3 id="查询（查）"><a href="#查询（查）" class="headerlink" title="查询（查）"></a>查询（查）</h3><p>查询所有：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询所有User.find(function(err,ret)&#123;	if(err)&#123;		console.log(&#x27;查询失败&#x27;);	&#125;else&#123;		console.log(ret);	&#125;&#125;);</span></span><br></pre></td></tr></table></figure>

<p>条件查询所有：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据条件查询User.find(&#123; username:&#x27;xiaoxiao&#x27; &#125;,function(err,ret)&#123;	if(err)&#123;		console.log(&#x27;查询失败&#x27;);	&#125;else&#123;		console.log(ret);	&#125;&#125;);</span></span><br></pre></td></tr></table></figure>

<p>条件查询单个：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按照条件查询单个，查询出来的数据是一个对象（&#123;&#125;）// 没有条件查询使用findOne方法，查询的是表中的第一条数据User.findOne(&#123;	username: &#x27;xiaoxiao&#x27;&#125;, function(err, ret) &#123;	if (err) &#123;		console.log(&#x27;查询失败&#x27;);	&#125; else &#123;		console.log(ret);	&#125;&#125;);</span></span><br></pre></td></tr></table></figure>

<h1 id="使用Node操作MySQL数据库"><a href="#使用Node操作MySQL数据库" class="headerlink" title="使用Node操作MySQL数据库"></a>使用Node操作MySQL数据库</h1><p>文档：<a href="https://www.npmjs.com/package/mysql">https://www.npmjs.com/package/mysql</a></p>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save  mysql</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入mysql包var mysql      = require(&#x27;mysql&#x27;);// 创建连接var connection = mysql.createConnection(&#123;  host     : &#x27;localhost&#x27;,	//本机  user     : &#x27;me&#x27;,		//账号root  password : &#x27;secret&#x27;,	//密码12345  database : &#x27;my_db&#x27;	//数据库名&#125;); // 连接数据库	（打开冰箱门）connection.connect(); //执行数据操作	（把大象放到冰箱）connection.query(&#x27;SELECT * FROM `users` &#x27;, function (error, results, fields) &#123;  if (error) throw error;//抛出异常阻止代码往下执行  // 没有异常打印输出结果  console.log(&#x27;The solution is: &#x27;,results);&#125;);//关闭连接	（关闭冰箱门）connection.end();</span></span><br></pre></td></tr></table></figure>





<h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>不成立的情况下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;    <span class="built_in">console</span>.log(<span class="number">1</span>);    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;        <span class="built_in">console</span>.log(<span class="number">2</span>);        <span class="keyword">var</span> ret = x + y;        <span class="keyword">return</span> ret;    &#125;,<span class="number">1000</span>);    <span class="built_in">console</span>.log(<span class="number">3</span>);    <span class="comment">//到这里执行就结束了，不会i等到前面的定时器，所以直接返回了默认值 undefined&#125;console.log(add(2,2));// 结果是 1 3 undefined 4</span></span><br></pre></td></tr></table></figure>

<p>使用回调函数解决：</p>
<p>回调函数：通过一个函数，获取函数内部的操作。（根据输入得到输出结果）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ret;<span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y,callback</span>)</span>&#123;    <span class="comment">// callback就是回调函数    // var x = 10;    // var y = 20;    // var callback = function(ret)&#123;console.log(ret);&#125;    console.log(1);    setTimeout(function()&#123;        var ret = x + y;        callback(ret);    &#125;,1000);    console.log(3);&#125;add(10,20,function(ret)&#123;    console.log(ret);&#125;);</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>​    凡是需要得到一个函数内部异步操作的结果（setTimeout,readFile,writeFile,ajax,readdir）</p>
<p>​    这种情况必须通过   回调函数 (异步API都会伴随着一个回调函数)</p>
<p>ajax:</p>
<p>基于原生XMLHttpRequest封装get方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oReq = <span class="keyword">new</span> XMLHttpRequest();<span class="comment">// 当请求加载成功要调用指定的函数oReq.onload = function()&#123;    console.log(oReq.responseText);&#125;oReq.open(&quot;GET&quot;, &quot;请求路径&quot;,true);oReq.send();</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">url,callback</span>)</span>&#123;    <span class="keyword">var</span> oReq = <span class="keyword">new</span> XMLHttpRequest();    <span class="comment">// 当请求加载成功要调用指定的函数    oReq.onload = function()&#123;        //console.log(oReq.responseText);        callback(oReq.responseText);    &#125;    oReq.open(&quot;GET&quot;, url,true);    oReq.send();&#125;get(&#x27;data.json&#x27;,function(data)&#123;    console.log(data);&#125;);</span></span><br></pre></td></tr></table></figure>



<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>callback  hell（回调地狱）:</p>
<p>文件的读取无法判断执行顺序（文件的执行顺序是依据文件的大小来决定的）(异步api无法保证文件的执行顺序)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);fs.readFile(<span class="string">&#x27;./data/a.text&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;	<span class="keyword">if</span>(err)&#123;		<span class="comment">// 1 读取失败直接打印输出读取失败		return console.log(&#x27;读取失败&#x27;);		// 2 抛出异常		// 		阻止程序的执行		// 		把错误信息打印到控制台		throw err;	&#125;	console.log(data);&#125;);fs.readFile(&#x27;./data/b.text&#x27;,&#x27;utf8&#x27;,function(err,data)&#123;	if(err)&#123;		// 1 读取失败直接打印输出读取失败		return console.log(&#x27;读取失败&#x27;);		// 2 抛出异常		// 		阻止程序的执行		// 		把错误信息打印到控制台		throw err;	&#125;	console.log(data);&#125;);</span></span><br></pre></td></tr></table></figure>

<p>通过回调嵌套的方式来保证顺序：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);fs.readFile(<span class="string">&#x27;./data/a.text&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;	<span class="keyword">if</span>(err)&#123;		<span class="comment">// 1 读取失败直接打印输出读取失败		return console.log(&#x27;读取失败&#x27;);		// 2 抛出异常		// 		阻止程序的执行		// 		把错误信息打印到控制台		throw err;	&#125;	console.log(data);	fs.readFile(&#x27;./data/b.text&#x27;,&#x27;utf8&#x27;,function(err,data)&#123;		if(err)&#123;			// 1 读取失败直接打印输出读取失败			return console.log(&#x27;读取失败&#x27;);			// 2 抛出异常			// 		阻止程序的执行			// 		把错误信息打印到控制台			throw err;		&#125;		console.log(data);		fs.readFile(&#x27;./data/a.text&#x27;,&#x27;utf8&#x27;,function(err,data)&#123;			if(err)&#123;				// 1 读取失败直接打印输出读取失败				return console.log(&#x27;读取失败&#x27;);				// 2 抛出异常				// 		阻止程序的执行				// 		把错误信息打印到控制台				throw err;			&#125;			console.log(data);		&#125;);	&#125;);&#125;);</span></span><br></pre></td></tr></table></figure>

<p>为了解决以上编码方式带来的问题（回调地狱嵌套），所以在EcmaScript6新增了一个API:</p>
<ul>
<li><p>Promise：承诺，保证     (深度变长度)</p>
</li>
<li><p>Promise本身不是异步的，但往往都是内部封装一个异步任务</p>
</li>
<li><p>Promise 容器：存放了一个异步任务，有两种状态（Pending）：</p>
<ul>
<li><p>Resolved：解决</p>
</li>
<li><p>Rejected：失败</p>
</li>
<li><p>两种状态只能变成其中一种</p>
</li>
<li><p>容器一旦创建，就开始执行里面的代码</p>
</li>
</ul>
</li>
</ul>
<p>基本语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在EcmaScript 6中新增了一个API Promise// Promise 是一个构造函数var fs = require(&#x27;fs&#x27;);// 1 创建Promise容器		resolve:解决   reject：失败var p1 = new Promise(function(resolve, reject) &#123;	fs.readFile(&#x27;./a.text&#x27;, &#x27;utf8&#x27;, function(err, data) &#123;		if (err) &#123;			// console.log(err);			// 把容器的Pending状态变为rejected			reject(err);		&#125; else &#123;			// console.log(data);			// 把容器的Pending状态变为resolve			resolve(1234);		&#125;	&#125;);&#125;);// 当p1成功了，然后就（then）做指定的操作// then方法接收的function就是容器中的resolve函数// 当你 return 123 后面就接收到 123,没有 return 后面收到的就是 undefined// 真正有用的是：我们可以 return 一个 Promise 对象p1	.then(function(data) &#123;		console.log(data);	&#125;, function(err) &#123;		console.log(&#x27;读取文件失败了&#x27;, err);	&#125;);</span></span><br></pre></td></tr></table></figure>

<p>链式循环：png</p>
<p>封装Promise的<code>readFile</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);<span class="function"><span class="keyword">function</span> <span class="title">pReadFile</span>(<span class="params">filePath</span>) </span>&#123;	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;		fs.readFile(filePath, <span class="string">&#x27;utf8&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;			<span class="keyword">if</span> (err) &#123;				reject(err);			&#125; <span class="keyword">else</span> &#123;				resolve(data);			&#125;		&#125;);	&#125;);&#125;pReadFile(<span class="string">&#x27;./a.txt&#x27;</span>)	.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;		<span class="built_in">console</span>.log(data);		<span class="keyword">return</span> pReadFile(<span class="string">&#x27;./b.txt&#x27;</span>);	&#125;)	.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;		<span class="built_in">console</span>.log(data);		<span class="keyword">return</span> pReadFile(<span class="string">&#x27;./a.txt&#x27;</span>);	&#125;)	.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;		<span class="built_in">console</span>.log(data);	&#125;)</span><br></pre></td></tr></table></figure>

<p>mongoose所有的API都支持Promise：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询所有User.find()	.then(function(data)&#123;        console.log(data)    &#125;)</span></span><br></pre></td></tr></table></figure>

<p>注册：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">User.findOne(&#123;<span class="attr">username</span>:<span class="string">&#x27;admin&#x27;</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">user</span>)</span>&#123;    <span class="keyword">if</span>(user)&#123;        <span class="built_in">console</span>.log(<span class="string">&#x27;用户已存在&#x27;</span>)    &#125; <span class="keyword">else</span> &#123;        <span class="keyword">new</span> User(&#123;             <span class="attr">username</span>:<span class="string">&#x27;aaa&#x27;</span>,             <span class="attr">password</span>:<span class="string">&#x27;123&#x27;</span>,             <span class="attr">email</span>:<span class="string">&#x27;fffff&#x27;</span>        &#125;).save(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;            <span class="built_in">console</span>.log(<span class="string">&#x27;注册成功&#x27;</span>);        &#125;)    &#125;&#125;)</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">User.findOne(&#123;    <span class="attr">username</span>:<span class="string">&#x27;admin&#x27;</span>&#125;)    .then(<span class="function"><span class="keyword">function</span>(<span class="params">user</span>)</span>&#123;        <span class="keyword">if</span>(user)&#123;            <span class="comment">// 用户已经存在不能注册            console.log(&#x27;用户已存在&#x27;);        &#125;        else&#123;            // 用户不存在可以注册            return new User(&#123;                username:&#x27;aaa&#x27;,                password:&#x27;123&#x27;,                email:&#x27;fffff&#x27;            &#125;).save();        &#125;    &#125;)    .then(funciton(ret)&#123;		console.log(&#x27;注册成功&#x27;);    &#125;)</span></span><br></pre></td></tr></table></figure>



<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>async函数</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="修改完代码自动重启"><a href="#修改完代码自动重启" class="headerlink" title="修改完代码自动重启"></a>修改完代码自动重启</h2><p>我们在这里可以使用一个第三方命名行工具：<code>nodemon</code>来帮助我们解决频繁修改代码重启服务器的问题。</p>
<p><code>nodemon</code>是一个基于Node.js开发的一个第三方命令行工具，我们使用的时候需要独立安装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#在任意目录执行该命令都可以#也就是说，所有需要 --<span class="built_in">global</span>安装的包都可以在任意目录执行npm install --<span class="built_in">global</span> nodemonnpm install -g nodemon#如果安装不成功的话，可以使用cnpm安装cnpm install -g nodemon</span><br></pre></td></tr></table></figure>

<p>安装完毕之后使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">node app.js#使用nodemonnodemon app.js</span><br></pre></td></tr></table></figure>

<p>只要是通过<code>nodemon</code>启动的服务，则他会监视你的文件变化，当文件发生变化的时候，会自动帮你重启服务器。</p>
<h2 id="封装异步API"><a href="#封装异步API" class="headerlink" title="封装异步API"></a>封装异步API</h2><p>回调函数：获取异步操作的结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">callback</span>)</span>&#123;    <span class="comment">// var callback = funtion(data)&#123; console.log(data); &#125;	setTimeout(function()&#123;        var data = &#x27;hello&#x27;;        callback(data);    &#125;,1000);&#125;// 如果需要获取一个函数中异步操作的结果，则必须通过回调函数的方式来获取fn(function(data)&#123;    console.log(data);&#125;)</span></span><br></pre></td></tr></table></figure>

<h2 id="数组的遍历方法，都是对函数作为一种参数"><a href="#数组的遍历方法，都是对函数作为一种参数" class="headerlink" title="数组的遍历方法，都是对函数作为一种参数"></a>数组的遍历方法，都是对函数作为一种参数</h2><h2 id="EcmaScript-6"><a href="#EcmaScript-6" class="headerlink" title="EcmaScript 6"></a>EcmaScript 6</h2><blockquote>
<p>参考文档：<a href="https://es6.ruanyifeng.com/">https://es6.ruanyifeng.com/</a></p>
</blockquote>
<h1 id="项目案例"><a href="#项目案例" class="headerlink" title="项目案例"></a>项目案例</h1><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.├- app.js				项目入口├- controllers/├- models/				存储数据模型（mongoose）	﹂ comment.js			评论数据模型	﹂ topic.js				话题数据模型	﹂ user.js				用户数据模型├- node_modules/		第三方包├- package.json		包描述文件├- package-lock.json	第三方包版本锁定文件├- public/				公共静态资源	﹂ css/					样式资源        · login.css		  		· main.css 		· markdown-github.css 		· setting.css	﹂ img/					媒体资源    ﹂ js/					脚本├- routes/				路由文件    ﹂ session.js			﹂ topic.js┖- views/				存储视图目录    ﹂ _layouts/        · home.html				主页面    ﹂ _partials/		公共模板        · header.html			公共头部模板		· footer.html			公共页脚模板		· settings-nav.html		公共设置导航条模板    ﹂ settings/        · admin.html		· profile.html    ﹂ topic/			操作页面        · edit.html				 编辑		· new.html				 添加        · show.html				 展示    ﹂ index.html		内容主体	﹂ login.html		登陆页面	﹂ register.html	注册页面</span><br></pre></td></tr></table></figure>

<h2 id="模板页"><a href="#模板页" class="headerlink" title="模板页"></a>模板页</h2><ul>
<li>子模板</li>
<li>模板继承</li>
</ul>
<h2 id="路由设计-1"><a href="#路由设计-1" class="headerlink" title="路由设计"></a>路由设计</h2><table>
<thead>
<tr>
<th>路由</th>
<th>方法</th>
<th>get参数</th>
<th>post参数</th>
<th>是否需要登录</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>/</td>
<td>get</td>
<td></td>
<td></td>
<td>否</td>
<td>渲染首页</td>
</tr>
<tr>
<td>/register(登录)</td>
<td>get</td>
<td></td>
<td></td>
<td>否</td>
<td>渲染注册页面</td>
</tr>
<tr>
<td>/register</td>
<td>post</td>
<td></td>
<td>email,nickname,password</td>
<td>否</td>
<td>处理注册请求</td>
</tr>
<tr>
<td>/login</td>
<td>get</td>
<td></td>
<td></td>
<td>是</td>
<td>渲染登陆界面</td>
</tr>
<tr>
<td>/login</td>
<td>post</td>
<td></td>
<td>email,password</td>
<td></td>
<td>处理登录请求</td>
</tr>
<tr>
<td>/loginout</td>
<td>get</td>
<td></td>
<td></td>
<td></td>
<td>处理退出请求</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="模型设计"><a href="#模型设计" class="headerlink" title="模型设计"></a>模型设计</h2><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h2><ul>
<li>创建目录结构</li>
<li>整合静态页-模板页<ul>
<li>include</li>
<li>block</li>
<li>extend</li>
</ul>
</li>
<li>设计用户登陆，退出，注册的路由</li>
<li>用户注册<ul>
<li>先处理客户端页面的内容（表单控件的name，收集表单数据，发起请求）</li>
<li>服务端<ul>
<li>获取从客户端收到的数据</li>
<li>操作数据库<ul>
<li>如果有错，发送500告诉客户端服务器错了‘</li>
<li>其他的根据业务发送不同的响应数据</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>登录</li>
<li>退出</li>
</ul>
<h1 id="Express中间件"><a href="#Express中间件" class="headerlink" title="Express中间件"></a>Express中间件</h1><h2 id="中间件的概念"><a href="#中间件的概念" class="headerlink" title="中间件的概念"></a>中间件的概念</h2><blockquote>
<p>参考文档：<a href="http://expressjs.com/en/guide/using-middleware.html">http://expressjs.com/en/guide/using-middleware.html</a></p>
</blockquote>
<p>中间件：把很复杂的事情分割成单个，然后依次有条理的执行。就是一个中间处理环节，有输入，有输出。</p>
<p>说的通俗易懂点儿，中间件就是一个（从请求到响应调用的方法）方法。</p>
<p>把数据从请求到响应分步骤来处理，每一个步骤都是一个中间处理环节。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);<span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);<span class="keyword">var</span> cookie = <span class="built_in">require</span>(<span class="string">&#x27;./expressPtoject/cookie&#x27;</span>);<span class="keyword">var</span> query = <span class="built_in">require</span>(<span class="string">&#x27;./expressPtoject/query&#x27;</span>);<span class="keyword">var</span> postBody = <span class="built_in">require</span>(<span class="string">&#x27;./expressPtoject/post-body&#x27;</span>);<span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;	<span class="comment">// 解析请求地址中的get参数	// var obj = url.parse(req.url,true);	// req.query = obj.query;	query(req,res);	//中间件		// 解析请求地址中的post参数	req.body = &#123;		foo:&#x27;bar&#x27;	&#125;&#125;);if(req.url === &#x27;xxx&#x27;)&#123;	// 处理请求	...&#125;server.listen(3000,function()&#123;	console.log(&#x27;3000 runing...&#x27;);&#125;);</span></span><br></pre></td></tr></table></figure>

<p>同一个请求对象所经过的中间件都是同一个请求对象和响应对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);<span class="keyword">var</span> app = express();app.get(<span class="string">&#x27;/abc&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;	<span class="comment">// 同一个请求的req和res是一样的，	// 可以前面存储下面调用	console.log(&#x27;/abc&#x27;);	// req.foo = &#x27;bar&#x27;;	req.body = &#123;		name:&#x27;xiaoxiao&#x27;,		age:18	&#125;	next();&#125;);app.get(&#x27;/abc&#x27;,function(req,res,next)&#123;	// console.log(req.foo);	console.log(req.body);	console.log(&#x27;/abc&#x27;);&#125;);app.listen(3000, function() &#123;	console.log(&#x27;app is running at port 3000.&#x27;);&#125;);</span></span><br></pre></td></tr></table></figure>



<h2 id="中间件的分类"><a href="#中间件的分类" class="headerlink" title="中间件的分类:"></a>中间件的分类:</h2><h3 id="1-1-应用程序级别的中间件"><a href="#1-1-应用程序级别的中间件" class="headerlink" title="1.1 应用程序级别的中间件"></a>1.1 应用程序级别的中间件</h3><p>万能匹配（不关心任何请求路径和请求方法的中间件）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;Time&#x27;</span>,<span class="built_in">Date</span>.now());    next();&#125;);</span><br></pre></td></tr></table></figure>

<p>关心请求路径和请求方法的中间件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">&#x27;/a&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;Time&#x27;</span>,<span class="built_in">Date</span>.now());    next();&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="路由级别的中间件"><a href="#路由级别的中间件" class="headerlink" title="路由级别的中间件"></a>路由级别的中间件</h3><p>严格匹配请求路径和请求方法的中间件</p>
<p>get:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;	res.send(<span class="string">&#x27;get&#x27;</span>);&#125;);</span><br></pre></td></tr></table></figure>

<p>post：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.post(<span class="string">&#x27;/a&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;	res.send(<span class="string">&#x27;post&#x27;</span>);&#125;);</span><br></pre></td></tr></table></figure>

<p>put:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.put(<span class="string">&#x27;/user&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;	res.send(<span class="string">&#x27;put&#x27;</span>);&#125;);</span><br></pre></td></tr></table></figure>

<p>delete:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.delete(<span class="string">&#x27;/delete&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;	res.send(<span class="string">&#x27;delete&#x27;</span>);&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="总"><a href="#总" class="headerlink" title="总"></a>总</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);<span class="keyword">var</span> app = express();<span class="comment">// 中间件：处理请求，本质就是个函数// 在express中，对中间件有几种分类// 1 不关心任何请求路径和请求方法的中间件// 也就是说任何请求都会进入这个中间件// 中间件本身是一个方法，该方法接收三个参数// Request 请求对象// Response 响应对象// next 下一个中间件// // 全局匹配中间件// app.use(function(req, res, next) &#123;// 	console.log(&#x27;1&#x27;);// 	// 当一个请求进入中间件后// 	// 如果需要请求另外一个方法则需要使用next（）方法// 	next();// 	// next是一个方法，用来调用下一个中间件//  // 注意：next（）方法调用下一个方法的时候，也会匹配（不是调用紧挨着的哪一个）// &#125;);// app.use(function(req, res, next) &#123;// 	console.log(&#x27;2&#x27;);// &#125;);// // 2 关心请求路径的中间件// // 以/xxx开头的中间件// app.use(&#x27;/a&#x27;,function(req, res, next) &#123;// 	console.log(req.url);// &#125;);// 3 严格匹配请求方法和请求路径的中间件app.get(&#x27;/&#x27;,function()&#123;	console.log(&#x27;/&#x27;);&#125;);app.post(&#x27;/a&#x27;,function()&#123;	console.log(&#x27;/a&#x27;);&#125;);app.listen(3000, function() &#123;	console.log(&#x27;app is running at port 3000.&#x27;);&#125;);</span></span><br></pre></td></tr></table></figure>

<h2 id="错误处理中间件"><a href="#错误处理中间件" class="headerlink" title="错误处理中间件"></a>错误处理中间件</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">err,req,res,next</span>)</span>&#123;    <span class="built_in">console</span>.error(err,stack);    res.status(<span class="number">500</span>).send(<span class="string">&#x27;Something broke&#x27;</span>);&#125;);</span><br></pre></td></tr></table></figure>

<p>配置使用404中间件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 放在最后，如果前面没有任何中间件能匹配处理，则进入这个404app.use(function(req,res)&#123;    res.render(&#x27;404.html&#x27;);&#125;);</span></span><br></pre></td></tr></table></figure>

<p>配置全局错误处理中间件:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/a&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;	fs.readFile(<span class="string">&#x27;.a/bc&#x27;</span>, <span class="function"><span class="title">funtion</span>(<span class="params"></span>)</span> &#123;		<span class="keyword">if</span> (err) &#123;        	<span class="comment">// 当调用next()传参后，则直接进入到全局错误处理中间件方法中（4个参数）        	// 当发生全局错误的时候，我们可以调用next传递错误对象        	// 然后被全局错误处理中间件匹配到并进行处理        	// 就不需要每处理一次业务都要判断err			next(err);		&#125;	&#125;)&#125;);//全局错误处理中间件app.use(function(err,req,res,next)&#123;    res.status(500).json(&#123;        err_code:500,        message:err.message    &#125;);&#125;);</span></span><br></pre></td></tr></table></figure>





<h2 id="内置中间件"><a href="#内置中间件" class="headerlink" title="内置中间件"></a>内置中间件</h2><ul>
<li>express.static(提供静态文件)<ul>
<li><a href="http://expressjs.com/en/starter/static-files.html#serving-static-files-in-express">http://expressjs.com/en/starter/static-files.html#serving-static-files-in-express</a></li>
</ul>
</li>
</ul>
<h2 id="第三方中间件"><a href="#第三方中间件" class="headerlink" title="第三方中间件"></a>第三方中间件</h2><blockquote>
<p>参考文档：<a href="http://expressjs.com/en/resources/middleware.html">http://expressjs.com/en/resources/middleware.html</a></p>
</blockquote>
<ul>
<li>body-parser</li>
<li>compression</li>
<li>cookie-parser</li>
<li>mogran</li>
<li>response-time</li>
<li>server-static</li>
<li>session</li>
</ul>
<h1 id="项目2-0"><a href="#项目2-0" class="headerlink" title="项目2.0"></a>项目2.0</h1><h2 id="目录结构-1"><a href="#目录结构-1" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.├- app.js	项目入口├- controllers/├- models/	存储数据模型（mongoose）	﹂ comment.js	评论数据模型	﹂ topic.js		话题数据模型	﹂ user.js		用户数据模型├- node_modules/ 第三方包├- package.json	 包描述文件├- package-lock.json	第三方包版本锁定文件├- public/	公共静态资源	﹂ css/	样式资源        · login.css		  		· main.css 		· markdown-github.css 		· setting.css	﹂ img/	媒体资源    ﹂ js/	脚本资源├- routes/	路由文件    ﹂ session.js			﹂ topic.js┖- views/	存储视图目录    ﹂ _layouts/        · home.html	主页面    ﹂ _partials/		公共模板        · header.html	公共头部模板		· footer.html	公共页脚模板		· settings-nav.html	共设置导航条模板    ﹂ settings/        · admin.html		· profile.html    ﹂ topic/			操作页面        · edit.html	编辑		· new.html	添加        · show.html	展示    ﹂ index.html 内容主体	﹂ login.html 登陆页面	﹂ register.html	注册页面</span><br></pre></td></tr></table></figure>

<h2 id="模板页-1"><a href="#模板页-1" class="headerlink" title="模板页"></a>模板页</h2><ul>
<li>子模板</li>
<li>模板继承</li>
</ul>
<h2 id="路由设计-2"><a href="#路由设计-2" class="headerlink" title="路由设计"></a>路由设计</h2><table>
<thead>
<tr>
<th>路由</th>
<th>方法</th>
<th>get参数</th>
<th>post参数</th>
<th>是否需要登录</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>/</td>
<td>get</td>
<td></td>
<td></td>
<td>否</td>
<td>渲染首页</td>
</tr>
<tr>
<td>/register(登录)</td>
<td>get</td>
<td></td>
<td></td>
<td>否</td>
<td>渲染注册页面</td>
</tr>
<tr>
<td>/register</td>
<td>post</td>
<td></td>
<td>email,nickname,password</td>
<td>否</td>
<td>处理注册请求</td>
</tr>
<tr>
<td>/login</td>
<td>get</td>
<td></td>
<td></td>
<td>是</td>
<td>渲染登陆界面</td>
</tr>
<tr>
<td>/login</td>
<td>post</td>
<td></td>
<td>email,password</td>
<td></td>
<td>处理登录请求</td>
</tr>
<tr>
<td>/loginout</td>
<td>get</td>
<td></td>
<td></td>
<td></td>
<td>处理退出请求</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="模型设计-1"><a href="#模型设计-1" class="headerlink" title="模型设计"></a>模型设计</h2><h4 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h4><ul>
<li><p>页面设计</p>
<ul>
<li>一体页</li>
</ul>
</li>
<li></li>
</ul>
<h2 id="功能实现-1"><a href="#功能实现-1" class="headerlink" title="功能实现"></a>功能实现</h2><h1 id="NodeJS2-0"><a href="#NodeJS2-0" class="headerlink" title="NodeJS2.0"></a>NodeJS2.0</h1><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="命令行窗口"><a href="#命令行窗口" class="headerlink" title="命令行窗口"></a>命令行窗口</h3><ul>
<li><p>cmd、终端、shell、dos</p>
</li>
<li><p>常用指令</p>
<ul>
<li><p>dir</p>
<ul>
<li>列出当前文件夹下所有文件</li>
</ul>
</li>
<li><p>cd</p>
</li>
<li><p>md  目录名</p>
<ul>
<li>创建文件夹</li>
</ul>
</li>
<li><p>rd  目录名</p>
<ul>
<li>删除文件夹</li>
</ul>
</li>
<li><p>文件名</p>
<ul>
<li>打开文件</li>
</ul>
</li>
</ul>
</li>
<li><p>环境变量</p>
<ul>
<li><p>即windows系统的变量</p>
</li>
<li><p>path</p>
<ul>
<li><p>系统寻找文件的顺序（dos）</p>
<ul>
<li>当前目录下</li>
<li>→环境变量path</li>
</ul>
</li>
<li><p>类似作用域链</p>
</li>
</ul>
</li>
<li><p>修改环境变量后需要重启dos</p>
</li>
</ul>
</li>
</ul>
<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><ul>
<li><p>进程</p>
<ul>
<li><p>负责为程序的运行提供必备的环境</p>
<ul>
<li>相当于工厂车间</li>
</ul>
</li>
</ul>
</li>
<li><p>线程</p>
<ul>
<li><p>计算机中最小的计算单位，负责执行进程中的程序</p>
<ul>
<li>相当于车间里的工人</li>
</ul>
</li>
<li><p>单线程</p>
</li>
<li><p>多线程</p>
<ul>
<li>并发问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="关于性能"><a href="#关于性能" class="headerlink" title="关于性能"></a>关于性能</h3><ul>
<li><p>客户端</p>
</li>
<li><p>服务器端</p>
<ul>
<li><p>多线程</p>
</li>
<li><p>nodejs</p>
<ul>
<li>单线程</li>
</ul>
</li>
</ul>
</li>
<li><p>数据库</p>
<ul>
<li>通过磁盘调用操作数据库</li>
</ul>
</li>
</ul>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>nodejs是能在服务器端运行js的开放源代码、跨平台的js运行环境</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>采用Google开发的V8引擎运行js代码</li>
<li>单线程服务器</li>
<li>使用事件驱动</li>
<li>非阻塞</li>
<li>异步I/O模型</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li><p>web服务API</p>
<ul>
<li>REST</li>
</ul>
</li>
<li><p>实时多人游戏</p>
</li>
</ul>
<h3 id="关于node版本"><a href="#关于node版本" class="headerlink" title="关于node版本"></a>关于node版本</h3><ul>
<li>奇数为开发版，偶数为稳定版</li>
</ul>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="使用node执行js文件"><a href="#使用node执行js文件" class="headerlink" title="使用node执行js文件"></a>使用node执行js文件</h3><ul>
<li><p>进入当前文件所在目录</p>
<ul>
<li><p>快捷方法</p>
<ul>
<li>在文件地址栏输入 cmd</li>
<li>node 文件名</li>
</ul>
</li>
</ul>
</li>
<li><p>在编译器终端</p>
<ul>
<li>node 文件名</li>
</ul>
</li>
<li><p>编译器直接run</p>
</li>
</ul>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul>
<li><p>特点</p>
<ul>
<li>大化小</li>
<li>避免耦合</li>
<li>增加复用</li>
</ul>
</li>
<li><p>ES标准缺陷</p>
<ul>
<li>没有模块系统（ES5）</li>
<li>标准库较少</li>
<li>没有标准接口</li>
<li>缺乏管理系统</li>
</ul>
</li>
</ul>
<h3 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h3><ul>
<li><p>简介</p>
<ul>
<li><p>弥补当前js没有标准的缺陷</p>
</li>
<li><p>对模块的定义</p>
<ul>
<li>模块引用</li>
<li>模块定义</li>
<li>模块标识</li>
</ul>
</li>
</ul>
</li>
<li><p>定义模块</p>
<ul>
<li>创建js文件</li>
<li>在node中一个js文件就是一个模块</li>
</ul>
</li>
<li><p>模块标识</p>
<ul>
<li><p>定义</p>
<ul>
<li>找到模块的方式</li>
<li>使用require引入外部模块时，使用的就是模块标识，通过模块标识来找到指定的标识</li>
</ul>
</li>
<li><p>模块分类</p>
<ul>
<li><p>核心模块</p>
<ul>
<li><p>由node引擎提供的模块</p>
</li>
<li><p>模块标识</p>
<ul>
<li>模块名</li>
</ul>
</li>
</ul>
</li>
<li><p>文件模块</p>
<ul>
<li><p>由用户自己创建的模块</p>
</li>
<li><p>模块标识</p>
<ul>
<li>文件路径</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>引用模块</p>
<ul>
<li><p>require（）</p>
<ul>
<li><p>参数</p>
<ul>
<li>文件路径</li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li>相对路径必须以  ./或 ../开头</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>该函数会返回一个对象，该对象代表引入的模块</li>
</ul>
</li>
</ul>
</li>
<li><p>在node中，每一个文件中的js代码都是独立运行在一个函数中且传入了5个实参，而不是全局作用域</p>
<ul>
<li><p>所以一个模块中的变量和函数在其他模块中无法访问</p>
</li>
<li><p>console.log(arguments)//证明一个模块的确是运行在函数里</p>
</li>
<li><p>arguments.callee</p>
<ul>
<li>该属性保存的是当前正在执行的函数对象</li>
</ul>
</li>
</ul>
</li>
<li><p>node执行模块中的代码时</p>
<ul>
<li><p>最顶部添加</p>
<ul>
<li>function (exports, require, module, __filename, __dirname) {</li>
</ul>
</li>
<li><p>最底部添加</p>
<ul>
<li>}</li>
</ul>
</li>
</ul>
</li>
<li><p>五个参数</p>
<ul>
<li><p>exports</p>
<ul>
<li><p>该对象用来向外部暴露属性或方法</p>
</li>
<li><p>语法</p>
<ul>
<li>exports . x</li>
</ul>
</li>
</ul>
</li>
<li><p>require</p>
<ul>
<li>函数，用来引入外部的模块</li>
</ul>
</li>
<li><p>module</p>
<ul>
<li><p>代表的是当前模块本身</p>
</li>
<li><p>exports就是module的属性</p>
<ul>
<li>即module . exports = exports，本质相同</li>
</ul>
</li>
</ul>
</li>
<li><p>__filename</p>
<ul>
<li>当前文件完整路径</li>
</ul>
</li>
<li><p>__dirname</p>
<ul>
<li>当前模块所在文件夹的完整路径</li>
</ul>
</li>
</ul>
</li>
<li><p>关于</p>
<ul>
<li><p>module .exports</p>
<ul>
<li><p>批量导入</p>
<ul>
<li>module.exports = {<br>}</li>
</ul>
</li>
<li><p>可以通过 . 的形式，也可以直接赋值</p>
<ul>
<li>module.exports = { }</li>
<li>model.exports . xxx = xxx</li>
</ul>
</li>
</ul>
</li>
<li><p>exports</p>
<ul>
<li><p>通过exports只能使用 . 的方式向外暴露内部变量</p>
<ul>
<li>exports . xxx = xxx</li>
</ul>
</li>
<li><p>改变量，不是改对象</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>global</p>
<ul>
<li><p>定义</p>
<ul>
<li>node的全局对象，与window类似</li>
<li>在全局中创建的变量/函数都会作为global的属性/方法保存</li>
</ul>
</li>
<li><p>创建</p>
<ul>
<li>去掉var</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="包package"><a href="#包package" class="headerlink" title="包package"></a>包package</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><ul>
<li><p>规范的模块</p>
<ul>
<li>将一组相关的模块组合到一起</li>
</ul>
</li>
<li><p>本质：文件夹</p>
</li>
</ul>
<h3 id="CommonJS的包规范组成"><a href="#CommonJS的包规范组成" class="headerlink" title="CommonJS的包规范组成"></a>CommonJS的包规范组成</h3><ul>
<li><p>包结构</p>
<ul>
<li><p>用于组织包中的各种文件（压缩文件）</p>
</li>
<li><p>规范目录组成</p>
<ul>
<li><p>package.json</p>
<ul>
<li>描述文件（说明书）</li>
</ul>
</li>
<li><p>bin</p>
<ul>
<li>可执行二进制文件</li>
</ul>
</li>
<li><p>lib</p>
<ul>
<li>js代码</li>
</ul>
</li>
<li><p>doc</p>
<ul>
<li>文档</li>
</ul>
</li>
<li><p>test</p>
<ul>
<li>单元测试</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>包描述文件</p>
<ul>
<li><p>表达非代码的相关信息，放在包的根目录下</p>
</li>
<li><p>package.json</p>
<ul>
<li>name、version、description…</li>
<li>不能写注释</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="npm-1"><a href="#npm-1" class="headerlink" title="npm"></a>npm</h3><ul>
<li><p>简介</p>
<ul>
<li>Node Package Manager包管理工具</li>
<li>CommonJS包规范是理论，npm是其实践之一</li>
</ul>
</li>
<li><p>功能</p>
<ul>
<li>帮助node完成第三方模块的发布、安装和依赖等</li>
</ul>
</li>
<li><p>命令</p>
<ul>
<li><p>npm -v</p>
<ul>
<li>查npm版本</li>
</ul>
</li>
<li><p>npm -version</p>
<ul>
<li>所有模块版本</li>
</ul>
</li>
<li><p>npm search 包名</p>
<ul>
<li>搜索包</li>
</ul>
</li>
<li><p>npm init</p>
<ul>
<li>初始化，创建package.json文件</li>
</ul>
</li>
<li><p>npm remove / r 包名</p>
<ul>
<li>删除包</li>
</ul>
</li>
<li><p>npm install / i 包名</p>
<ul>
<li>安装包</li>
</ul>
</li>
<li><p>npm install 包名  –save </p>
<ul>
<li>安装包并添加到依赖</li>
<li>将包版本直接添加到package.json文件的dependencies中</li>
</ul>
</li>
<li><p>npm install</p>
<ul>
<li>下载当前项目所依赖的包</li>
<li>通过package.josn文件的dependencies寻找</li>
</ul>
</li>
<li><p>npm install 包名 -g</p>
<ul>
<li><p>全局安装包</p>
</li>
<li><p>一般是一些工具</p>
<ul>
<li>用于计算机中，而不是项目中</li>
</ul>
</li>
</ul>
</li>
<li><p>npm install 包名 -registry=地址</p>
<ul>
<li>从镜像原安装</li>
</ul>
</li>
<li><p>npm  config set registry 地址</p>
<ul>
<li>设置镜像源</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="配置cnpm"><a href="#配置cnpm" class="headerlink" title="配置cnpm"></a>配置cnpm</h3><ul>
<li><p>切换为国内镜像源</p>
<ul>
<li>淘宝npm镜像</li>
</ul>
</li>
<li><p>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p>
</li>
<li><p>其他命令与npm相似</p>
</li>
</ul>
<h3 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h3><ul>
<li><p>通过npm下载的包都放到node_module文件夹中</p>
<ul>
<li>直接通过包名引入即可</li>
</ul>
</li>
<li><p>node搜索包的流程</p>
<ul>
<li>通过包名引入时，首先在当前目录的node_module中寻找</li>
<li>如果没有则去上一级的node_module寻找</li>
<li>直到找到磁盘的根目录，如果依然没有，报错</li>
</ul>
</li>
</ul>
<h2 id="Buffer缓冲区"><a href="#Buffer缓冲区" class="headerlink" title="Buffer缓冲区"></a>Buffer缓冲区</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><ul>
<li><p>概念</p>
<ul>
<li><p>buffer结构与数组相似，操作也类似</p>
</li>
<li><p>专门用来存储二进制文件的数组，以16进制显示</p>
<ul>
<li><p>元素范围：00 ~ ff</p>
</li>
<li><p>实际范围：00000000~11111111</p>
<ul>
<li>0~255(十进制)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li>接收用户发送的数据，暂存</li>
</ul>
</li>
<li><p>本质</p>
<ul>
<li><p>直接操作内存空间</p>
<ul>
<li>开辟连续的内存空间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h3><ul>
<li><p>创建</p>
<ul>
<li><p>Buffer.from</p>
<ul>
<li>保存字符串到buffer中</li>
<li>var buf = Buffer.from(str)</li>
</ul>
</li>
<li><p>new Buffer（1024）</p>
<ul>
<li>创建一个指定长度的buffer</li>
<li>尽量不用此构造函数</li>
</ul>
</li>
<li><p>Buffer.alloc（1024）</p>
<ul>
<li>创建指定字节的buffer</li>
</ul>
</li>
<li><p>Buffer.allocUnsafe（10）</p>
<ul>
<li><p>特性</p>
<ul>
<li>可能含有敏感数据</li>
<li>分配空间时，不会清空之前的数据</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>可能泄露数据</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>性能好</li>
</ul>
</li>
</ul>
</li>
<li><p> …</p>
</li>
</ul>
</li>
<li><p>添加</p>
<ul>
<li>buf [0] = 254</li>
</ul>
</li>
<li><p>读取</p>
<ul>
<li><p>buf[0]</p>
</li>
<li><p>只要数字在控制台输出或页面中输出一定是10进制</p>
<ul>
<li><p>若需要转换成其他</p>
<ul>
<li>toString（16）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>遍历</p>
<ul>
<li>同数组</li>
</ul>
</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li><p>length</p>
<ul>
<li><p>占用内存的大小（字节数）</p>
</li>
<li><p>区别字符串length</p>
<ul>
<li>表示字符串的长度</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="fs-文件系统"><a href="#fs-文件系统" class="headerlink" title="fs  文件系统"></a>fs  文件系统</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><ul>
<li>文件系统简单来说就是通过Node操作系统中的文件</li>
<li>该模块提供了一些标准文件访问API来打开、读取、写入文件，以及与其交互</li>
</ul>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>fs模块所有操作都有同步与异步可选择</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>引入</p>
<ul>
<li>var fs = require(‘fs’)</li>
</ul>
</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><p>文件写入</p>
<ul>
<li><p>同步文件写入</p>
<ul>
<li><p>同步文件系统会阻塞程序的执行</p>
<ul>
<li>除非操作完毕，否则不会向下执行代码</li>
</ul>
</li>
<li><p>步骤</p>
<ul>
<li><p>打开文件</p>
<ul>
<li><p>fs.openSync()</p>
<ul>
<li><p>参数</p>
<ul>
<li><p>path：要打开文件的路径</p>
</li>
<li><p>flags：打开文件要做的操作的类型（w，r）</p>
<ul>
<li><p>w</p>
<ul>
<li>覆盖写</li>
</ul>
</li>
<li><p>a</p>
<ul>
<li>追加写</li>
</ul>
</li>
<li><p>r+</p>
<ul>
<li>读写文件，追加，文件不存在则报错</li>
</ul>
</li>
</ul>
</li>
<li><p>[mode]：设置文件的操作权限，windows一般不写</p>
</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>该方法会返回一个文件的描述符</li>
<li>可通过该描述符对文件进行操作</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>写入内容</p>
<ul>
<li><p>fs.writeSync()</p>
<ul>
<li><p>参数</p>
<ul>
<li><p>fd</p>
<ul>
<li>文件描述符</li>
</ul>
</li>
<li><p>string</p>
<ul>
<li>要写入的内容</li>
</ul>
</li>
<li><p>mode</p>
<ul>
<li>写入的起始位置</li>
</ul>
</li>
<li><p>encoding</p>
<ul>
<li>写入的编码</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>保存并关闭文件</p>
<ul>
<li><p>fs.closeSync(3)</p>
<ul>
<li><p>参数</p>
<ul>
<li><p>fd</p>
<ul>
<li>文件描述符</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>异步文件写入</p>
<ul>
<li><p>异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回</p>
</li>
<li><p>步骤</p>
<ul>
<li><p>打开文件</p>
<ul>
<li><p>open</p>
<ul>
<li><p>参数</p>
<ul>
<li><p>path：路径</p>
</li>
<li><p>flags：操作类型</p>
</li>
<li><p>callback：回调函数</p>
<ul>
<li><p>参数</p>
<ul>
<li><p>err：错误对象</p>
<ul>
<li>没有错误则为null（错误优先思想）</li>
</ul>
</li>
<li><p>fd：文件描述符</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>异步方法没有返回值</li>
<li>异步调用的方法，结果都是通过回调函数返回的</li>
</ul>
</li>
<li><p>open时，会将该任务交给后台线程池，继续异步执行open之后的代码，当open操作完成后，通过回调函数返回</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>写入文件</p>
<ul>
<li><p>write</p>
<ul>
<li><p>在回调函数里面操作</p>
</li>
<li><p>参数</p>
<ul>
<li><p>fd</p>
</li>
<li><p>string：内容</p>
</li>
<li><p>callback：回调</p>
<ul>
<li><p>参数</p>
<ul>
<li>err</li>
<li>written：被写入的字符串的字节数</li>
<li>string：写入的内容</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>关闭文件</p>
<ul>
<li><p>close</p>
<ul>
<li><p>参数</p>
<ul>
<li><p>fd</p>
</li>
<li><p>callback</p>
<ul>
<li><p>参数</p>
<ul>
<li>err</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>简单文件写入</p>
<ul>
<li><p>步骤</p>
<ul>
<li><p>异步</p>
<ul>
<li><p>fs.writeFile()</p>
<ul>
<li><p>参数</p>
<ul>
<li><p>file：操作文件路径</p>
</li>
<li><p>data：指定要写入的数据</p>
</li>
<li><p>【options】</p>
<ul>
<li><p>选项，配置信息，对写入进行一些设置</p>
</li>
<li><p>一般需要一个对象作为参数</p>
<ul>
<li>encoding：编码</li>
<li>mode：0o666</li>
<li>flag：‘w’</li>
</ul>
</li>
</ul>
</li>
<li><p>callback</p>
<ul>
<li><p>写入完成以后执行的操作</p>
</li>
<li><p>参数</p>
<ul>
<li><p>err</p>
<ul>
<li>错误对象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>同步</p>
<ul>
<li><p>fs.writeFileSync()</p>
<ul>
<li><p>参数</p>
<ul>
<li><p>file：操作文件路径</p>
</li>
<li><p>data：指定要写入的数据</p>
</li>
<li><p>【options】</p>
<ul>
<li>选项，配置信息，对写入进行一些设置</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>流式文件写入</p>
<ul>
<li><p>概念</p>
<ul>
<li><p>特点</p>
<ul>
<li>非一次性写入文件</li>
<li>避免占用内存</li>
<li>适用大型文件</li>
</ul>
</li>
<li><p>对比其他文件写入</p>
<ul>
<li>容易内存溢出</li>
<li>性能差</li>
</ul>
</li>
</ul>
</li>
<li><p>步骤</p>
<ul>
<li><p>创建一个可写流（接通水管）</p>
<ul>
<li><p>fs.createWriteStream()</p>
<ul>
<li><p>参数</p>
<ul>
<li>path</li>
<li>【option】</li>
</ul>
</li>
<li><p>返回值</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>写入内容</p>
<ul>
<li><p>write（）</p>
<ul>
<li><p>参数</p>
<ul>
<li>字符串</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>关闭流</p>
<ul>
<li><p>通过监听流的open和close事件来监听流的打开和关闭</p>
</li>
<li><p>补充</p>
<ul>
<li><p>once（事件字符串，回调函数）</p>
<ul>
<li>为对象绑定一个一次性的事件，触发后自动失效</li>
</ul>
</li>
<li><p>on（事件字符串，回调函数）</p>
<ul>
<li>绑定一个事件</li>
</ul>
</li>
</ul>
</li>
<li><p>end（）</p>
<ul>
<li>输送完后断“流”</li>
</ul>
</li>
<li><p>close（）</p>
<ul>
<li>可能没送完就断“流”（旧版本）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>文件读取</p>
<ul>
<li><p>同步文件读取</p>
</li>
<li><p>异步文件读取</p>
</li>
<li><p>简单文件读取</p>
<ul>
<li><p>同步</p>
<ul>
<li><p>fs.readFile()</p>
<ul>
<li><p>参数</p>
<ul>
<li>path，【options，】callback（err，data）</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li><p>返回一个buffer</p>
<ul>
<li>提高通用性</li>
<li>比如读取一张图片</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>异步</p>
<ul>
<li><p>fs.readFileSync()</p>
<ul>
<li><p>参数</p>
<ul>
<li>path，【options，】callback</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>流式文件读取</p>
<ul>
<li><p>特点</p>
<ul>
<li>适用于大文件</li>
<li>分多次读取文件</li>
</ul>
</li>
<li><p>步骤</p>
<ul>
<li><p>创建一个可读流</p>
<ul>
<li>var rs = fs.createReadStream(“hello2.txt”)</li>
</ul>
</li>
<li><p>监听流的开启和关闭</p>
</li>
<li><p>读取</p>
<ul>
<li>如果要读取一个可读流中的数据，必须为可读流绑定一个data事件，data事件绑定完毕，会自动开始读取数据</li>
</ul>
</li>
</ul>
</li>
<li><p>pipe（）</p>
<ul>
<li><p>将可读流中的内容直接输出到可写流中</p>
</li>
<li><p>简写（复制文件）</p>
<ul>
<li>var fs = require(‘fs’)<br>//创建一个可读流<br>var rs = fs.createReadStream(“hello2.txt”)<br>//创建一个可写流<br>var ws = fs.createWriteStream(‘a.txt’)<br>rs.pipe(ws)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><ul>
<li><p>existsSync()</p>
<ul>
<li>验证文件路径是否存在</li>
<li>只有同步（立即获取结果）</li>
</ul>
</li>
<li><p>stat( path,  callback（err，stat）)</p>
<ul>
<li><p>获取文件状态</p>
</li>
<li><p>返回一个对象，保存当前对象状态的信息</p>
</li>
<li><p>属性</p>
<ul>
<li>size</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
<li><p>unlink（path，callback）/unlinkSync（path）</p>
<ul>
<li>删除文件</li>
</ul>
</li>
<li><p>readdir（path[,  option], callback(err,  files)）</p>
<ul>
<li><p>读取一个目录的 目录结构</p>
</li>
<li><p>回调参数</p>
<ul>
<li><p>files</p>
<ul>
<li>是一个字符串数组，每一个元素就是一个文件夹或文件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>truncate(path , len, callback)</p>
<ul>
<li>截断文件</li>
<li>len：截断后的文件大小</li>
</ul>
</li>
<li><p>mkdir（path[，mode]，callback）</p>
<ul>
<li>创建目录</li>
</ul>
</li>
<li><p>rmdir（path）</p>
<ul>
<li>删除文件夹</li>
</ul>
</li>
<li><p>rename（oldpath，newpath，callback）</p>
<ul>
<li>重命名文件</li>
<li>改变路径</li>
</ul>
</li>
<li><p>watchFile（filename[,optin], listener）</p>
<ul>
<li><p>监视文件的修改，耗性能</p>
</li>
<li><p>参数</p>
<ul>
<li><p>文件名</p>
</li>
<li><p>配置选项</p>
<ul>
<li><p>interval：1000</p>
<ul>
<li>监听频率（1s刷新一次）</li>
</ul>
</li>
</ul>
</li>
<li><p>回调函数</p>
<ul>
<li><p>当文件发送变化时执行</p>
</li>
<li><p>参数</p>
<ul>
<li><p>curr</p>
<ul>
<li>当前文件状态stat</li>
</ul>
</li>
<li><p>prev</p>
<ul>
<li>修改前文件状态stat</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><em>XMind: ZEN - Trial Version</em></p>
]]></content>
      <categories>
        <category>code</category>
        <category>backend</category>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>NodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title>React</title>
    <url>/2021/07/22/react/</url>
    <content><![CDATA[<blockquote>
<p>react学习笔记</p>
</blockquote>
<span id="more"></span>

<h1 id="1-React简介"><a href="#1-React简介" class="headerlink" title="1. React简介"></a>1. React简介</h1><blockquote>
<p>React官网：<a href="https://react.docschina.org/docs/add-react-to-a-website.html">https://react.docschina.org/docs/add-react-to-a-website.html</a></p>
</blockquote>
<p><strong>react是什么？</strong></p>
<p>React用于构建用户<strong>界面</strong>的JS库。<strong>是一个将数据渲染为HTML视图的开源JS库。</strong></p>
<p><strong>谁开发的？</strong></p>
<p>Facebook开发开源</p>
<p><strong>为什么学？</strong></p>
<p>1.原生JS操作DOM繁琐，效率低（DOM Api操作ui）</p>
<p>2.使用JS直接操作DOM,浏览器会进行大量的<strong>重绘重排</strong></p>
<p>3.原生JS没有<strong>组件化</strong>编码方案，代码复用低</p>
<p><strong>库与框架的区别？</strong></p>
<blockquote>
<p>在学习之前最好看一下关于npm的知识：<a href="https://blog.csdn.net/qq_25502269/article/details/79346545">npm</a></p>
</blockquote>
<h1 id="2-React入门"><a href="#2-React入门" class="headerlink" title="2. React入门"></a>2. React入门</h1><h2 id="React-基础案例"><a href="#React-基础案例" class="headerlink" title="React 基础案例"></a>React 基础案例</h2><p>1.先导入三个包：</p>
<p>【先引入react.development.js，后引入react-dom.development.js】</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">react.development.js</span><br><span class="line">react-dom.development.js</span><br><span class="line">babel.min.js </span><br></pre></td></tr></table></figure>

<p>2.创建一个容器</p>
<p>3.创建虚拟DOM，渲染到容器中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 准备好容器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入依赖 ,引入的时候，必须就按照这个步骤--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/react.development.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/react-dom.development.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/babel.min.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--这里使用了babel用来解析jsx语法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 1.创建虚拟DOM</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> VDOM = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>  <span class="comment">//这个地方使用的是JSX语法，不需要加&quot;&quot;</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 2.渲染，如果有多个渲染同一个容器，后面的会将前面的覆盖掉</span></span></span><br><span class="line"><span class="javascript">        ReactDOM.render(VDOM,<span class="built_in">document</span>.getElementById(<span class="string">&quot;test&quot;</span>));        </span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，就会在页面中的这个div容器上添加这个h1.</p>
<p><img src="C:\Users\86136\Desktop\repository\notes\FrontEnd\images\1611196030416.png" alt="渲染结果"></p>
<h2 id="JSX基础语法"><a href="#JSX基础语法" class="headerlink" title="JSX基础语法"></a>JSX基础语法</h2><p>1.定义虚拟DOM，不能使用“”</p>
<p>2.标签中混入JS<strong>表达式</strong>的时候使用**{}**</p>
<p>3.样式的类名指定不要使用class，使用className</p>
<p>4.内敛样式要使用双大括号包裹</p>
<p>5.不能有多个根标签，只能有一个跟标签</p>
<p>6.标签必须闭合</p>
<p>7.如果小写字母开头，就将标签转化为html同名元素，如果html中无该标签对应的元素，就报错；如果是大写字母开头，react就去渲染对应的组件，如果没有就报错</p>
<blockquote>
<p>关于JS表达式和JS语句：</p>
<p><strong>JS表达式</strong>：返回一个值，可以放在任何一个需要值的地方  a  a+b  demo(a)  arr.map() function text(){}<br><strong>JS语句</strong>：if(){} for(){} while(){} swith(){} 不会返回一个值</p>
</blockquote>
<blockquote>
<p>一定注意区分：【js语句(代码)】与【js表达式】</p>
<p>​     *1.<strong>表达式</strong>：一个表达式会产生一个值，可以放在任何一个需要值的地方*</p>
<p>​        <em>下面这些都是表达式：</em></p>
<p>​          <em>(1). a</em></p>
<p>​          <em>(2). a+b</em></p>
<p>​          <em>(3). demo(1)</em></p>
<p>​          <em>(4). arr.map()</em> </p>
<p>​          <em>(5). function test () {}</em></p>
<p>​     *2.**语句(代码)*<em>：</em></p>
<p>​        <em>下面这些都是语句(代码)：</em></p>
<p>​          <em>(1).if(){}</em></p>
<p>​          <em>(2).for(){}</em></p>
<p>​          <em>(3).switch(){case:xxxx}</em></p>
</blockquote>
<p>实例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.sss</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 准备好容器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入依赖 ,引入的时候，必须就按照这个步骤--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/react.development.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/react-dom.development.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这里使用了js来创建虚拟DOM--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> MyId = <span class="string">&quot;title&quot;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> MyData = <span class="string">&quot;Cyk&quot;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 1.创建虚拟DOM</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> VDOM = (</span></span><br><span class="line"><span class="javascript">            <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span> = <span class="string">&#123;MyId.toLocaleUpperCase()&#125;</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="javascript">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span> = <span class="string">&quot;sss&quot;</span> <span class="attr">style</span> = <span class="string">&#123;&#123;fontSize:</span>&#x27;<span class="attr">50px</span>&#x27;&#125;&#125;&gt;</span>sss<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="javascript">            <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">        )</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 2.渲染，如果有多个渲染同一个容器，后面的会将前面的覆盖掉</span></span></span><br><span class="line"><span class="javascript">        ReactDOM.render(VDOM,<span class="built_in">document</span>.getElementById(<span class="string">&quot;test&quot;</span>));</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="两种创建虚拟DOM的方式"><a href="#两种创建虚拟DOM的方式" class="headerlink" title="两种创建虚拟DOM的方式"></a>两种创建虚拟DOM的方式</h2><p><strong>1.使用JSX创建虚拟DOM</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> VDOM = (</span><br><span class="line">           <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span> = <span class="string">&#123;MyId.toLocaleUpperCase()&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">               <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span> = <span class="string">&quot;sss&quot;</span> <span class="attr">style</span> = <span class="string">&#123;&#123;fontSize:</span>&#x27;<span class="attr">50px</span>&#x27;&#125;&#125;&gt;</span>sss<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">           <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">       )</span><br></pre></td></tr></table></figure>

<p>这个在上面的案例中已经演示过了 ，下面看看另外一种创建虚拟DOM的方式</p>
<p><strong>2.使用JS创建虚拟DOM</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建虚拟DOM[在这使用了js的语法]React.createElement(标签,标签属性,内容)</span></span><br><span class="line"><span class="keyword">const</span> VDOM = React.createElement(<span class="string">&#x27;h1&#x27;</span>,&#123;<span class="attr">id</span>:<span class="string">&quot;title&quot;</span>&#125;,<span class="string">&quot;nihao&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>使用JS和JSX都可以创建虚拟DOM，但是可以看出JS创建虚拟DOM比较繁琐，尤其是标签如果很多的情况下，所以还是比较推荐使用JSX来创建。</p>
<p><strong>3.关于虚拟DOM：</strong></p>
<p>​     <em>1.本质是Object类型的对象（一般对象）</em></p>
<p>​     <em>2.虚拟DOM比较“轻”，真实DOM比较“重”，因为虚拟DOM是React内部在用，无需真实DOM上那么多的属性。</em></p>
<p>​     <em>3.虚拟DOM最终会被React转化为真实DOM，呈现在页面上。</em></p>
<h1 id="3-React组件"><a href="#3-React组件" class="headerlink" title="3. React组件"></a>3. React组件</h1><p>当应用是以多组件的方式实现，这个应用就是一个组件化的应用</p>
<blockquote>
<p><strong>注意：</strong> 组件名称必须以大写字母开头。</p>
<p>React 会将以小写字母开头的组件视为原生 DOM 标签。例如，&lt; div /&gt;<code>代表 HTML 的 div 标签，而</code>&lt; Weclome /&gt; 则代表一个组件，并且需在作用域内使用 <code>Welcome</code></p>
<p>传递的参数，不能在组件中改动</p>
</blockquote>
<h2 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//1.先创建函数，函数可以有参数，也可以没有，但是必须要有返回值 返回一个虚拟DOM</span><br><span class="line">function Welcome(props) &#123;</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line">//2.进行渲染</span><br><span class="line">ReactDOM.Render(&lt;Welcom name = &quot;ss&quot; /&gt;,document.getElementById(&quot;div&quot;));</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\86136\Desktop\repository\notes\FrontEnd\images\1611211670211.png" alt="结果"></p>
<p>让我们来回顾一下这个例子中发生了什么：</p>
<ol>
<li>我们调用 <code>ReactDOM.render()</code> 函数，并传入 <code>&lt;Welcome name=&quot;Sara&quot; /&gt;</code> 作为参数。</li>
<li>React 调用 <code>Welcome</code> 组件，并将 <code>&#123;name: &#39;Sara&#39;&#125;</code> 作为 props 传入。</li>
<li><code>Welcome</code> 组件将 <code>Hello, Sara</code> 元素作为返回值。</li>
<li>React DOM 将 DOM 高效地更新为 <code>Hello, Sara</code>。</li>
</ol>
<blockquote>
<p>注意</p>
<p>组件函数中的this是undefined，因为babel编译后开启了<strong>严格模式</strong>: 禁止函数里的this指向window</p>
</blockquote>
<h2 id="Class组件"><a href="#Class组件" class="headerlink" title="Class组件"></a>Class组件</h2><p>补充 Class基础</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> &gt;</span><br><span class="line">		<span class="comment">//创建一个Person类</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">			<span class="comment">//构造器方法</span></span><br><span class="line">			<span class="function"><span class="title">constructor</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">				<span class="comment">//构造器中的this是谁？—— 类的实例对象</span></span><br><span class="line">				<span class="built_in">this</span>.name = name</span><br><span class="line">				<span class="built_in">this</span>.age = age</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//一般方法</span></span><br><span class="line">			<span class="function"><span class="title">speak</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				<span class="comment">// 重点一：speak方法放在了哪里？——类的原型对象上，供实例使用</span></span><br><span class="line">				<span class="comment">// 重点二：speak中的this是谁？通过Person实例调用speak时，speak中的this就是Person实例</span></span><br><span class="line">				<span class="built_in">console</span>.log(<span class="string">`我叫<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>，我年龄是<span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span>`</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;p1&#x27;</span>, <span class="number">19</span>);</span><br><span class="line">		<span class="keyword">const</span> p2 = <span class="keyword">new</span> Person(<span class="string">&#x27;p2&#x27;</span>, <span class="number">29</span>);</span><br><span class="line">		p1.speak()	<span class="comment">// this指向改变</span></span><br><span class="line">		p2.speak.call(&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;)	<span class="comment">// this指向改变</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建一个Student类，继承于Person类</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">			<span class="function"><span class="title">constructor</span>(<span class="params">name,age,grade</span>)</span>&#123;</span><br><span class="line">				<span class="built_in">super</span>(name,age)	<span class="comment">// 必须调用super, 且在最开始调用</span></span><br><span class="line">				<span class="built_in">this</span>.grade = grade</span><br><span class="line">				<span class="built_in">this</span>.school = <span class="string">&#x27;尚硅谷&#x27;</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//重写从父类继承过来的方法</span></span><br><span class="line">			<span class="function"><span class="title">speak</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				<span class="built_in">console</span>.log(<span class="string">`我叫<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>，我年龄是<span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span>,我读的是<span class="subst">$&#123;<span class="built_in">this</span>.grade&#125;</span>年级`</span>);</span><br><span class="line">				<span class="built_in">this</span>.study()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="function"><span class="title">study</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				<span class="comment">// study方法放在了哪里？——类的原型对象上，供实例使用</span></span><br><span class="line">				<span class="comment">// 通过Student实例调用study时，study中的this就是Student实例</span></span><br><span class="line">				<span class="built_in">console</span>.log(<span class="string">&#x27;我很努力的学习&#x27;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">const</span> s1 = <span class="keyword">new</span> Student(<span class="string">&#x27;校长&#x27;</span>, <span class="number">15</span>, <span class="string">&#x27;高一&#x27;</span>);</span><br><span class="line">		s1.speak()</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">			<span class="function"><span class="title">constructor</span>(<span class="params">name,price</span>)</span>&#123;</span><br><span class="line">				<span class="built_in">this</span>.name = name</span><br><span class="line">				<span class="built_in">this</span>.price = price</span><br><span class="line">				<span class="comment">// this.wheel = 4</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//类中可以直接写赋值语句,如下代码的含义是：给Car的实例对象添加一个属性，名为a，值为1</span></span><br><span class="line">			a = <span class="number">1</span></span><br><span class="line">			wheel = <span class="number">4</span></span><br><span class="line">			<span class="keyword">static</span> demo = <span class="number">100</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">const</span> c1 = <span class="keyword">new</span> Car(<span class="string">&#x27;奔驰c63&#x27;</span>,<span class="number">199</span>)</span><br><span class="line">		<span class="built_in">console</span>.log(c1);</span><br><span class="line">		<span class="built_in">console</span>.log(Car.demo);</span><br><span class="line">	&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：<br>1.类中的构造器不是必须要写的，要对实例进行一些初始化的操作，如添加指定属性时才写。<br>2.如果A类继承了B类，且A类中写了构造器，那么A类构造器中的super是必须要调用的。<br>3.类中所定义的方法，都放在了类的原型对象上，供实例去使用。</p>
</blockquote>
<p><strong>实例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1.必须继承React.Component</span><br><span class="line">// 2.然后重写Render()方法，该方法一定要有返回值，返回一个虚拟DOM</span><br><span class="line">class Welcome extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    //render是放在哪里的？—— MyComponent的原型对象上，供实例使用。</span><br><span class="line">	//render中的this是谁？—— MyComponent的实例对象 &lt;=&gt; MyComponent组件实例对象。		</span><br><span class="line">    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//渲染 【这个跟之前也是一样的】</span><br><span class="line">ReactDOM.Render(&lt;Welcom name = &quot;ss&quot; /&gt;,document.getElementById(&quot;div&quot;));</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<p>1.render是放在哪里的？—— MyComponent的原型对象上，供实例使用。<br>2.render中的this是谁？—— <strong>MyComponent的实例对象</strong> &lt;=&gt; MyComponent组件实例对象。</p>
<p><strong>执行过程</strong>：</p>
<p>​    1.React解析组件标签，找到相应的组件</p>
<p>​    2.发现组件是类定义的，<strong>随后new出来的类的实例，并通过该实例调用到原型上的render方法</strong></p>
<p>​    3.将render返回的虚拟DOM转化为真实的DOM,随后呈现在页面中</p>
<h2 id="组件案例"><a href="#组件案例" class="headerlink" title="组件案例"></a>组件案例</h2><p>下面，我们通过一个案例更好的理解组件：【只关注与核心代码】</p>
<p>我们发现组件是可以包含中使用的， 而且如果创建的数组，必须要代一个key。数组元素中使用的 key 在其兄弟节点之间应该是独一无二的。然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的 key 值 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/babel&quot;&gt;        //创建一个组件&lt;li&gt;        function GetLi(props)&#123;                  return &lt;li&gt;&#123;props.value&#125;&lt;/li&gt;        &#125;;        // 1.创建类式组件&lt;ul&gt;        class MyComponent extends React.Component&#123;            render()&#123;                console.log(this.props.arr);                let com = this.props.arr.map((item,index)=&gt;                     //在这个地方包含了GetLi这个组件，【注意不能用&#123;&#125;】                     //因为这个是一个列表，所以必须传递一个key【独一无二的Key】                     //key 帮助 React 识别哪些元素改变了，比如被添加或删除。                        &lt;GetLi value=&#123;item&#125; key = &#123;index&#125; /&gt;                    );                console.log(com);                return &lt;ul&gt;&#123;com&#125;&lt;/ul&gt;            &#125;        &#125;                let num = [1,2,3,4]        //2.渲染组件        ReactDOM.render(&lt;MyComponent  arr=&#123;num&#125;/&gt;,document.getElementById(&quot;test&quot;);&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h2 id="类组件的实例的三大属性"><a href="#类组件的实例的三大属性" class="headerlink" title="类组件的实例的三大属性"></a>类组件的实例的三大属性</h2><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><blockquote>
<p>复习——this指向问题</p>
<p><a href="https://www.bilibili.com/video/BV1wy4y1D7JT?p=12&spm_id_from=pageDriver">尚硅谷教程p12-p16</a></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">人</th>
<th align="center">状态</th>
<th align="center">影响</th>
<th align="center">行为</th>
</tr>
</thead>
<tbody><tr>
<td align="center">组件</td>
<td align="center">状态</td>
<td align="center">驱动</td>
<td align="center">页面</td>
</tr>
</tbody></table>
<p>我们都说React是一个状态机，体现是什么地方呢，就是体现在state上，通过与用户的交互，实现不同的状态，然后去渲染UI,这样就让用户的数据和界面保持一致了。<strong>state是组件的私有属性</strong>。</p>
<p>在React中，更新组件的state，结果就会重新渲染用户界面(不需要操作DOM),一句话就是说，<strong>用户的界面会随着状态的改变而改变</strong>。</p>
<p>state是组件对象最重要的属性，值是对象（可以包含多个key-value的组合）</p>
<p><strong>案例</strong>：</p>
<p>1.需求：页面显示【今天天气很炎热】，鼠标点击文字的时候，页面更改为【今天天气很凉爽】</p>
<p>核心代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--这里使用了js来创建虚拟DOM--&gt;</span><br><span class="line">&lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">        //1.创建组件</span><br><span class="line">        class St extends React.Component&#123;</span><br><span class="line">            constructor(props)&#123;</span><br><span class="line">                super(props);</span><br><span class="line">                //先给state赋值</span><br><span class="line">                this.state = &#123;isHot:true,win:&quot;ss&quot;&#125;;</span><br><span class="line">                //找到原型的dem，根据dem函数创建了一个dem1的函数，并且将实例对象的this赋值过去</span><br><span class="line">                this.dem1 = this.dem.bind(this);</span><br><span class="line">            &#125;</span><br><span class="line">            //render会调用1+n次【1就是初始化的时候调用的，n就是每一次修改state的时候调用的】</span><br><span class="line">            render()&#123; //这个This也是实例对象</span><br><span class="line">                //如果加dem()，就是将函数的回调值放入这个地方</span><br><span class="line">                //this.dem这里面加入this，并不是调用，只不过是找到了dem这个函数，在调用的时候相当于直接调用，并不是实例对象的调用</span><br><span class="line">                return &lt;h1 onClick = &#123;this.dem1&#125;&gt;今天天气很&#123;this.state.isHot?&quot;炎热&quot;:&quot;凉爽&quot;&#125;&lt;/h1&gt;    </span><br><span class="line">            &#125;</span><br><span class="line">            //通过state的实例调用dem的时候，this就是实例对象</span><br><span class="line">            dem()&#123;</span><br><span class="line">                const state =  this.state.isHot;</span><br><span class="line">                 //状态中的属性不能直接进行更改，需要借助API</span><br><span class="line">                // this.state.isHot = !isHot; 错误</span><br><span class="line">                //必须使用setState对其进行修改，并且这是一个合并</span><br><span class="line">                this.setState(&#123;isHot:!state&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 2.渲染，如果有多个渲染同一个容器，后面的会将前面的覆盖掉</span><br><span class="line">        ReactDOM.render(&lt;St /&gt;,document.getElementById(&quot;test&quot;));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<p>1.组件的构造函数，必须要传递一个props参数</p>
<p>2.特别关注this【重点】，类中所有的方法局部都开启了严格模式，如果直接进行调用，this就是undefined</p>
<p>3.想要改变state,需要使用<strong>setState</strong>进行修改，如果只是修改state的部分属性，则不会影响其他的属性，这个只是<strong>合并</strong>并不是覆盖。</p>
<h4 id="this-setState"><a href="#this-setState" class="headerlink" title="this.setState()"></a><strong>this.setState()</strong></h4><p>该方法接收两种参数：对象或函数。</p>
<ol>
<li>对象：即想要修改的state</li>
<li>函数：接收两个函数，第一个函数接受两个参数，第一个是当前state，第二个是当前props，该函数返回一个对象，和直接传递对象参数是一样的，就是要修改的state；第二个函数参数是state改变后触发的回调</li>
</ol>
<p>在此还需要注意的是，setState有异步更新和同步更新两种形式，那么什么时候会同步更新，什么时候会异步更新呢？</p>
<ul>
<li><p><strong>React控制之外的事件中调用setState是同步更新的。比如原生js绑定的事件，    setTimeout/setInterval等</strong>。</p>
</li>
<li><p><strong>大部分开发中用到的都是React封装的事件，比如onChange、onClick、    onTouchMove等，这些事件处理程序中的setState都是异步处理的。</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//1.创建组件</span><br><span class="line">class St extends React.Component&#123;</span><br><span class="line">    //可以直接对其进行赋值</span><br><span class="line">    state = &#123;isHot:10&#125;;</span><br><span class="line">    render()&#123; //这个This也是实例对象</span><br><span class="line">        return &lt;h1 onClick = &#123;this.dem&#125;&gt;点击事件&lt;/h1&gt; </span><br><span class="line">    &#125;</span><br><span class="line">//箭头函数 [自定义方法---&gt;要用赋值语句的形式+箭头函数]</span><br><span class="line">    dem = () =&gt;&#123;</span><br><span class="line">        //修改isHot</span><br><span class="line">        this.setState(&#123; isHot: this.state.isHot + 1&#125;)</span><br><span class="line">        console.log(this.state.isHot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的案例中预期setState使得isHot变成了11，输出也应该是11。然而在控制台打印的却是10，也就是并没有对其进行更新。这是因为异步的进行了处理，在输出的时候还没有对其进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">componentDidMount()&#123;    document.getElementById(&quot;test&quot;).addEventListener(&quot;click&quot;,()=&gt;&#123;        this.setState(&#123;isHot: this.state.isHot + 1&#125;);        console.log(this.state.isHot);    &#125;)&#125;</span><br></pre></td></tr></table></figure>

<p>但是通过这个原生JS的，可以发现，控制台打印的就是11，也就是已经对其进行了处理。也就是进行了同步的更新。</p>
<h4 id="React怎么调用同步或者异步的呢？"><a href="#React怎么调用同步或者异步的呢？" class="headerlink" title="React怎么调用同步或者异步的呢？"></a><strong>React怎么调用同步或者异步的呢？</strong></h4><ul>
<li><p>在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中延时更新，而 isBatchingUpdates 默认是 false，表示 setState 会同步更新 this.state；但是，有一个函数 batchedUpdates，该函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会先调用这个 batchedUpdates将isBatchingUpdates修改为true，这样由 React 控制的事件处理过程 setState 不会同步更新 this.state。</p>
</li>
<li><p><strong>如果是同步更新，每一个setState对调用一个render，并且如果多次调用setState会以最后调用的为准，前面的将会作废；如果是异步更新，多个setSate会统一调用一次render</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dem = () =&gt;&#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">        isHot:  1,</span><br><span class="line">        cont:444</span><br><span class="line">    &#125;)</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">    	isHot: this.state.isHot + 1</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">        isHot:  888,</span><br><span class="line">        cont:888</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的最后会输出：isHot是888，cont是888</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dem = () =&gt;&#123;</span><br><span class="line">               </span><br><span class="line">               this.setState(&#123;</span><br><span class="line">                   isHot: this.state.isHot + 1,</span><br><span class="line">                   </span><br><span class="line">               &#125;)</span><br><span class="line">               this.setState(&#123;</span><br><span class="line">                   isHot: this.state.isHot + 1,</span><br><span class="line">                   </span><br><span class="line">               &#125;)</span><br><span class="line">               this.setState(&#123;</span><br><span class="line">                   isHot: this.state.isHot + 888</span><br><span class="line">               &#125;)</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<p>初始isHot为10，最后isHot输出为898，也就是前面两个都没有执行。</p>
<p>**注意！！这是异步更新才有的，如果同步更新，每一次都会调用render，这样每一次更新都会 **</p>
<p><strong>简化版本：</strong></p>
<p>1.state的赋值可以不再构造函数中进行</p>
<p>2.使用了箭头函数，将this进行了改变</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/babel&quot;&gt;        class St extends React.Component&#123;            //可以直接对其进行赋值            state = &#123;isHot:true&#125;;            render()&#123; //这个This也是实例对象                return &lt;h1 onClick = &#123;this.dem&#125;&gt;今天天气很&#123;this.state.isHot?&quot;炎热&quot;:&quot;凉爽&quot;&#125;&lt;/h1&gt;                    //或者使用&#123;()=&gt;this.dem()也是可以的&#125;            &#125;            //箭头函数 [自定义方法---&gt;要用赋值语句的形式+箭头函数]            dem = () =&gt;&#123;                console.log(this);                const state =  this.state.isHot;                this.setState(&#123;isHot:!state&#125;);            &#125;        &#125;        ReactDOM.render(&lt;St /&gt;,document.getElementById(&quot;test&quot;));       &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>如果想要在调用方法的时候传递参数，有两个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>上述两种方式是等价的，分别通过<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind"><code>Function.prototype.bind</code></a> 来实现。</p>
<p>在这两种情况下，React 的事件对象 <code>e</code> 会被作为第二个参数传递。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 <code>bind</code> 的方式，事件对象以及更多的参数将会被隐式的进行传递。</p>
<h3 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h3><p>作用：Props主要用来传递数据，比如组件之间进行传值</p>
<h5 id="基本使用："><a href="#基本使用：" class="headerlink" title="基本使用："></a>基本使用：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;    &lt;div id = &quot;div&quot;&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/babel&quot;&gt;    class Person extends React.Component&#123;        render()&#123;            return (                &lt;ul&gt;                    //接受数据并显示                    &lt;li&gt;&#123;this.props.name&#125;&lt;/li&gt;                    &lt;li&gt;&#123;this.props.age&#125;&lt;/li&gt;                    &lt;li&gt;&#123;this.props.sex&#125;&lt;/li&gt;                &lt;/ul&gt;            )        &#125;    &#125;    //传递数据    ReactDOM.render(&lt;Person name=&quot;tom&quot; age = &quot;41&quot; sex=&quot;男&quot;/&gt;,document.getElementById(&quot;div&quot;));&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>如果传递的数据是一个对象，可以更加简便的使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/babel&quot;&gt;    class Person extends React.Component&#123;        render()&#123;            return (                &lt;ul&gt;                    &lt;li&gt;&#123;this.props.name&#125;&lt;/li&gt;                    &lt;li&gt;&#123;this.props.age&#125;&lt;/li&gt;                    &lt;li&gt;&#123;this.props.sex&#125;&lt;/li&gt;                &lt;/ul&gt;            )        &#125;    &#125;    const p = &#123;name:&quot;张三&quot;,age:&quot;18&quot;,sex:&quot;女&quot;&#125;   ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;,document.getElementById(&quot;div&quot;));&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><code>... </code>这个符号恐怕都不陌生，这个是一个展开运算符，主要用来展开数组，如下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];arr1 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];arr2 = [...arr,...arr1];  <span class="comment">//arr2 = [1,2,,3,4,5,6]</span></span><br></pre></td></tr></table></figure>

<p>但是他还有其他的用法：</p>
<p>1.复制一个对象给另一个对象{…对象名}。此时这两个对象并没有什么联系了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = &#123;<span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>,<span class="attr">age</span>:<span class="string">&quot;18&quot;</span>,<span class="attr">sex</span>:<span class="string">&quot;女&quot;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> p2 = &#123;...p1&#125;;	<span class="comment">// 复制</span></span><br><span class="line">p1.name = <span class="string">&quot;sss&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p2)  <span class="comment">//&#123;name:&quot;张三&quot;,age:&quot;18&quot;,sex:&quot;女&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>2.在复制的时候，合并其中的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = &#123;<span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>,<span class="attr">age</span>:<span class="string">&quot;18&quot;</span>,<span class="attr">sex</span>:<span class="string">&quot;女&quot;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> p2 = &#123;...p1,<span class="attr">name</span> : <span class="string">&quot;111&quot;</span>,<span class="attr">hua</span>:<span class="string">&quot;ss&quot;</span>&#125;;</span><br><span class="line">p1.name = <span class="string">&quot;sss&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p2)  <span class="comment">//&#123;name: &quot;111&quot;, age: &quot;18&quot;, sex: &quot;女&quot;,hua:&quot;ss&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意！！</strong> <strong>{…P}并不能展开一个对象</strong></p>
<p><strong>props传递一个对象，是因为babel+react使得{..p}可以展开对象，但是只有在标签中才能使用</strong></p>
<h5 id="对于props限制"><a href="#对于props限制" class="headerlink" title="对于props限制"></a><strong>对于props限制</strong></h5><p>很多时候都想要传递的参数进行相应的限制，比如：限制传递参数的类型，参数的默认值等等</p>
<p>react对此提供了相应的解决方法：</p>
<ul>
<li>propTypes:类型检查，还可以限制不能为空</li>
<li>defaultProps：默认值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    class Person extends React.Component&#123;</span><br><span class="line">        render()&#123;</span><br><span class="line">            //props是只读的</span><br><span class="line">            return (</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &lt;li&gt;&#123;this.props.name&#125;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;&#123;this.props.age&#125;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;&#123;this.props.sex&#125;&lt;/li&gt;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        //对组件的属性对其进行限制</span><br><span class="line">        static propTypes = &#123;</span><br><span class="line">            name:PropTypes.string.isRequired, //限定name是string类型，并且必须要传递</span><br><span class="line">            sex:PropTypes.string,  //限定sex是string类型</span><br><span class="line">            speak:PropTypes.func   //限定speak是function类型</span><br><span class="line">        &#125;</span><br><span class="line">        //指定默认的标签属性</span><br><span class="line">        static defaultProps = &#123;</span><br><span class="line">            sex:&quot;不男不女&quot;,</span><br><span class="line">            age:18</span><br><span class="line">        &#125;   </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    //在js中可以使用&#123;...p&#125;来复制一个对象，但是这个地方并不是复制对象，而是babel+react通过展开运算符，展开了一个对象</span><br><span class="line">    //但是只能在标签中进行使用</span><br><span class="line">    //const p = &#123;name:&quot;张三&quot;,age:&quot;18&quot;,sex:&quot;女&quot;&#125;   &#123;14&#125;就代表的是数值</span><br><span class="line">    //ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;,document.getElementById(&quot;div&quot;));</span><br><span class="line">    ReactDOM.render(&lt;Person name=&quot;sss&quot; age = &#123;14&#125; speak=&quot;8&quot;/&gt;,document.getElementById(&quot;div&quot;));</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    function speak()&#123;</span><br><span class="line">        console.log(&quot;这个是一个函数&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="函数式组件的使用"><a href="#函数式组件的使用" class="headerlink" title="函数式组件的使用"></a><strong>函数式组件的使用</strong></h5><p>函数在使用props的时候，是作为参数进行使用的(props)；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(props)&#123;          return (                &lt;ul&gt;                    &lt;li&gt;&#123;props.name&#125;&lt;/li&gt;                    &lt;li&gt;&#123;props.age&#125;&lt;/li&gt;                    &lt;li&gt;&#123;props.sex&#125;&lt;/li&gt;                &lt;/ul&gt;            )    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h3><p> 作用：Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素。 </p>
<p>Refs主要提供了三种方式：</p>
<h5 id="1-字符串形式"><a href="#1-字符串形式" class="headerlink" title="1.字符串形式"></a><strong>1.字符串形式</strong></h5><p>在想要获取到一个DOM节点，可以直接在这个节点上添加ref属性。利用该属性进行获取该节点的值。</p>
<p>案例：给需要的节点添加ref属性，此时该实例对象的refs上就会有这个值。就可以利用实例对象的refs获取已经添加节点的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input ref=&quot;dian&quot; type=&quot;text&quot; placeholder=&quot;点击弹出&quot; /&gt; inputBlur = () =&gt;&#123;            alert(this.refs.shiqu.value);        &#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-回调形式"><a href="#2-回调形式" class="headerlink" title="2.回调形式"></a><strong>2.回调形式</strong></h5><p>回调形式会在ref属性中添加一个回调函数。<strong>将该DOM作为参数传递过去。</strong></p>
<p>如：ref里面就是一个回调函数，self就是该input标签。然后在将该DOM元素赋值给实例对象中的一个属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input ref=&#123;self =&gt;&#123; this.dian = self;console.log(self)&#125;&#125;  placeholder=&quot;点击弹出&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\86136\Desktop\repository\notes\FrontEnd\images\1611495051999.png" alt="input标签"></p>
<p>也可以将函数提取出来，在ref中进行调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">isRef = (self) =&gt;&#123;            this.dian = self;            console.log(self)        &#125;&lt;input ref=&#123;this.isRef&#125; type=&quot;text&quot; placeholder=&quot;点击弹出&quot; /&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于Refs中的回调次数问题</p>
<p>如果 <code>ref</code> 回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数 <code>null</code>，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的。</p>
</blockquote>
<h5 id="3-API形式"><a href="#3-API形式" class="headerlink" title="3.API形式"></a><strong>3.API形式</strong></h5><p>React其实已经给我们提供了一个相应的API，他会自动的将该DOM元素放入实例对象中</p>
<p>如下：依旧先在DOM元素中添加一个ref元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;/*&lt;input ref=&#123;this.容器名称&#125; type=&quot;text&quot; placeholder=&quot;点击弹出&quot; /&gt;*/&#125;&lt;input ref=&#123;this.MyRef&#125; type=&quot;text&quot; placeholder=&quot;点击弹出&quot; /&gt;&lt;input ref=&#123;this.MyRef1&#125; type=&quot;text&quot; placeholder=&quot;点击弹出&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>通过API，创建React的容器，相当于省略了回调的中间环节。但是这个容器是专门专用的，所以每一个ref都需要创建这个。该API会将DOM元素赋值给实例对象的名称为容器名称的属性的current【这个current是固定的】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;/*容器名称 = React.createRef()*/&#125;</span><br><span class="line">MyRef = React.createRef();</span><br><span class="line">MyRef1 = React.createRef();</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\86136\Desktop\repository\notes\FrontEnd\images\1611495597978.png" alt="API"></p>
<p>然后就可以使用了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">btnOnClick = () =&gt;&#123;</span><br><span class="line">    //创建之后，将自身节点，传入current中</span><br><span class="line">    console.log(this.MyRef.current.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>官方提示我们不要过度的使用ref，如果发生时间的元素刚好是需要操作的元素，就可以使用事件去替代。</strong></p>
<h1 id="4-React事件"><a href="#4-React事件" class="headerlink" title="4. React事件"></a>4. React事件</h1><h5 id="一般事件"><a href="#一般事件" class="headerlink" title="一般事件"></a>一般事件</h5><p>React的事件是通过<strong>onXxx</strong>属性指定事件处理函数</p>
<ul>
<li><p>React使用的都是自定义的事件，而不是原生的事件 <em>—————— 为了更好的兼容性</em></p>
</li>
<li><p>React中的事件是通过事件委托方式处理的(委托给组件最外层的元素) <em>——————为了的高效</em></p>
</li>
<li><p><strong>事件中必须返回的是函数</strong></p>
</li>
<li><p>通过event.target得到发生事件的Dom元素对象 <em>——————不要过度使用ref</em></p>
</li>
</ul>
<p>比如：</p>
<p>先声明一个事件，然后在根据事件创建相应的函数，根据事件的event参数，将DOM元素获取到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input onChange=&#123;this.saveName&#125; type = &quot;text&quot; name =&quot;username&quot;/&gt;saveName = (event) =&gt;&#123;            this.setState(&#123;name:event.target.value&#125;);        &#125;</span><br></pre></td></tr></table></figure>



<h5 id="受控和非受控组件"><a href="#受控和非受控组件" class="headerlink" title="受控和非受控组件"></a><strong>受控和非受控组件</strong></h5><p>先来说说受控组件：</p>
<p> 使 React 的 state 成为“<strong>唯一数据源</strong>”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">saveName = (event) =&gt;&#123;    this.setState(&#123;name:event.target.value&#125;);&#125;savePwd = (event) =&gt; &#123;    this.setState(&#123;pwd:event.target.value&#125;);&#125;render() &#123;    return (        &lt;form action=&quot;http://www.baidu.com&quot; onSubmit=&#123;this.login&#125;&gt;            用户名：&lt;input value=&#123;this.state.name&#125; onChange=&#123;this.saveName&#125; type = &quot;text&quot; /&gt;            密码&lt;input value=&#123;this.state.pwd&#125; onChange=&#123;this.savePwd&#125; type = &quot;password&quot;/&gt;            &lt;button&gt;登录&lt;/button&gt;        &lt;/form&gt;    )&#125;</span><br></pre></td></tr></table></figure>

<p>由于在表单元素上设置了 <code>value</code> 属性，因此显示的值将始终为 <code>this.state.value</code>，这使得 React 的 state 成为唯一数据源。由于 <code>onchange</code> 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。</p>
<p>对于受控组件来说，输入的值始终由 React 的 state 驱动。</p>
<p>非受控组件：</p>
<p><strong>非受控组件其实就是表单元素的值不会更新state</strong>。输入数据都是<strong>现用现取</strong>的。</p>
<p>如下：下面并没有使用state来控制属性，使用的是事件来控制表单的属性值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Login extends React.Component&#123;</span><br><span class="line"></span><br><span class="line">    login = (event) =&gt;&#123;</span><br><span class="line">        event.preventDefault(); //阻止表单提交</span><br><span class="line">            console.log(this.name.value);</span><br><span class="line">            console.log(this.pwd.value);</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;form action=&quot;http://www.baidu.com&quot; onSubmit=&#123;this.login&#125;&gt;</span><br><span class="line">                用户名：&lt;input ref = &#123;self =&gt; this.name =self &#125; type = &quot;text&quot; name =&quot;username&quot;/&gt;</span><br><span class="line">                密码：&lt;input ref = &#123;self =&gt; this.pwd =self &#125; type = &quot;password&quot; name =&quot;password&quot;/&gt;</span><br><span class="line">                &lt;button&gt;登录&lt;/button&gt;</span><br><span class="line">                &lt;/form&gt;</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="5-函數拓展"><a href="#5-函數拓展" class="headerlink" title="5. 函數拓展"></a>5. 函數拓展</h1><h5 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a><strong>高级函数</strong></h5><p>如果一个函数符合下面2个规范中的任何一个，那该函数就是高阶函数。</p>
<p>​    1.若A函数，接收的参数是一个函数，那么A就可以称之为高阶函数。</p>
<p>​    2.若A函数，调用的返回值依然是一个函数，那么A就可以称之为高阶函数。</p>
<p><em>常见的高阶函数有：Promise、setTimeout、arr.map()等等</em></p>
<h5 id="函数的珂里化"><a href="#函数的珂里化" class="headerlink" title="函数的珂里化"></a><strong>函数的珂里化</strong></h5><p>  通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span><span class="function">(<span class="params">b</span>)=&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="function">(<span class="params">c</span>)=&gt;</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> a+b+c</span><br><span class="line">		&#125;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>如下，我们将上面的案例简化，创建高级函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Login extends React.Component&#123;         state = &#123;name:&quot;&quot;,pwd:&quot;&quot;&#125;;				//返回一个函数        saveType = (type) =&gt;&#123;            return (event) =&gt; &#123;                this.setState(&#123;[type]:event.target.value&#125;);            &#125;        &#125;        //因为事件中必须是一个函数，所以返回的也是一个函数，这样就符合规范了        render() &#123;            return (                &lt;form&gt;      				&lt;input onChange = &#123;this.saveType(&#x27;name&#x27;)&#125; type = &quot;text&quot;/&gt;                    &lt;button&gt;登录&lt;/button&gt;                &lt;/form&gt;            )        &#125;    &#125;    ReactDOM.render(&lt;Login /&gt;,document.getElementById(&quot;div&quot;));</span><br></pre></td></tr></table></figure>



<h1 id="6-生命周期"><a href="#6-生命周期" class="headerlink" title="6. 生命周期"></a>6. 生命周期</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 初始化阶段: 由ReactDOM.render()触发---初次渲染	<span class="number">1.</span>	<span class="title">constructor</span>(<span class="params"></span>)	2.	<span class="title">componentWillMount</span>(<span class="params"></span>)	3.	<span class="title">render</span>(<span class="params"></span>)	4.	<span class="title">componentDidMount</span>(<span class="params"></span>) =====&gt; 常用		一般在这个钩子中做一些初始化的事，例如：开启定时器、发送网络请求、订阅消息2. 更新阶段: 由组件内部<span class="title">this</span>.<span class="title">setSate</span>(<span class="params"></span>)或父组件<span class="title">render</span>触发	1.	<span class="title">shouldComponentUpdate</span>(<span class="params"></span>)	2.	<span class="title">componentWillUpdate</span>(<span class="params"></span>)	3.	<span class="title">render</span>(<span class="params"></span>) =====&gt; 必须使用的一个	4.	<span class="title">componentDidUpdate</span>(<span class="params"></span>)3. 卸载组件: 由<span class="title">ReactDOM</span>.<span class="title">unmountComponentAtNode</span>(<span class="params"></span>)触发	1.	<span class="title">componentWillUnmount</span>(<span class="params"></span>)  =====&gt; 常用		一般在这个钩子中做一些收尾的事，例如：关闭定时器、取消订阅消息</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 初始化阶段: 由ReactDOM.render()触发---初次渲染	<span class="number">1.</span>	<span class="title">constructor</span>(<span class="params"></span>)	2.	<span class="title">getDerivedStateFromProps</span> 	3.	<span class="title">render</span>(<span class="params"></span>)	4.	<span class="title">componentDidMount</span>(<span class="params"></span>) =====&gt; 常用		一般在这个钩子中做一些初始化的事，例如：开启定时器、发送网络请求、订阅消息2. 更新阶段: 由组件内部<span class="title">this</span>.<span class="title">setSate</span>(<span class="params"></span>)或父组件重新<span class="title">render</span>触发	1.	<span class="title">getDerivedStateFromProps</span>	2.	<span class="title">shouldComponentUpdate</span>(<span class="params"></span>)	3.	<span class="title">render</span>(<span class="params"></span>)	4.	<span class="title">getSnapshotBeforeUpdate</span>	5.	<span class="title">componentDidUpdate</span>(<span class="params"></span>)3. 卸载组件: 由<span class="title">ReactDOM</span>.<span class="title">unmountComponentAtNode</span>(<span class="params"></span>)触发	1.	<span class="title">componentWillUnmount</span>(<span class="params"></span>)  =====&gt; 常用		一般在这个钩子中做一些收尾的事，例如：关闭定时器、取消订阅消息</span><br></pre></td></tr></table></figure>



<h2 id="（旧）"><a href="#（旧）" class="headerlink" title="（旧）"></a>（旧）</h2><p>组件从创建到死亡，会经过一些特定的阶段</p>
<p>​      React组件中包含一系列钩子函数{生命周期回调函数}，会在特定的时刻调用</p>
<p>​      我们在定义组件的时候，会在特定的声明周期回调函数中，做特定的工作</p>
<p>如下图是旧生命周期的结构图：</p>
<p><img src="C:\Users\86136\Desktop\repository\notes\FrontEnd\images\1611490156766.png" alt="旧生命周期"></p>
<p>我们通过一个案例更详细的了解这个生命周期：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A extends React.Component&#123;</span><br><span class="line"></span><br><span class="line">       constructor(props)&#123;</span><br><span class="line">           console.log(&quot;A --- constructor&quot;)</span><br><span class="line">           super(props);</span><br><span class="line">           this.state = &#123;num:1&#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       add = () =&gt; &#123;</span><br><span class="line">           let &#123;num&#125; = this.state;</span><br><span class="line">           this.setState(&#123;num:num+1&#125;);</span><br><span class="line">           //强制更新</span><br><span class="line">           //this.forceUpdate();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">      render()&#123;</span><br><span class="line">          console.log(&quot;A --- render&quot;);</span><br><span class="line">           return (</span><br><span class="line">               &lt;div&gt;</span><br><span class="line">                   &lt;h1&gt;这个是第&#123;this.state.num&#125;个&lt;/h1&gt;</span><br><span class="line">                   &lt;B name = &#123;this.state.num&#125;/&gt;</span><br><span class="line">                   &lt;button onClick = &#123;this.add&#125;&gt;点击加一&lt;/button&gt;</span><br><span class="line">               &lt;/div&gt;</span><br><span class="line">           )</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //在render之前执行</span><br><span class="line">      componentWillMount()&#123;</span><br><span class="line">           console.log(&quot;A --- componentWillMount&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //在render之后执行</span><br><span class="line">      componentDidMount()&#123;</span><br><span class="line">       console.log(&quot;A --- componenetDidMount&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //更新操作 setState之后执行，判断是否可以更新（true可以，false不可以）</span><br><span class="line">      shouldComponentUpdate()&#123;</span><br><span class="line">           console.log(&quot;A --- shouldComponentUpdate&quot;);</span><br><span class="line">           return true;</span><br><span class="line">      &#125;</span><br><span class="line">      // 组件将要更新之前</span><br><span class="line">      componentWillUpdate()&#123;</span><br><span class="line">           console.log(&quot;A --- componentWillUpdate&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      //组件更新之后，该函数可以接受相应的参数</span><br><span class="line">      componentDidUpdate()&#123;</span><br><span class="line">           console.log(&quot;A --- componentDidUpdate&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //卸载组件之后</span><br><span class="line">      componentWillUnmonut()&#123;</span><br><span class="line">           console.log(&quot;A --- componentWillUnmonut&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  class B extends React.Component&#123;</span><br><span class="line">      render()&#123;</span><br><span class="line">          return(   </span><br><span class="line">               &lt;div&gt;</span><br><span class="line">                   &lt;h1&gt;这个是B组件,传递过来的是：&#123;this.props.name&#125;&lt;/h1&gt;</span><br><span class="line">               &lt;/div&gt;</span><br><span class="line">          )</span><br><span class="line">      &#125;</span><br><span class="line">      //父组件进行了更新，子组件先执行这个【注意，第一次传递数据的时候，并不执行】</span><br><span class="line">      componentWillReceiveProps()&#123;</span><br><span class="line">       console.log(&quot;A --- componentWillReceiveProps&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   ReactDOM.render(&lt;A   /&gt;,document.getElementById(&quot;div&quot;));</span><br></pre></td></tr></table></figure>

<p>我们在控制台看一下：</p>
<p>当我们刚刚打开控制台的时候，组件第一次加载：</p>
<p><img src="C:\Users\86136\Desktop\repository\notes\FrontEnd\images\1611568192158.png" alt="组件第一次加载"></p>
<p>当我们点击按钮更新sate的时候：</p>
<p><img src="C:\Users\86136\Desktop\repository\notes\FrontEnd\images\1611568250881.png" alt="更新state"></p>
<h2 id="（新）"><a href="#（新）" class="headerlink" title="（新）"></a>（新）</h2><p>在最新的react版本中，有些生命周期钩子被抛弃了，在官网中是这样说的：</p>
<p>​    我们得到最重要的经验是，过时的组件生命周期往往会带来不安全的编码实践，具体函数如下：</p>
<ul>
<li><p><code>componentWillMount</code></p>
</li>
<li><p><code>componentWillReceiveProps</code></p>
</li>
<li><p><code>componentWillUpdate</code></p>
<p>这些生命周期方法经常被误解和滥用；此外，我们预计，在异步渲染中，它们潜在的误用问题可能更大。我们将在即将发布的版本中为这些生命周期添加 “UNSAFE_” 前缀。（这里的 “unsafe” 不是指安全性，而是表示使用这些生命周期的代码在 React 的未来版本中更有可能出现 <strong>bug</strong>，尤其是在启用异步渲染之后。）</p>
</li>
</ul>
<p>由此可见，新版本中并不推荐持有这三个函数，取而代之的是带有UNSAFE_ 前缀的三个函数，比如: UNSAFE_ componentWillMount。即便如此，其实React官方还是不推荐大家去使用，在以后版本中有可能会去除这几个函数。</p>
<p>如下图是新的生命周期：</p>
<p><img src="C:\Users\86136\Desktop\repository\notes\FrontEnd\images\1611651795885.png" alt="新生命周期"></p>
<p>从图上可以看出，新生命周期和旧生命周期的区别主要有：</p>
<p>1.抛弃了上面所说的三个钩子函数【其实还可以使用】</p>
<p>2.新添加了两个钩子函数</p>
<p>现在重点说一下，新添加的钩子函数</p>
<p><strong>static getDerivedStateFromProps(props, state)</strong></p>
<p>首先，该函数会调用 <strong>render 方法之前</strong>调用，并且在<strong>初始挂载</strong>及<strong>后续更新</strong>时都会被调用；该函数必须是<strong>静态</strong>的；给组件传递的数据（props）以及组件状态（state），会作为参数到这个函数中；该函数也必须有返回值，返回一个Null或者state对象。因为初始化和后续更新都会执行这个方法，因此在这个方法返回state对象，就相当于将原来的state进行了覆盖，所以倒是修改状态不起作用。</p>
<p><strong>getSnapshotBeforeUpdate(prevProps, prevState)</strong></p>
<p> <code>getSnapshotBeforeUpdate()</code> 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递<code>componentDidUpdate()</code>。 </p>
<blockquote>
<p>补充一下：componentDidUpdate(prevProps, prevState, snapshot)</p>
<p>该生命周期函数，可以有三个参数：原始传过来的参数，最开始的状态，getSnapshotBeforeUpdate传递的值</p>
<p>关于更多关于生命周期的介绍，可以参考官方文档：</p>
<p><a href="https://zh-hans.reactjs.org/docs/react-component.html#render">https://zh-hans.reactjs.org/docs/react-component.html#render</a></p>
</blockquote>
<p>以上就是两个新添加的钩子函数，但是在现实开发中可能并不常用这两个。</p>
<p>**案例：在一个区域内，定时的输出以行话，如果内容大小超过了区域大小，就出现滚动条，但是内容不进行移动 **</p>
<p><img src="C:\Users\86136\Desktop\repository\notes\FrontEnd\images\BeforeGender.gif" alt="案例"></p>
<p>如上面的动图：区域内部的内容展现没有变化，但是可以看见滚动条在变化，也就是说上面依旧有内容在输出，只不过不在这个区域内部展现。</p>
<p><strong>实现：</strong></p>
<p>【一些css样式，就不在这展示了】</p>
<p>1.首先我们先实现定时输出内容</p>
<p>我们可以使用state状态，改变新闻后面的值，但是为了同时显示这些内容，我们应该为state的属性定义一个数组。并在创建组件之后开启一个定时器，不断的进行更新state。更新渲染组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class New extends React.Component&#123;</span><br><span class="line"></span><br><span class="line">       state = &#123;num:[]&#125;;</span><br><span class="line"></span><br><span class="line">       //在组件创建之后,开启一个定时任务</span><br><span class="line">       componentDidMount()&#123;</span><br><span class="line">           setInterval(()=&gt;&#123;</span><br><span class="line">               let &#123;num&#125; = this.state;</span><br><span class="line">               const news = (num.length+1);</span><br><span class="line">               this.setState(&#123;num:[news,...num]&#125;);</span><br><span class="line">           &#125;,2000);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       render()&#123;</span><br><span class="line">           return (</span><br><span class="line"></span><br><span class="line">               &lt;div ref = &quot;list&quot; className = &quot;list&quot;&gt;&#123;</span><br><span class="line">                   this.state.num.map((n,index)=&gt;&#123;</span><br><span class="line">                   return &lt;div className=&quot;news&quot; key=&#123;index&#125; &gt;新闻&#123;n&#125;&lt;/div&gt;</span><br><span class="line">                   &#125;)</span><br><span class="line">               &#125;&lt;/div&gt;</span><br><span class="line">           )</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ReactDOM.render(&lt;New /&gt;,document.getElementById(&quot;div&quot;));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.接下来就是控制滚动条了</p>
<p>我们在组件渲染到DOM之前获取组件的高度，然后用组件渲染之后的高度减去之前的高度就是一条新的内容的高度，这样在不断的累加到滚动条位置上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getSnapshotBeforeUpdate()&#123;	return this.refs.list.scrollHeight;&#125;componentDidUpdate(preProps,preState,height)&#123;	this.refs.list.scrollTop += (this.refs.list.scrollHeight - height);&#125;</span><br></pre></td></tr></table></figure>

<p>这样就实现了这个功能。</p>
<h1 id="7-Diff算法"><a href="#7-Diff算法" class="headerlink" title="7. Diff算法"></a>7. Diff算法</h1><p>提到这个算法，就必须说一下关于<code>Key</code>的事情了。</p>
<p>其实每个组件中的每个标签都会有一个key, 只不过有的必须显示的指定，有的可以隐藏。</p>
<p> 如果生成的render出来后就<strong>不会改变里面的内容，那么你不需要指定key</strong>（不指定key时，React也会生成一个默认的标识）,或者将index作为key，只要key不重复即可。</p>
<p>但是如果你的标签是动态的，是有可能刷新的，就必须显示的指定key。上面案使用map进行便利的时候就必须指定Key:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.state.num.map((n,index)=&gt;&#123;	return &lt;div className=&quot;news&quot; key=&#123;index&#125; &gt;新闻&#123;n&#125;&lt;/div&gt;&#125;)</span><br></pre></td></tr></table></figure>

<p>这个地方虽然显示的指定了key，但是<strong>官网并不推荐使用Index作为Key去使用</strong>；</p>
<p>这样会很有可能会有效率上的问题</p>
<p>举个例子：</p>
<p>在一个组件中，我们先创建了两个对象，通过循环的方式放入&lt; li&gt;标签中，此时key使用的是index。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">person:[    &#123;id:1,name:&quot;张三&quot;,age:18&#125;,    &#123;id:2,name:&quot;李四&quot;,age:19&#125;]this.state.person.map((preson,index)=&gt;&#123;  return  &lt;li key = &#123;index&#125;&gt;&#123;preson.name&#125;&lt;/li&gt;&#125;)</span><br></pre></td></tr></table></figure>

<p>如下图展现在页面中：</p>
<p><img src="C:\Users\86136\Desktop\repository\notes\FrontEnd\images\1611800406864.png" alt="原始对象数组"></p>
<p>此时，我们想在点击按钮之后动态的添加一个对象，并且放入到li标签中，在重新渲染到页面中。</p>
<p>我们通过修改State来控制对象的添加。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;this.addObject&#125;&gt;点击增加对象&lt;/button&gt;</span><br><span class="line">addObject = () =&gt;&#123;</span><br><span class="line">    let &#123;person&#125; = this.state;</span><br><span class="line">    const p = &#123;id:(person.length+1),name:&quot;王五&quot;,age:20&#125;;</span><br><span class="line">    this.setState(&#123;person:[p,...person]&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下动图所示：</p>
<p> <img src="C:\Users\86136\Desktop\repository\notes\FrontEnd\images\addObject.gif" alt="原始对象数组"> </p>
<p>这样看，虽然完成了功能。但是其实存在效率上的问题，    我们先来看一下两个前后组件状态的变化：</p>
<p><img src="C:\Users\86136\Desktop\repository\notes\FrontEnd\images\1611800988496.png" alt="组件状态的变化"></p>
<p>我们发现，组件第一个变成了王五，张三和李四都移下去了。因为我们使用Index作为Key，这三个标签的key也就发生了改变【张三原本的key是0，现在变成了1，李四的key原本是1，现在变成了2，王五变成了0】在组件更新状态重新渲染的时候，就出现了问题：</p>
<p>因为react是通过key来比较组件标签是否一致的，拿这个案例来说：</p>
<p>首先，状态更新导致组件标签更新，react根据Key，判断旧的虚拟DOM和新的虚拟DOM是否一致</p>
<p>key = 0 的时候 旧的虚拟DOM 内容是张三  新的虚拟DOM为王五 ，react认为内容改变，从而重新创建新的真实DOM.</p>
<p>key = 1 的时候 旧的虚拟DOM 内容是李四，新的虚拟DOM为张三，react认为内容改变，从而重新创建新的真实DOM</p>
<p>key = 2 的时候 旧的虚拟DOM没有，创建新的真实DOM </p>
<p>这样原本有两个虚拟DOM可以复用，但都没有进行复用，完完全全的都是新创建的；这就导致效率极大的降低。</p>
<p>其实这是因为我们将新创建的对象放在了首位，如果放在最后其实是没有问题的，但是因为官方并不推荐使用Index作为key值，我们推荐使用id作为key值。从而完全避免这样的情况。</p>
<p><strong>虚拟DOM中key的作用：</strong></p>
<p>​     1). 简单的说: key是虚拟DOM对象的标识, 在更新显示时key起着极其重要的作用。</p>
<p>​     2). 详细的说: 当状态中的数据发生变化时，react会根据【新数据】生成【新的虚拟DOM】, </p>
<p>​            随后React进行【新虚拟DOM】与【旧虚拟DOM】的diff比较，比较规则如下：</p>
<p>​         a. 旧虚拟DOM中找到了与新虚拟DOM相同的key：</p>
<p>​            (1).若虚拟DOM中内容没变, 直接使用之前的真实DOM</p>
<p>​            (2).若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM</p>
<p>​         b. 旧虚拟DOM中未找到与新虚拟DOM相同的key</p>
<p>​            根据数据创建新的真实DOM，随后渲染到到页面</p>
<p><strong>用index作为key可能会引发的问题:</strong></p>
<p>​    1.若对数据进行:逆序添加、逆序删除等破坏顺序操作:</p>
<p>​        会产生没有必要的真实DOM更新  界面效果没问题,但效率低。</p>
<p>​    2.如果结构中还包含输入类的DOM:</p>
<p>​        会产生错误DOM更新   界面有问题。</p>
<p>​    3.注意! 如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。</p>
<p><strong>开发如何选择key?</strong></p>
<p>​    最好使用每一条数据的唯一标识作为key 比如id，手机号，身份证号</p>
<p>​    如果确定只是简单的展示数据，用Index也是可以的</p>
<p><strong>而这个判断key的比较规则就是Diff算法</strong></p>
<p>Diff算法其实就是react生成的新虚拟DOM和以前的旧虚拟DOM的比较规则：</p>
<ul>
<li><p>如果旧的虚拟DOM中找到了与新虚拟DOM相同的key:</p>
<ul>
<li>如果内容没有变化，就直接只用之前旧的真实DOM</li>
<li>如果内容发生了变化，就生成新的真实DOM            </li>
</ul>
</li>
<li><p>如果旧的虚拟DOM中没有找到了与新虚拟DOM相同的key:</p>
<ul>
<li>根据数据创建新的真实的DOM,随后渲染到页面上</li>
</ul>
</li>
</ul>
<h1 id="8-React脚手架"><a href="#8-React脚手架" class="headerlink" title="8.React脚手架"></a>8.React脚手架</h1><p>react提供了一个用于创建react项目的脚手架库：create-react-app</p>
<h2 id="创建项目并启动"><a href="#创建项目并启动" class="headerlink" title="创建项目并启动"></a>创建项目并启动</h2><ol>
<li><p>全局安装：<code>npm i -g create-react-app</code></p>
</li>
<li><p>创建项目：<code>create-react-app 项目名  </code></p>
<p>在这一步，有可能会出现：</p>
</li>
</ol>
<p><img src="C:\Users\86136\Desktop\repository\notes\FrontEnd\images\1611803687193.png" alt="不是内部命令"></p>
<p>​     这样可以直接使用：<code>npx create-react-app 项目名 </code></p>
<ol start="3">
<li><p>等待下载完成，进入项目文件夹，运行一下</p>
<p>比如，我这的项目名称是hello,就先进入hello文件夹</p>
<p><code>cd hello</code></p>
<p><code>npm start </code>  //启动这个项目</p>
</li>
</ol>
<p><img src="C:\Users\86136\Desktop\repository\notes\FrontEnd\images\1611816095069.png" alt="启动成功"></p>
<p>这个时会自动的打开浏览器，展现这个项目：</p>
<p><img src="C:\Users\86136\Desktop\repository\notes\FrontEnd\images\1611816150630.png" alt="第一个脚手架项目"></p>
<h2 id="项目的目录结构"><a href="#项目的目录结构" class="headerlink" title="项目的目录结构"></a>项目的目录结构</h2><p>我们先来看一下public这个目录下面的结构：</p>
<p><img src="C:\Users\86136\Desktop\repository\notes\FrontEnd\images\1611817630266.png" alt="public"></p>
<p>这里面最主要的还是这个Index.html文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">    &lt;!--%PUBLIC_URL%表示public文件夹的路径--&gt;</span><br><span class="line">    &lt;link rel=&quot;icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt;</span><br><span class="line">    &lt;!--用于开启理想视口，用于移动端页面的适配--&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;</span><br><span class="line">    &lt;!--用于配置浏览器地址栏的颜色（仅支持安卓手机浏览器）--&gt;</span><br><span class="line">    &lt;meta name=&quot;theme-color&quot; content=&quot;#000000&quot; /&gt;</span><br><span class="line">    &lt;!--描述网页信息的--&gt;</span><br><span class="line">    &lt;meta</span><br><span class="line">      name=&quot;description&quot;</span><br><span class="line">      content=&quot;Web site created using create-react-app&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">    &lt;!--用于指定网页添加到手机主屏幕后的图标（仅仅支持ios）--&gt;</span><br><span class="line">    &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;%PUBLIC_URL%/logo192.png&quot; /&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;!--应用加壳时候的配置文件 --&gt;</span><br><span class="line">    &lt;link rel=&quot;manifest&quot; href=&quot;%PUBLIC_URL%/manifest.json&quot; /&gt;</span><br><span class="line">  </span><br><span class="line">    &lt;title&gt;React App&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;!-- 浏览器不支持JS的运行的时候展现 --&gt;</span><br><span class="line">    &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;</span><br><span class="line">    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>src文件：</p>
<p><img src="C:\Users\86136\Desktop\repository\notes\FrontEnd\images\1611818262317.png" alt="src文件"></p>
<p>这里面其实最主要的就是App.js以及index.js，一个是组件，一个是将组件渲染到页面中的。</p>
<h2 id="第一个脚手架应用"><a href="#第一个脚手架应用" class="headerlink" title="第一个脚手架应用"></a>第一个脚手架应用</h2><p>1.我们保持public中的Index.html不变</p>
<p>2.修改src下面的APP.js以及index.js文件</p>
<p>App.js:  【注意：创建好的组件一定要暴露出去】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建外壳组件APPimport React from &#x27;react&#x27;class App extends React.Component&#123;    render()&#123;        return (            &lt;div&gt;Hello word&lt;/div&gt;        )    &#125;&#125;export default App</span><br></pre></td></tr></table></figure>

<p>index.js: 【主要的作用其实就是将App这个组件渲染到页面上】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//引入核心库import React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;//引入组件import App from &#x27;./App&#x27;ReactDOM.render(&lt;App /&gt;,document.getElementById(&quot;root&quot;))</span><br></pre></td></tr></table></figure>

<p>这样在重新启动应用，就成功了。</p>
<p><img src="C:\Users\86136\Desktop\repository\notes\FrontEnd\images\1611820194124.png" alt="第一个脚手架应用"></p>
<p>我们也不建议这样直接将内容放入App组件中，尽量还是用内部组件。</p>
<p>我们在顶一个Hello组件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React,&#123;Componet&#125; from &#x27;react&#x27;export default class Hello extends Componet&#123;    render() &#123;        return (            &lt;h1&gt;Hello&lt;/h1&gt;        )    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>在App组件中，进行使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class App extends Component&#123;    render()&#123;        return (            &lt;div&gt;                &lt;Hello /&gt;            &lt;/div&gt;        )    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>这样的结果和前面是一样的。</p>
<p>但是由于普通的Js和组件都是js，所一最好组件使用jsx去展示。</p>
<h2 id="样式冲突"><a href="#样式冲突" class="headerlink" title="样式冲突"></a>样式冲突</h2><p>当组件逐渐增多起来的时候，我们发现，组件的样式也是越来越丰富，这样就很有可能产生两个组件中样式名称有可能会冲突，这样会根据引入App这个组件的先后顺序，后面的会覆盖前面的，</p>
<p>为了避免这样的样式冲突，我们采用下面的形式：</p>
<p>1.将css文件名修改： hello.css — &gt;hello.module.css</p>
<p>2.引入并使用的时候改变方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React,&#123;Component&#125;from &#x27;react&#x27;</span><br><span class="line">import hello from &#x27;./hello.module.css&#x27;  //引入的时候给一个名称</span><br><span class="line"></span><br><span class="line">export default class Hello extends Component&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;h1 className=&#123;hello.title&#125;&gt;Hello&lt;/h1&gt;   //通过大括号进行调用</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="9-功能界面的组件化编码流程"><a href="#9-功能界面的组件化编码流程" class="headerlink" title="9. 功能界面的组件化编码流程"></a>9. 功能界面的组件化编码流程</h1><p>1.拆分组件:拆分界面，抽取组件</p>
<p>2.实现静态组件</p>
<p>3.实现动态组件</p>
<ul>
<li>动态的显示初始化数据<ul>
<li>数据类型</li>
<li>数据名称</li>
<li>保存在哪个组件</li>
</ul>
</li>
<li>交互</li>
</ul>
<p><strong>注意事项：</strong></p>
<p>1.拆分组件、实现静态组件。注意className、style的写法</p>
<p>2.动态初始化列表，如何确定将数据放在哪个组件的state中？</p>
<ul>
<li>某个组件使用：放在自身的state中</li>
<li>某些组件使用：放在他们共同的父组件中【状态提升】</li>
</ul>
<p>3.关于父子组件之间的通信</p>
<ul>
<li>父组件给子组件传递数据：通过props传递</li>
<li>子组件给父组件传递数据：通过props传递，要求父组件提前给子组件传递一个函数</li>
</ul>
<p>4.注意defaultChecked 和checked区别，defalutChecked只是在初始化的时候执行一次，checked没有这个限制，但是必须添加onChange方法类似的还有：defaultValue 和value</p>
<p>5.状态在哪里，操作状态的方法就在哪里</p>
<h1 id="10-react-ajax"><a href="#10-react-ajax" class="headerlink" title="10. react ajax"></a>10. react ajax</h1><p>React本身只关注与页面，并不包含发送ajax请求的代码，所以一般都是集成第三方的一些库，或者自己进行封装。</p>
<p>推荐使用axios。</p>
<p>在使用的过程中很有可能会出现跨域的问题，这样就应该配置代理。</p>
<p> 所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）， 当一个请求url的<strong>协议、域名、端口</strong>三者之间任意一个与当前页面url不同即为跨域  。</p>
<p>那么react通过代理解决跨域问题呢</p>
<p><strong>方法一</strong></p>
<blockquote>
<p>在package.json中追加如下配置</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;proxy&quot;</span>:<span class="string">&quot;请求的地址&quot;</span>      <span class="string">&quot;proxy&quot;</span>:<span class="string">&quot;http://localhost:5000&quot;</span>  </span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>优点：配置简单，前端请求资源时可以不加任何前缀。</li>
<li>缺点：不能配置多个代理。</li>
<li>工作方式：上述方式配置代理，当请求了3000不存在的资源时，那么该请求会转发给5000 （优先匹配前端资源）</li>
</ol>
<p><strong>方法二</strong></p>
<ol>
<li><p>第一步：创建代理配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在src下创建配置文件：src/setupProxy.js</span><br></pre></td></tr></table></figure></li>
<li><p>编写setupProxy.js配置具体代理规则：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>)<span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">app</span>) </span>&#123;  app.use(    proxy(<span class="string">&#x27;/api1&#x27;</span>, &#123;  <span class="comment">//api1是需要转发的请求(所有带有/api1前缀的请求都会转发给5000)      target: &#x27;http://localhost:5000&#x27;, //配置转发目标地址(能返回数据的服务器地址)      changeOrigin: true, //控制服务器接收到的请求头中host字段的值      /*      	changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000      	changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:3000      	changeOrigin默认值为false，但我们一般将changeOrigin值设为true      */      pathRewrite: &#123;&#x27;^/api1&#x27;: &#x27;&#x27;&#125; //去除请求前缀，保证交给后台服务器的是正常请求地址(必须配置)    &#125;),    proxy(&#x27;/api2&#x27;, &#123;       target: &#x27;http://localhost:5001&#x27;,      changeOrigin: true,      pathRewrite: &#123;&#x27;^/api2&#x27;: &#x27;&#x27;&#125;    &#125;)  )&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>说明：</p>
<ol>
<li>优点：可以配置多个代理，可以灵活的控制请求是否走代理。</li>
<li>缺点：配置繁琐，前端请求资源时必须加前缀。</li>
</ol>
<h1 id="11-兄弟之间进行通信"><a href="#11-兄弟之间进行通信" class="headerlink" title="11. 兄弟之间进行通信"></a>11. 兄弟之间进行通信</h1><h3 id="消息订阅和发布机制。"><a href="#消息订阅和发布机制。" class="headerlink" title="消息订阅和发布机制。"></a><strong>消息订阅</strong>和<strong>发布机制</strong>。</h3><p>举个例子来说就是张三想要跟李四进行通信，张三就需要订阅一个消息【比如A消息】，李四想要给张三数据，就必须发布一个A消息，在发布的同时将数据放入消息中，因为张三订阅了名称为A的消息，此时就能接受到李四发布的消息，从而获取到数据。</p>
<p>这就有点类似于看报纸，甲想要知道每天都发生什么事情，于是订阅了每天日报，乙每天都会发布这个每天日报，因为甲订阅了，于是乙就会每天就给甲方推送，甲方从而获取数据。</p>
<p><strong>在消息订阅和发布中，我们可以使用PubSubJs进行通信：</strong></p>
<p>引入PubSubJs:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import PubSub from &#x27;pubsub-js&#x27;</span><br></pre></td></tr></table></figure>

<p>订阅消息：（接收数据方）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PubSub.subscribe(&quot;getSate&quot;,(_,data)=&gt;&#123;</span><br><span class="line">            console.log(data)</span><br><span class="line">        &#125;)</span><br><span class="line">PubSub.subscribe(&quot;订阅的消息名称&quot;,回调函数，第一个参数是消息名称，可以使用_来占位，第二个是传递的数据</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p>发布消息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PubSub.publish(&quot;getSate&quot;,&#123;isFrist:false,isLoad:true&#125;)</span><br><span class="line">PubSub.publish(&quot;订阅的消息名称&quot;,传递的数据)</span><br></pre></td></tr></table></figure>



<h3 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h3><p><strong>async:</strong></p>
<p>该关键字是放在函数之前的，使得函数成为一个异步函数，他最大的特点就是将函数回封装成Promise，也就是被他修饰的函数的返回值都是Promise对象。而这个Promise对象的状态则是由函数执行的返回值决定的。</p>
<p>如果返回的是一个非promise对象，该函数将返回一个成功的Promise，成功的值则是返回的值；</p>
<p>如果返回的是一个promise对象，则该函数返回的就是该promise对应的状态。</p>
<p><strong>await</strong></p>
<p>await右边是一个表达式，如果该表达式返回的是一个Promise对象，则左边接收的结果就是该Promise对象成功的结果，如果该Promise对象失败了，就必须使用try..catch来捕获。如果该表达式返回的是是一个不是promise对象，则左边接受的就是该表达式的返回值。</p>
<p> 当 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await">await</a> 关键字与异步函数一起使用时，它的真正优势就变得明显了 —— 事实上， <strong>await 只在异步函数里面才起作用</strong>。它可以放在任何异步的，基于 promise 的函数之前。它会暂停代码在该行上，直到 promise 完成，然后返回结果值。在暂停的同时，其他正在等待执行的代码就有机会执行了。 </p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f1 = () =&gt;&#123;</span><br><span class="line">       return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">           // resolve(1);</span><br><span class="line">           reject(&quot;错误&quot;)</span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   async function test()&#123;</span><br><span class="line">       try&#123;</span><br><span class="line">          const p =  await f1();</span><br><span class="line">          console.log(p)</span><br><span class="line">       &#125;catch(error)&#123;</span><br><span class="line">           console.error(error)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   test();</span><br></pre></td></tr></table></figure>

<h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><p>以前发送请求，使用ajax或者axios，现在还可以使用fetch。这个是window自带的，和xhr是一个级别的。</p>
<p>可以查看这个文章，写的真的不错：</p>
<p><a href="http://www.ruanyifeng.com/blog/2020/12/fetch-tutorial.html">fetch</a></p>
<h1 id="12-React路由"><a href="#12-React路由" class="headerlink" title="12. React路由"></a>12. React路由</h1><h2 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h2><ul>
<li><p><strong>单页Web应用</strong>(single page web application，SPA)。</p>
</li>
<li><p>整个应用只有<strong>一个完整的页面</strong>。</p>
</li>
<li><p>点击页面中的链接<strong>不会刷新页面</strong>，只会做页面的<strong>局部更新</strong>。</p>
</li>
<li><p>数据都需要通过<strong>ajax</strong>请求获取,并在前端<strong>异步</strong>展现</p>
</li>
</ul>
<h2 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h2><ul>
<li><p>一个路由其实就是一个映射关系（k:v）</p>
</li>
<li><p>key为路径，value可能是function 或者是 component</p>
</li>
</ul>
<p><strong>后端路由：</strong></p>
<ul>
<li><p>value是function，用来处理客户端提交的请求</p>
</li>
<li><p>注册路由：router.get(path,function(req,res))</p>
</li>
<li><p>工作过程：当node接收一个请求的时候，根据请求路径找到匹配的路由，调用路由中的函数来处理请求，返回响应的数据</p>
</li>
</ul>
<p><strong>前端路由：</strong></p>
<ul>
<li><p>浏览器端路由，value是Component，用于展示页面内容</p>
</li>
<li><p>注册路由：&lt; Route path=”/test” component={Test}&gt;</p>
</li>
<li><p>工作过程：当浏览器的path变为/test的时候，当前路由组件就会变成Test组件</p>
</li>
</ul>
<p><strong>前端路由的原理</strong></p>
<ul>
<li><p>主要是依靠于<strong>history</strong>，也就是浏览器的历史记录。</p>
</li>
<li><p>浏览器上的记录其实就是一个栈，前进一次就是<strong>入栈</strong>，后退一次就是<strong>出栈</strong>。</p>
</li>
<li><p>并且历史记录上有一个监听的方法，可以时时刻刻监听记录的变化。从而判断是否改变路径</p>
</li>
</ul>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History">History</a></p>
<h2 id="react-router-dom"><a href="#react-router-dom" class="headerlink" title="react-router-dom"></a>react-router-dom</h2><p>react的路由有三类：</p>
<ul>
<li><p>web【主要适用于前端】</p>
</li>
<li><p>native【主要适用于本地】</p>
</li>
<li><p>anywhere【任何地方】</p>
</li>
</ul>
<p>在这主要使用web也就是这个标题 react-router-dom</p>
<p><strong>基本的使用：</strong></p>
<p>导航中的a标签改写成Link标签</p>
<p>&lt; Link to=”/路径” &gt;xxx&lt; /Link&gt;</p>
<p>展示区写Route标签进行路径的匹配</p>
<p>&lt; Route path = ‘/路径’ component={组件名称}&gt;</p>
<p>&lt; App&gt;最外侧包裹了一个&lt; BrowserRouter&gt;或者&lt; HashRouter&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div className=&quot;list-group&quot;&gt;</span><br><span class="line">    &lt;Link className=&quot;list-group-item&quot;  to=&quot;/about&quot;&gt;About&lt;/Link&gt;</span><br><span class="line">    &lt;Link className=&quot;list-group-item&quot;  to=&quot;/home&quot;&gt;Home&lt;/Link&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div className=&quot;panel-body&quot;&gt;</span><br><span class="line">    &#123;/* 注册路由，也就是写对应的关系 */&#125;</span><br><span class="line">    &lt;Route path=&quot;/about&quot;component=&#123;About&#125;/&gt;</span><br><span class="line">    &lt;Route path=&quot;/home&quot;component=&#123;Home&#125;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">index.js:</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;App /&gt;</span><br><span class="line">    &lt;/BrowserRouter&gt;</span><br><span class="line">    ,document.getElementById(&quot;root&quot;))</span><br></pre></td></tr></table></figure>

<p>那么使用Link代替a标签之后，在页面上会是什么呢，我们发现其实页面上也是把link转化为了a标签</p>
<p><strong>路由组件以及一般组件</strong></p>
<p>1.写法不一样</p>
<p>​    一般组件：&lt; Demo&gt;</p>
<p>​    路由组件：&lt; Route path=”/demo” component ={Demo}/&gt;</p>
<p>2.存放的位置一般不同</p>
<p>​    一般组件：components</p>
<p>​    路由组件：pages</p>
<p>3.接收的内容【props】</p>
<p>​    一般组件：写组件标签的时候传递什么，就能收到什么</p>
<p>​    路由组件：接收到三个固定的属性【history,location,match】</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">history:    go: ƒ go(n)    goBack: ƒ goBack()    goForward: ƒ goForward()    push: ƒ push(path, state)    replace: ƒ replace(path, state)location:    pathname: <span class="string">&quot;/about&quot;</span>    search: <span class="string">&quot;&quot;</span>    state: undefinedmatch:    params: &#123;&#125;    path: <span class="string">&quot;/about&quot;</span>    url: <span class="string">&quot;/about&quot;</span></span><br></pre></td></tr></table></figure>



<p><strong>NavLink</strong></p>
<p>因为Link不能够改变标签体，因此只适合用于一些写死的标签。而如果想要有一些点击的效果，使用NavLink.</p>
<p>如下代码，就写了<strong>activeClassName</strong>，当点击的时候就会触发这个class的样式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;/*NavLink在点击的时候就会去找activeClassName=&quot;ss&quot;所指定的class的值，如果不添加默认是active</span><br><span class="line"> 这是因为Link相当于是把标签写死了，不能去改变什么。*/&#125;</span><br><span class="line"></span><br><span class="line">&lt;NavLink  ctiveClassName=&quot;ss&quot; className=&quot;list-group-item&quot;  to=&quot;/about&quot;&gt;About&lt;/NavLink&gt;</span><br><span class="line">&lt;NavLink className=&quot;list-group-item&quot;  to=&quot;/home&quot;&gt;Home&lt;/NavLink&gt; </span><br></pre></td></tr></table></figure>

<p>但是可能一个导航又很多标签，如果这样重复的写NavLink也会造成很多的重复性的代码问题。</p>
<p>因此可以自定义一个NavLink：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> // 通过&#123;...对象&#125;的形式解析对象，相当于将对象中的属性全部展开</span><br><span class="line"> //&lt;NavLink  to = &#123;this.props.to&#125; children = &#123;this.props.children&#125;/&gt;</span><br><span class="line">&lt;NavLink className=&quot;list-group-item&quot; &#123;...this.props&#125;/&gt;</span><br></pre></td></tr></table></figure>

<p>​    在使用的时候：直接写每个标签中不一样的部分就行，比如路径和名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将NavLink进行封装，成为MyNavLink,通过props进行传参数，标签体内容props是特殊的一个属性，叫做children </span><br><span class="line">&lt;MyNavLink to = &quot;/about&quot; &gt;About&lt;/MyNavLink&gt;</span><br></pre></td></tr></table></figure>



<p>补充：</p>
<p><strong>Switch</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;/* 注册路由 */&#125;&lt;Switch&gt;	&lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;	&lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt;		&#123;/* 不往下匹配，提高效率 */&#125;	&lt;Route path=&quot;/home&quot; component=&#123;Test&#125;/&gt;&lt;/Switch&gt;</span><br></pre></td></tr></table></figure>





<h2 id="样式错误"><a href="#样式错误" class="headerlink" title="样式错误"></a>样式错误</h2><p>拿上面的案例来说：</p>
<p>这里面会有一个样式：</p>
<p><img src="C:\Users\86136\Desktop\repository\notes\FrontEnd\images\1612316916900.png" alt="样式表"></p>
<p>此时，加载该样式的路径为：</p>
<p><img src="C:\Users\86136\Desktop\repository\notes\FrontEnd\images\1612317786643.png" alt="加载样式路径"></p>
<p>但是在写路由的时候，有的时候就会出现多级目录，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;MyNavLink to = &quot;/cyk/about&quot; &gt;About&lt;/MyNavLink&gt;</span><br><span class="line"></span><br><span class="line">&lt;Route path=&quot;/cyk/about&quot;component=&#123;About&#125;/&gt;</span><br></pre></td></tr></table></figure>

<p>这个时候就在刷新页面，就会出现问题：</p>
<p>样式因为路径问题加载失败，此时页面返回public下面的Index.html</p>
<p><img src="C:\Users\86136\Desktop\repository\notes\FrontEnd\images\1612317880916.png" alt="加载页面失败"></p>
<p>解决这个问题，有三个方法：</p>
<p>1.样式加载使用绝对位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link href=&quot;/css/bootstrap.css&quot; rel=&quot;stylesheet&quot;&gt; </span><br></pre></td></tr></table></figure>

<p>2.使用 %PUBLIC_URL%</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link href=&quot;%PUBLIC_URL%/css/bootstrap.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>3.使用HashRouter</p>
<p>因为HashRouter会添加#，默认不会处理#后面的路径，所以也是可以解决的</p>
<h2 id="模糊匹配和精准匹配"><a href="#模糊匹配和精准匹配" class="headerlink" title="模糊匹配和精准匹配"></a>模糊匹配和精准匹配</h2><p>react默认是开启模糊匹配的。</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;MyNavLink to = &quot;/home/a/b&quot; &gt;Home&lt;/MyNavLink&gt;</span><br></pre></td></tr></table></figure>

<p>此时该标签匹配的路由，分为三个部分 home a b；将会根据这个<strong>先后顺序匹配</strong>路由。</p>
<p>如下就可以匹配到相应的路由：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Route path=&quot;/home&quot;component=&#123;Home&#125;/&gt;</span><br></pre></td></tr></table></figure>

<p>但是如果是下面这个就会失败，也就是说他是根据路径一级一级查询的，可以包含前面那一部分，但并不是只包含部分就可以。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Route path=&quot;/a&quot; component=&#123;Home&#125;/&gt;</span><br></pre></td></tr></table></figure>

<p>当然也可以使用这个精确的匹配 exact={true}</p>
<p>如以下：这样就精确的匹配/home，则上面的/home/a/b就不行了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Route exact=&#123;true&#125;  path=&quot;/home&quot; component=&#123;Home&#125;/&gt;或者&lt;Route exact path=&quot;/home&quot; component=&#123;Home&#125;/&gt;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h2 id="初始化路由"><a href="#初始化路由" class="headerlink" title="初始化路由"></a>初始化路由</h2><p>在配置好路由，最开始打开页面的时候，应该是不会匹配到任意一个组件。这个时候页面就显得极其不合适，此时应该默认的匹配到一个组件。</p>
<p><img src="C:\Users\86136\Desktop\repository\notes\FrontEnd\images\RouterDef.gif" alt="空组件"></p>
<p>此时就需要使用Redirect进行<strong>默认匹配</strong>了。如下的代码就是默认匹配/home路径所到的组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Switch&gt;    &lt;Route path=&quot;/about&quot;component=&#123;About&#125;/&gt;    &#123;/* exact=&#123;true&#125;：开启严格匹配的模式，路径必须一致 */&#125;    &lt;Route   path=&quot;/home&quot; component=&#123;Home&#125;/&gt;    &#123;/* Redirect:如果上面的都没有匹配到，就匹配到这个路径下面 */&#125;    &lt;Redirect  to = &quot;/home&quot;/&gt;&lt;/Switch&gt;</span><br></pre></td></tr></table></figure>

<p>就可以做到如下的效果：</p>
<p><img src="C:\Users\86136\Desktop\repository\notes\FrontEnd\images\RouterSetDef.gif" alt="设置默认值"></p>
<h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p>简单来说就是在一个路由组件中又使用了一个路由，就形成了嵌套路由。</p>
<p>举个例子来说：</p>
<p>我们在home这个路由组件中又添加两个组件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">APP.jsx:</span><br><span class="line">&lt;Route   path=&quot;/home&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">Home.jsx:</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;ul className=&quot;nav nav-tabs&quot;&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">    	&lt;MyNavLink to = &quot;/home/news&quot;&gt;News&lt;/MyNavLink&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">    	&lt;MyNavLink  to = &quot;/home/message&quot;&gt;Message&lt;/MyNavLink&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;Switch&gt;</span><br><span class="line">        &lt;Route path = &quot;/home/news&quot; component=&#123;News&#125; /&gt;</span><br><span class="line">        &lt;Route path = &quot;/home/message&quot; component=&#123;Message&#125; /&gt;</span><br><span class="line">        &lt;Redirect to=&quot;/home/message&quot;/&gt;</span><br><span class="line">    &lt;/Switch&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p> react中路由的注册是有顺序的，因此在匹配的时候也是按照这个顺序进行的，因此会先匹配父组件中的路由 </p>
<p>比如上面的 /home/news的路由处理过程：</p>
<p>​    1.因为父组件home的路由是先注册的，因此在匹配的时候先去找home的路由，也就是根据/home/news先模糊匹配到/home</p>
<p>​    2.在去Home组件里面去匹配相应的路由，从而找到了/home/news进行匹配，因此找到了News组件。</p>
<p>但是如果开启精确匹配，就会在第一步的时候卡住，这个时候就走不下去了。<strong>因此不要轻易的使用精确匹配</strong></p>
<h2 id="向路由组件传递参数"><a href="#向路由组件传递参数" class="headerlink" title="向路由组件传递参数"></a>向路由组件传递参数</h2><p>1.<strong>params</strong>参数</p>
<ul>
<li><p>路由链接(携带参数)：</p>
</li>
<li><p>注册路由(声明接收)</p>
</li>
<li><p>接收参数：this.props.match.params</p>
</li>
</ul>
<p>2.<strong>search</strong>参数</p>
<ul>
<li><p>路由链接(携带参数)：&lt;Link to=’/demo/test?name=tom&amp;age=18’}&gt;详情</Link></p>
</li>
<li><p>注册路由(无需声明，正常注册即可)：<Route path="/demo/test" component={Test}/></p>
</li>
<li><p>接收参数：<strong>this.props.location.search</strong></p>
</li>
<li><p>备注：获取到的search是urlencoded编码字符串，需要借助querystring解析</p>
</li>
</ul>
<p>3.<strong>state</strong>参数</p>
<ul>
<li><p>路由链接(携带参数)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Link to=&#123;&#123;pathname:&#x27;/demo/test&#x27;,state:&#123;name:&#x27;tom&#x27;,age:18&#125;&#125;&#125;&gt;详情&lt;/Link&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>注册路由(无需声明，正常注册即可)：<Route path="/demo/test" component={Test}/></p>
</li>
<li><p>接收参数：this.props.location.state</p>
</li>
<li><p>备注：刷新也可以保留住参数</p>
</li>
<li><p>优点：<strong>url不暴露参数</strong></p>
</li>
</ul>
<h2 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h2><p>借助this.prosp.history对象上的API对操作路由跳转、前进、后退</p>
<ul>
<li><p>this.prosp.history.<strong>push</strong>()</p>
</li>
<li><p>this.prosp.history.<strong>replace</strong>()</p>
</li>
<li><p>this.prosp.history.goBack()</p>
</li>
<li><p>this.prosp.history.goForward()</p>
</li>
<li><p>this.prosp.history.go()</p>
</li>
</ul>
<h2 id="WithRouter"><a href="#WithRouter" class="headerlink" title="WithRouter"></a>WithRouter</h2><ul>
<li><p>withRouter可以加工一般组件，让一般组件具备路由组件所特有的API</p>
</li>
<li><p><strong>withRouter的返回值是一个新组件</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#x27;react&#x27;</span><br><span class="line">import &#123;withRouter&#125; from &#x27;react-router-dom&#x27;</span><br><span class="line"></span><br><span class="line">class Header extends Component &#123;</span><br><span class="line"></span><br><span class="line">	back = ()=&gt;&#123;</span><br><span class="line">		this.props.history.goBack()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	forward = ()=&gt;&#123;</span><br><span class="line">		this.props.history.goForward()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	go = ()=&gt;&#123;</span><br><span class="line">		this.props.history.go(-2)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	render() &#123;</span><br><span class="line">		console.log(&#x27;Header组件收到的props是&#x27;,this.props);</span><br><span class="line">		return (</span><br><span class="line">			&lt;div className=&quot;page-header&quot;&gt;</span><br><span class="line">				&lt;h2&gt;React Router Demo&lt;/h2&gt;</span><br><span class="line">				&lt;button onClick=&#123;this.back&#125;&gt;回退&lt;/button&gt;&amp;nbsp;</span><br><span class="line">				&lt;button onClick=&#123;this.forward&#125;&gt;前进&lt;/button&gt;&amp;nbsp;</span><br><span class="line">				&lt;button onClick=&#123;this.go&#125;&gt;go&lt;/button&gt;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default withRouter(Header)</span><br></pre></td></tr></table></figure>



<h2 id="BrowserRouter与HashRouter的区别"><a href="#BrowserRouter与HashRouter的区别" class="headerlink" title="BrowserRouter与HashRouter的区别"></a>BrowserRouter与HashRouter的区别</h2><p>1.底层原理不一样：</p>
<ul>
<li><p>BrowserRouter使用的是H5的history API，不兼容IE9及以下版本。</p>
</li>
<li><p>HashRouter使用的是URL的哈希值。</p>
</li>
</ul>
<p>2.path表现形式不一样</p>
<ul>
<li><p>BrowserRouter的路径中没有#,例如：localhost:3000/demo/test</p>
</li>
<li><p>HashRouter的路径包含#,例如：localhost:3000/#/demo/test</p>
</li>
</ul>
<p>3.刷新后对路由state参数的影响</p>
<p>​    (1).BrowserRouter没有任何影响，因为state保存在history对象中。</p>
<p>​    (2).<strong>HashRouter刷新后会导致路由state参数的丢失！！！</strong></p>
<p>4.备注：HashRouter可以用于解决一些路径错误相关的问题。</p>
<h1 id="13-antd的按需引入-自定主题"><a href="#13-antd的按需引入-自定主题" class="headerlink" title="13. antd的按需引入+自定主题"></a>13. antd的按需引入+自定主题</h1><p>   1.安装依赖：yarn add react-app-rewired customize-cra babel-plugin-import less less-loader</p>
<p>   2.修改package.json</p>
<p>​     ….</p>
<p>​      “scripts”: {</p>
<p>​       “start”: “react-app-rewired start”,</p>
<p>​       “build”: “react-app-rewired build”,</p>
<p>​       “test”: “react-app-rewired test”,</p>
<p>​       “eject”: “react-scripts eject”</p>
<p>​      },</p>
<p>​     ….</p>
<p>   3.根目录下创建config-overrides.js</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//配置具体的修改规则</span></span><br><span class="line"><span class="keyword">const</span> &#123; override, fixBabelImports,addLessLoader&#125; = <span class="built_in">require</span>(<span class="string">&#x27;customize-cra&#x27;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="built_in">module</span>.exports = override(</span><br><span class="line"></span><br><span class="line">      fixBabelImports(<span class="string">&#x27;import&#x27;</span>, &#123;</span><br><span class="line"></span><br><span class="line">      	 <span class="attr">libraryName</span>: <span class="string">&#x27;antd&#x27;</span>,</span><br><span class="line"></span><br><span class="line">      	 <span class="attr">libraryDirectory</span>: <span class="string">&#x27;es&#x27;</span>,</span><br><span class="line"></span><br><span class="line">      	 <span class="attr">style</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">      &#125;),</span><br><span class="line"></span><br><span class="line">      addLessLoader(&#123;</span><br><span class="line"></span><br><span class="line">       <span class="attr">lessOptions</span>:&#123;</span><br><span class="line"></span><br><span class="line">       	 <span class="attr">javascriptEnabled</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">       	 <span class="attr">modifyVars</span>: &#123; <span class="string">&#x27;@primary-color&#x27;</span>: <span class="string">&#x27;green&#x27;</span> &#125;,</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">      &#125;),</span><br><span class="line"></span><br><span class="line">     );</span><br></pre></td></tr></table></figure>
</code></pre>
<p>​    4.备注：不用在组件里亲自引入样式了，即：import ‘antd/dist/antd.css’应该删掉</p>
<h1 id="14-Redux"><a href="#14-Redux" class="headerlink" title="14. Redux"></a>14. Redux</h1><h2 id="redux理解"><a href="#redux理解" class="headerlink" title="redux理解"></a>redux理解</h2><h3 id="学习文档"><a href="#学习文档" class="headerlink" title="学习文档"></a>学习文档</h3><ol>
<li><p>英文文档: <a href="https://redux.js.org/">https://redux.js.org/</a></p>
</li>
<li><p>中文文档: <a href="http://www.redux.org.cn/">http://www.redux.org.cn/</a></p>
</li>
<li><p>Github: <a href="https://github.com/reactjs/redux">https://github.com/reactjs/redux</a></p>
</li>
</ol>
<h3 id="redux是什么"><a href="#redux是什么" class="headerlink" title="redux是什么"></a>redux是什么</h3><ol>
<li><p>redux是一个专门用于做<strong>状态管理</strong>的JS库(不是react插件库)。</p>
</li>
<li><p>它可以用在react, angular, vue等项目中, 但基本与react配合使用。</p>
</li>
<li><p>作用: 集中式管理react应用中多个组件<strong>共享</strong>的状态。</p>
</li>
</ol>
<h3 id="什么情况下需要使用redux"><a href="#什么情况下需要使用redux" class="headerlink" title="什么情况下需要使用redux"></a>什么情况下需要使用redux</h3><ol>
<li><p>某个组件的状态，需要让其他组件可以随时拿到（<strong>共享</strong>）。</p>
</li>
<li><p>一个组件需要改变另一个组件的状态（<strong>通信</strong>）。</p>
</li>
<li><p>总体原则：能不用就不用, 如果不用时比较吃力才考虑使用。</p>
</li>
</ol>
<h3 id="redux工作流程"><a href="#redux工作流程" class="headerlink" title="redux工作流程"></a>redux工作流程</h3><p><img src="C:\Users\86136\Desktop\repository\notes\FrontEnd\images\redux原理图.png" alt="redux原理图"></p>
<h2 id="redux的三个核心概念"><a href="#redux的三个核心概念" class="headerlink" title="redux的三个核心概念"></a>redux的三个核心概念</h2><h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><ol>
<li><p>动作的对象</p>
</li>
<li><p>包含2个属性</p>
<p>type：标识属性, 值为字符串, 唯一, 必要属性</p>
<p>data：数据属性, 值类型任意, 可选属性</p>
</li>
<li><p>例子：{ type: ‘ADD_STUDENT’,data:{name: ‘tom’,age:18} }</p>
</li>
</ol>
<h3 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h3><ol>
<li><p>用于<strong>初始化</strong>状态、<strong>加工</strong>状态。</p>
</li>
<li><p>加工时，根据旧的state和action， 产生新的state的<strong>纯函数</strong>。</p>
</li>
</ol>
<h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><ol>
<li><p>将state、action、reducer联系在一起的对象</p>
</li>
<li><p>如何得到此对象?</p>
<ol>
<li><p>  import {createStore} from ‘redux’</p>
</li>
<li><p>  import reducer from ‘./reducers’</p>
</li>
<li><p>  const store = createStore(reducer)</p>
</li>
</ol>
</li>
<li><p>此对象的功能?</p>
<ol>
<li><p>  getState(): 得到state</p>
</li>
<li><p>  dispatch(action): 分发action, 触发reducer调用, 产生新的state</p>
</li>
<li><p>  subscribe(listener): 注册监听, 当产生了新的state时, 自动调用</p>
</li>
</ol>
</li>
</ol>
<h2 id="redux的核心API"><a href="#redux的核心API" class="headerlink" title="redux的核心API"></a>redux的核心API</h2><h3 id="createstore"><a href="#createstore" class="headerlink" title="createstore()"></a>createstore()</h3><p>作用：创建包含指定reducer的store对象</p>
<h3 id="store对象"><a href="#store对象" class="headerlink" title="store对象"></a>store对象</h3><ol>
<li><p>作用: redux库最核心的管理对象</p>
</li>
<li><p>它内部维护着:</p>
<ol>
<li><p>  state</p>
</li>
<li><p>  reducer</p>
</li>
</ol>
</li>
<li><p>核心方法:</p>
<ol>
<li><p>  getState()</p>
</li>
<li><p>  dispatch(action)</p>
</li>
<li><p>  subscribe(listener)</p>
</li>
</ol>
</li>
<li><p>具体编码:</p>
<ol>
<li><p>  store.getState()</p>
</li>
<li><p>  store.dispatch({type:’INCREMENT’, number})</p>
</li>
<li><p>  store.subscribe(render)</p>
</li>
</ol>
</li>
</ol>
<h3 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware()"></a>applyMiddleware()</h3><p>作用：应用上基于redux的中间件(插件库)</p>
<h3 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers()"></a>combineReducers()</h3><p>作用：合并多个reducer函数</p>
<h2 id="使用redux编写应用"><a href="#使用redux编写应用" class="headerlink" title="使用redux编写应用"></a>使用redux编写应用</h2><p>  <strong>效果</strong></p>
<h4 id="1-求和案例-redux精简版"><a href="#1-求和案例-redux精简版" class="headerlink" title="1.求和案例_redux精简版"></a>1.求和案例_redux精简版</h4><p>  (1).去除Count组件自身的状态</p>
<p>  (2).src下建立:</p>
<ul>
<li><p>redux</p>
</li>
<li><p>store.js</p>
</li>
</ul>
<p>-count_reducer.js</p>
<p>  (3).store.js：</p>
<p>​     1).引入redux中的createStore函数，创建一个store</p>
<p>​     2).createStore调用时要传入一个为其服务的reducer</p>
<p>​     3).记得暴露store对象</p>
<p>  (4).count_reducer.js：</p>
<p>​     1).reducer的本质是一个函数，接收：preState,action，返回加工后的状态</p>
<p>​     2).reducer有两个作用：初始化状态，加工状态</p>
<p>​     3).reducer被第一次调用时，是store自动触发的，</p>
<p>​         传递的preState是undefined,</p>
<p>​         传递的action是:{type:‘@@REDUX/INIT_a.2.b.4}</p>
<p>  (5).在index.js中监测store中状态的改变，一旦发生改变重新渲染<App/></p>
<p>​    备注：redux只负责管理状态，至于状态的改变驱动着页面的展示，要靠我们自己写。</p>
<h4 id="2-求和案例-redux完整版"><a href="#2-求和案例-redux完整版" class="headerlink" title="2.求和案例_redux完整版"></a>2.求和案例_redux完整版</h4><p>  新增文件：</p>
<p>   1.count_action.js 专门用于创建action对象</p>
<p>   2.constant.js 放置容易写错的type值</p>
<h4 id="3-求和案例-redux异步action版"><a href="#3-求和案例-redux异步action版" class="headerlink" title="3.求和案例_redux异步action版"></a>3.求和案例_redux异步action版</h4><blockquote>
<p>异步action，就是指action的值为函数.</p>
<p>异步action中一般都会调用同步action，异步action不是必须要用的。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//store.js引入redux-thunk，用于支持异步action</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createIncrementAsyncAction = <span class="function">(<span class="params">data,time</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>)=&gt;</span>&#123;</span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">			dispatch(createIncrementAction(data))</span><br><span class="line">		&#125;,time)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> (1).明确：延迟的动作不想交给组件自身，想交给action</p>
<p>   (2).何时需要异步action：想要对状态进行操作，但是具体的数据靠异步任务返回。</p>
<p>   (3).具体编码：</p>
<p>​     1).yarn add redux-thunk，并配置在store中</p>
<p>​     2).创建action的函数不再返回一般对象，而是一个<strong>函数</strong>，该函数中写异步任务。</p>
<p>​     3).异步任务有结果后，分发一个同步的action去真正操作数据。</p>
<p>   (4).备注：异步action不是必须要写的，完全可以自己等待异步任务的结果了再去分发同步action。</p>
<h4 id="4-求和案例-react-redux基本使用"><a href="#4-求和案例-react-redux基本使用" class="headerlink" title="4.求和案例_react-redux基本使用"></a>4.求和案例_react-redux基本使用</h4><p><img src="C:\Users\86136\Desktop\repository\notes\FrontEnd\images\react-redux模型图.png" alt="react-redux模型图"></p>
<p>   (1).明确两个概念：</p>
<p>​      1).<strong>UI组件</strong>:不能使用任何redux的api，只负责页面的呈现、交互等。</p>
<p>​      2).<strong>容器组件</strong>：负责和redux通信，将结果交给UI组件。</p>
<p>   (2).如何创建一个容器组件————靠react-redux 的 <strong>connect</strong>函数</p>
<ul>
<li><p>connect(mapStateToProps,mapDispatchToProps)(UI组件)</p>
</li>
<li><p>mapStateToProps:映射状态，返回值是一个对象</p>
</li>
<li><p>mapDispatchToProps:映射操作状态的方法，返回值是一个对象</p>
<p>(3).备注1：容器组件中的store是靠<strong>props</strong>传进去的，而不是在容器组件中        直接引入</p>
<p>(4).备注2：mapDispatchToProps，也可以是一个对象</p>
</li>
</ul>
<h4 id="5-求和案例-react-redux优化"><a href="#5-求和案例-react-redux优化" class="headerlink" title="5.求和案例_react-redux优化"></a>5.求和案例_react-redux优化</h4><p>(1).容器组件和UI组件整合一个文件</p>
<p>(2).无需自己给容器组件传递store，给<App/>包裹一个<Provider store={store}>即可。</p>
<p>(3).使用了react-redux后也不用再自己检测redux中状态的改变了，容器组件可以自动完成这个工作。</p>
<p>(4).mapDispatchToProps也可以简单的写成一个对象</p>
<p>(5).一个组件要和redux“打交道”要经过哪几步？</p>
<p>​       (1).定义好UI组件—不暴露</p>
<p>​       (2).引入connect生成一个容器组件，并暴露，写法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">connect(</span><br><span class="line">	<span class="function"><span class="params">state</span> =&gt;</span> (&#123;<span class="attr">key</span>:value&#125;), <span class="comment">//映射状态</span></span><br><span class="line">	&#123;<span class="attr">key</span>:xxxxxAction&#125; <span class="comment">//映射操作状态的方法</span></span><br><span class="line">)(UI组件)</span><br></pre></td></tr></table></figure>

<p>​       (4).在UI组件中通过this.props.xxxxxxx读取和操作状态</p>
<h4 id="6-求和案例-react-redux数据共享版"><a href="#6-求和案例-react-redux数据共享版" class="headerlink" title="6.求和案例_react-redux数据共享版"></a>6.求和案例_react-redux数据共享版</h4><p>   (1).定义一个Pserson组件，和Count组件通过redux共享数据。</p>
<p>   (2).为Person组件编写：reducer、action，配置constant常量。</p>
<p>   (3).重点：Person的reducer和Count的Reducer要使用combineReducers进行合并，</p>
<p>​     合并后的总状态是一个对象！！！</p>
<p>   (4).交给store的是总reducer，最后注意在组件中取出状态的时候，记得“取到位”。</p>
<h4 id="7-求和案例-react-redux开发者工具的使用"><a href="#7-求和案例-react-redux开发者工具的使用" class="headerlink" title="7.求和案例_react-redux开发者工具的使用"></a>7.求和案例_react-redux开发者工具的使用</h4><p>   (1).yarn add redux-devtools-extension</p>
<p>   (2).store中进行配置</p>
<p>import {composeWithDevTools} from ‘redux-devtools-extension’</p>
<p>const store=createStore(allReducer,composeWithDevTools(applyMiddleware(thunk)))</p>
<h4 id="8-求和案例-react-redux最终版"><a href="#8-求和案例-react-redux最终版" class="headerlink" title="8.求和案例_react-redux最终版"></a>8.求和案例_react-redux最终版</h4><p>   (1).所有变量名字要规范，尽量触发对象的简写形式。</p>
<p>   (2).reducers文件夹中，编写index.js专门用于汇总并暴露所有的reducer</p>
<h2 id="redux异步编程"><a href="#redux异步编程" class="headerlink" title="redux异步编程"></a>redux异步编程</h2><h3 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h3><ol>
<li><p>redux默认是不能进行异步处理的,</p>
</li>
<li><p>某些时候应用中需要在<strong>redux****中执行异步任务</strong>(ajax, 定时器)</p>
</li>
</ol>
<h3 id="使用异步中间件"><a href="#使用异步中间件" class="headerlink" title="使用异步中间件"></a>使用异步中间件</h3><p><code>npm install --save redux-thunk</code></p>
<h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ol>
<li><p>一个react插件库</p>
</li>
<li><p>专门用来简化react应用中使用redux</p>
</li>
</ol>
<h3 id="react-Redux将所有组件分成两大类"><a href="#react-Redux将所有组件分成两大类" class="headerlink" title="react-Redux将所有组件分成两大类"></a>react-Redux将所有组件分成两大类</h3><ol>
<li><p>UI组件</p>
<ol>
<li><p>  只负责 UI 的呈现，不带有任何业务逻辑</p>
</li>
<li><p>  通过props接收数据(一般数据和函数)</p>
</li>
<li><p>  不使用任何 Redux 的 API</p>
</li>
<li><p>  一般保存在components文件夹下</p>
</li>
</ol>
</li>
<li><p>容器组件</p>
<ol>
<li><p>  负责管理数据和业务逻辑，不负责UI的呈现</p>
</li>
<li><p>  使用 Redux 的 API</p>
</li>
<li><p>  一般保存在containers文件夹下</p>
</li>
</ol>
</li>
</ol>
<h3 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h3><ol>
<li><strong>Provider</strong>：让所有组件都可以得到state数据</li>
</ol>
<p><strong><Provider store={store}> <App/></Provider></strong>   </p>
<ol start="2">
<li><strong>connect</strong>：用于包装 UI 组件生成容器组件</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span> </span><br><span class="line"></span><br><span class="line">connect( mapStateToprops, mapDispatchToProps)(Counter)        </span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>mapStateToprops</strong>：将外部的数据（即state对象）转换为<strong>UI组件的标签属性</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	1.mapStateToProps函数返回的是一个对象；</span></span><br><span class="line"><span class="comment">	2.返回的对象中的key就作为传递给UI组件props的key,value就作为传递给UI组件props的value</span></span><br><span class="line"><span class="comment">	3.mapStateToProps用于传递状态</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> mapStateToprops = <span class="function"><span class="keyword">function</span> (<span class="params">state</span>) </span>&#123;    </span><br><span class="line">	<span class="keyword">return</span> &#123;    <span class="attr">value</span>: state    &#125;    </span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>mapDispatchToProps</strong>：将分发action的函数转换为UI组件的标签属性</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	1.mapDispatchToProps函数返回的是一个对象；</span></span><br><span class="line"><span class="comment">	2.返回的对象中的key就作为传递给UI组件props的key,value就作为传递给UI组件props的value</span></span><br><span class="line"><span class="comment">	3.mapDispatchToProps用于传递操作状态的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="attr">jia</span>:<span class="function"><span class="params">number</span> =&gt;</span> dispatch(createIncrementAction(number)),</span><br><span class="line">		<span class="attr">jian</span>:<span class="function"><span class="params">number</span> =&gt;</span> dispatch(createDecrementAction(number)),</span><br><span class="line">		<span class="attr">jiaAsync</span>:<span class="function">(<span class="params">number,time</span>) =&gt;</span> dispatch(createIncrementAsyncAction(number,time)),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用上redux调试工具"><a href="#使用上redux调试工具" class="headerlink" title="使用上redux调试工具"></a>使用上redux调试工具</h2><h3 id="安装chrome浏览器插件"><a href="#安装chrome浏览器插件" class="headerlink" title="安装chrome浏览器插件"></a>安装chrome浏览器插件</h3><h3 id="下载工具依赖包"><a href="#下载工具依赖包" class="headerlink" title="下载工具依赖包"></a>下载工具依赖包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save-dev redux-devtools-extension</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;composeWithDevTools&#125; <span class="keyword">from</span> <span class="string">&#x27;redux-devtools-extension&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store=createStore(allReducer,composeWithDevTools(applyMiddleware(thunk)))</span><br></pre></td></tr></table></figure>



<h2 id="纯函数和高阶函数"><a href="#纯函数和高阶函数" class="headerlink" title="纯函数和高阶函数"></a>纯函数和高阶函数</h2><h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><ol>
<li><p>一类特别的函数: <strong>只要是同样的输入(实参)，必定得到同样的输出(返回)</strong></p>
</li>
<li><p>必须遵守以下一些约束 </p>
<ol>
<li><p>  不得改写参数数据</p>
</li>
<li><p>  不会产生任何副作用，例如网络请求，输入和输出设备</p>
</li>
<li><p>  不能调用Date.now()或者Math.random()等不纯的方法 </p>
</li>
</ol>
</li>
<li><p><strong>redux的reducer函数必须是一个纯函数</strong></p>
</li>
</ol>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><ol>
<li><p>理解: 一类特别的函数</p>
<ol>
<li><p>  情况1: <strong>参数是函数</strong></p>
</li>
<li><p>  情况2: <strong>返回是函数</strong></p>
</li>
</ol>
</li>
<li><p>常见的高阶函数: </p>
<ol>
<li><p>  定时器设置函数</p>
</li>
<li><p>  数组的forEach()/map()/filter()/reduce()/find()/bind()</p>
</li>
<li><p>  promise</p>
</li>
<li><p>  react-redux中的connect函数</p>
</li>
</ol>
</li>
<li><p>作用: 能实现更加动态, 更加可扩展的功能</p>
</li>
</ol>
<h1 id="15-React扩展"><a href="#15-React扩展" class="headerlink" title="15. React扩展"></a>15. React扩展</h1><h3 id="1-setState"><a href="#1-setState" class="headerlink" title="1. setState"></a>1. setState</h3><h5 id="setState更新状态的2种写法"><a href="#setState更新状态的2种写法" class="headerlink" title="setState更新状态的2种写法"></a>setState更新状态的2种写法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1). setState(stateChange, [callback])------对象式的setState</span><br><span class="line">    1.stateChange为状态改变对象(该对象可以体现出状态的更改)</span><br><span class="line">    2.callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用</span><br><span class="line">					</span><br><span class="line">(2). setState(updater, [callback])------函数式的setState</span><br><span class="line">    1.updater为返回stateChange对象的函数。</span><br><span class="line">    2.updater可以接收到state和props。</span><br><span class="line">    4.callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。</span><br><span class="line">总结:</span><br><span class="line">	1.对象式的setState是函数式的setState的简写方式(语法糖)</span><br><span class="line">	2.使用原则：</span><br><span class="line">		(1).如果新状态不依赖于原状态 ===&gt; 使用对象方式</span><br><span class="line">		(2).如果新状态依赖于原状态 ===&gt; 使用函数方式</span><br><span class="line">		(3).如果需要在setState()执行后获取最新的状态数据, 要在第二个callback函数中读取</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-lazyLoad"><a href="#2-lazyLoad" class="headerlink" title="2. lazyLoad"></a>2. lazyLoad</h3><h5 id="路由组件的lazyLoad"><a href="#路由组件的lazyLoad" class="headerlink" title="路由组件的lazyLoad"></a>路由组件的lazyLoad</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.通过React的lazy函数配合import()函数动态加载路由组件 ===&gt; 路由组件代码会被分开打包</span></span><br><span class="line"><span class="keyword">const</span> Login = lazy(<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;@/pages/Login&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.通过&lt;Suspense&gt;指定在加载得到路由打包文件前显示一个自定义loading界面</span></span><br><span class="line">&lt;Suspense fallback=&#123;<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>loading.....<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>&#125;&gt;</span><br><span class="line">       <span class="xml"><span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">           <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/xxx&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Xxxx&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">           <span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&quot;/login&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line">   &lt;/Suspense&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="3-Hooks"><a href="#3-Hooks" class="headerlink" title="3. Hooks"></a>3. Hooks</h3><h5 id="1-React-Hook-Hooks是什么"><a href="#1-React-Hook-Hooks是什么" class="headerlink" title="1. React Hook/Hooks是什么?"></a>1. React Hook/Hooks是什么?</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1). Hook是React 16.8.0版本增加的新特性/新语法</span><br><span class="line">(2). 可以让你在函数组件中使用 state 以及其他的 React 特性</span><br></pre></td></tr></table></figure>

<h5 id="2-三个常用的Hook"><a href="#2-三个常用的Hook" class="headerlink" title="2. 三个常用的Hook"></a>2. 三个常用的Hook</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1). State Hook: React.useState()</span><br><span class="line">(2). Effect Hook: React.useEffect()</span><br><span class="line">(3). Ref Hook: React.useRef()</span><br></pre></td></tr></table></figure>

<h5 id="State-Hook"><a href="#State-Hook" class="headerlink" title="State Hook"></a>State Hook</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1). State Hook让函数组件也可以有state状态, 并进行状态数据的读写操作</span><br><span class="line">(2). 语法: const [xxx, setXxx] = React.useState(initValue)  </span><br><span class="line">(3). useState()说明:</span><br><span class="line">        参数: 第一次初始化指定的值在内部作缓存</span><br><span class="line">        返回值: 包含2个元素的数组, 第1个为内部当前状态值, 第2个为更新状态值的函数</span><br><span class="line">(4). setXxx()2种写法:</span><br><span class="line">        setXxx(newValue): 参数为非函数值, 直接指定新的状态值, 内部用其覆盖原来的状态值</span><br><span class="line">        setXxx(value =&gt; newValue): 参数为函数, 接收原本的状态值, 返回新的状态值, 内部用其覆盖原来的状态值</span><br></pre></td></tr></table></figure>

<h5 id="Effect-Hook"><a href="#Effect-Hook" class="headerlink" title="Effect Hook"></a>Effect Hook</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1). Effect Hook 可以让你在函数组件中执行副作用操作(用于模拟类组件中的生命周期钩子)</span><br><span class="line">(2). React中的副作用操作:</span><br><span class="line">        发ajax请求数据获取</span><br><span class="line">        设置订阅 / 启动定时器</span><br><span class="line">        手动更改真实DOM</span><br><span class="line">(3). 语法和说明: </span><br><span class="line">        useEffect(() =&gt; &#123; </span><br><span class="line">          // 在此可以执行任何带副作用操作</span><br><span class="line">          return () =&gt; &#123; // 在组件卸载前执行（相当于componentWillUnMount）</span><br><span class="line">            // 在此做一些收尾工作, 比如清除定时器/取消订阅等</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, [stateValue]) // 如果指定的是[], 回调函数只会在第一次render()后执行</span><br><span class="line">					   // 检测状态更新，不写则检测所有状态</span><br><span class="line">    </span><br><span class="line">(4). 可以把 useEffect Hook 看做如下三个函数的组合</span><br><span class="line">        componentDidMount()</span><br><span class="line">        componentDidUpdate()</span><br><span class="line">    	componentWillUnmount() </span><br></pre></td></tr></table></figure>

<h5 id="Ref-Hook"><a href="#Ref-Hook" class="headerlink" title="Ref Hook"></a>Ref Hook</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1). Ref Hook 可以在函数组件中存储/查找组件内的标签或任意其它数据</span><br><span class="line">(2). 语法: const refContainer = useRef()</span><br><span class="line">(3). 作用: 保存标签对象,功能与React.createRef()一样</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-Fragment"><a href="#4-Fragment" class="headerlink" title="4. Fragment"></a>4. Fragment</h3><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用方式：</span><br><span class="line">	1.&lt;Fragment&gt;&lt;Fragment&gt;	// 只能用于key属性</span><br><span class="line">	2.&lt;&gt;&lt;/&gt;  			   // 不允许传任何属性</span><br></pre></td></tr></table></figure>

<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><blockquote>
<p>可以不用必须有一个真实的DOM根标签了</p>
<p>（例：最外层不用包一个div）</p>
</blockquote>
<hr/>



<h3 id="5-Context"><a href="#5-Context" class="headerlink" title="5. Context"></a>5. Context</h3><h5 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h5><blockquote>
<p>一种组件间通信方式, 常用于【<strong>祖组件</strong>】与【<strong>后代组件</strong>】间通信</p>
</blockquote>
<h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>) 创建Context容器对象：	<span class="keyword">const</span> XxxContext = React.createContext()  	</span><br><span class="line"><span class="number">2</span>) 渲染子组时，外面包裹xxxContext.Provider, 通过value属性给后代组件传递数据：	&lt;xxxContext.Provider value=&#123;数据&#125;&gt;		子组件    &lt;/xxxContext.Provider&gt;    </span><br><span class="line"><span class="number">3</span>) 后代组件读取数据：	</span><br><span class="line">	<span class="comment">//第一种方式:仅适用于类组件 	  </span></span><br><span class="line">	<span class="keyword">static</span> contextType = xxxContext  <span class="comment">// 声明接收context	  </span></span><br><span class="line">	<span class="built_in">this</span>.context <span class="comment">// 读取context中的value数据	  	</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种方式: 函数组件与类组件都可以	  </span></span><br><span class="line">	&lt;xxxContext.Consumer&gt;	    </span><br><span class="line">        &#123;<span class="function"><span class="params">value</span> =&gt;</span> ( </span><br><span class="line">         <span class="comment">// value就是context中的value数据	        要显示的内容	      </span></span><br><span class="line">         )&#125;	  </span><br><span class="line">    &lt;/xxxContext.Consumer&gt;</span><br></pre></td></tr></table></figure>

<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在应用开发中一般不用context, 一般都用它的封装react插件</span><br></pre></td></tr></table></figure>

<hr/>



<h3 id="6-组件优化"><a href="#6-组件优化" class="headerlink" title="6. 组件优化"></a>6. 组件优化</h3><h5 id="Component的2个问题"><a href="#Component的2个问题" class="headerlink" title="Component的2个问题"></a>Component的2个问题</h5><blockquote>
<ol>
<li><p>只要执行setState(),即使不改变状态数据, 组件也会重新render() ==&gt; 效率低</p>
</li>
<li><p>只要当前组件重新render(), 就会自动重新render子组件，纵使子组件没有用到父组件的任何数据 ==&gt; 效率低</p>
</li>
</ol>
</blockquote>
<h5 id="效率高的做法"><a href="#效率高的做法" class="headerlink" title="效率高的做法"></a>效率高的做法</h5><blockquote>
<p> 只有当组件的state或props数据发生改变时才重新render()</p>
</blockquote>
<h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><blockquote>
<p> Component中的shouldComponentUpdate()总是返回true</p>
</blockquote>
<h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">办法1: 	</span><br><span class="line">	重写shouldComponentUpdate()方法	</span><br><span class="line">	比较新旧state或props数据, 如果有变化才返回true, 如果没有返回false</span><br><span class="line">办法2:  	</span><br><span class="line">	使用PureComponent	</span><br><span class="line">    PureComponent重写了shouldComponentUpdate(), 只有state或props数据有变化才返回true	</span><br><span class="line">	注意: 		</span><br><span class="line">		只是进行state和props数据的浅比较, 如果只是数据对象内部数据变了, 返回false  		不要直接修改state数据, 而是要产生新数据项目中一般使用PureComponent来优化</span><br></pre></td></tr></table></figure>

<hr/>



<h3 id="7-render-props"><a href="#7-render-props" class="headerlink" title="7. render props"></a>7. render props</h3><h5 id="如何向组件内部动态传入带内容的结构-标签"><a href="#如何向组件内部动态传入带内容的结构-标签" class="headerlink" title="如何向组件内部动态传入带内容的结构(标签)?"></a>如何向组件内部动态传入带内容的结构(标签)?</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue中: 	使用slot技术, 也就是通过组件标签体传入结构  &lt;A&gt;<span class="xml"><span class="tag">&lt;<span class="name">B</span>/&gt;</span></span>&lt;/A&gt;</span><br><span class="line">React中:	<span class="number">1.</span>使用children props: 通过组件标签体传入结构	（<span class="built_in">this</span>.props.children）</span><br><span class="line">		<span class="number">2.</span>使用render props: 通过组件标签属性传入结构,而且可以携带数据，一般用render函数属性</span><br></pre></td></tr></table></figure>

<h6 id="children-props"><a href="#children-props" class="headerlink" title="children props"></a>children props</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;A&gt;  &lt;B&gt;xxxx&lt;/B&gt;&lt;/A&gt;</span><br><span class="line">&#123;this.props.children&#125;</span><br><span class="line">问题: 如果B组件需要A组件内的数据, ==&gt; 做不到 </span><br></pre></td></tr></table></figure>

<h6 id="render-props"><a href="#render-props" class="headerlink" title="render props"></a>render props</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;A render=&#123;(data) =&gt; &lt;C data=&#123;data&#125;&gt;&lt;/C&gt;&#125;&gt;&lt;/A&gt;</span><br><span class="line">A组件: &#123;this.props.render(内部state数据)&#125;</span><br><span class="line">C组件: 读取A组件传入的数据显示 &#123;this.props.data&#125; </span><br></pre></td></tr></table></figure>



<hr/>

<h3 id="8-错误边界"><a href="#8-错误边界" class="headerlink" title="8. 错误边界"></a>8. 错误边界</h3><h5 id="理解：-1"><a href="#理解：-1" class="headerlink" title="理解："></a>理解：</h5><p>错误边界(Error boundary)：用来捕获后代组件错误，渲染出备用页面</p>
<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><p>只能捕获<strong>后代组件生命周期</strong>产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误</p>
<h5 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h5><p>getDerivedStateFromError配合componentDidCatch</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生命周期函数，一旦后台组件报错，就会触发</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">getDerivedStateFromError</span>(<span class="params">error</span>)</span> </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="built_in">console</span>.log(error);    <span class="comment">// 在render之前触发    </span></span><br><span class="line">    <span class="comment">// 返回新的state    </span></span><br><span class="line">    <span class="keyword">return</span> &#123;        </span><br><span class="line">        <span class="attr">hasError</span>: <span class="literal">true</span>,    </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">componentDidCatch</span>(<span class="params">error, info</span>)</span> &#123;    <span class="comment">// 统计页面的错误。发送请求发送到后台去    console.log(error, info);&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="9-组件通信方式总结"><a href="#9-组件通信方式总结" class="headerlink" title="9. 组件通信方式总结"></a>9. 组件通信方式总结</h3><h5 id="组件间的关系："><a href="#组件间的关系：" class="headerlink" title="组件间的关系："></a>组件间的关系：</h5><ul>
<li>父子组件</li>
<li>兄弟组件（非嵌套组件）</li>
<li>祖孙组件（跨级组件）</li>
</ul>
<h5 id="几种通信方式："><a href="#几种通信方式：" class="headerlink" title="几种通信方式："></a>几种通信方式：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.props：		</span><br><span class="line">	(1).children props		</span><br><span class="line">	(2).render props	</span><br><span class="line">2.消息订阅-发布：		</span><br><span class="line">	pubs-sub、event等等	</span><br><span class="line">3.集中式管理：		</span><br><span class="line">	redux、dva等等	</span><br><span class="line">4.conText:		</span><br><span class="line">	生产者-消费者模式</span><br></pre></td></tr></table></figure>

<h5 id="比较好的搭配方式："><a href="#比较好的搭配方式：" class="headerlink" title="比较好的搭配方式："></a>比较好的搭配方式：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父子组件：props	</span><br><span class="line">兄弟组件：消息订阅-发布、集中式管理	</span><br><span class="line">祖孙组件(跨级组件)：消息订阅-发布、集中式管理、conText(开发用的少，封装插件用的多)</span><br></pre></td></tr></table></figure>





<h1 id="16-项目打包"><a href="#16-项目打包" class="headerlink" title="16. 项目打包"></a>16. 项目打包</h1><h5 id="1-打包"><a href="#1-打包" class="headerlink" title="1.打包"></a>1.打包</h5><p><code>npm run build</code></p>
<h5 id="2-开启服务器"><a href="#2-开启服务器" class="headerlink" title="2.开启服务器"></a>2.开启服务器</h5><blockquote>
<p>借用serve库</p>
</blockquote>
]]></content>
      <categories>
        <category>code</category>
        <category>frontend</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>React</tag>
      </tags>
  </entry>
</search>
